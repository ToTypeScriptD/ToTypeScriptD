declare module Windows.Foundation.Collections {

    enum CollectionChange {
        reset,
        itemInserted,
        itemRemoved,
        itemChanged
    }

    export interface IIterable<T> {
        first(): Windows.Foundation.Collections.IIterator<T>;
    }

    export interface IIterator<T> {
        current: T;
        hasCurrent: boolean;
        moveNext(): boolean;
        getMany(): { items: T[]; returnValue: number; };
    }

    export interface IKeyValuePair<K,V> {
        key: K;
        value: V;
    }

    export interface IMap<K,V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        size: number;
        lookup(key: K): V;
        hasKey(key: K): boolean;
        getView(): Windows.Foundation.Collections.IMapView<K,V>;
        insert(key: K, value: V): boolean;
        remove(key: K): void;
        clear(): void;
    }

    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }

    export interface IMapView<K,V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        size: number;
        lookup(key: K): V;
        hasKey(key: K): boolean;
        split(): { first: Windows.Foundation.Collections.IMapView<K,V>; second: Windows.Foundation.Collections.IMapView<K,V>; };
    }

    export interface IVectorChangedEventArgs {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        index: number;
    }
    export interface IPropertySet extends Windows.Foundation.Collections.IObservableMap<string, any>, Windows.Foundation.Collections.IMap<string, any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string, any>> {
    }
    export class PropertySet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string, any>, Windows.Foundation.Collections.IMap<string, any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string, any>> {
        size: number;
        onmapchanged: any/* TODO */;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string, any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string, any>>;
    }
    interface IVectorView<T> extends Windows.Foundation.Collections.IIterable<T> {
        size: number;
        getAt(index: number): T;
        indexOf(value: T): { index: number; returnValue: boolean; };
        getMany(startIndex: number): { items: T[]; returnValue: number; };

        toString(): string;
        toLocaleString(): string;
        concat(...items: T[][]): T[];
        join(seperator: string): string;
        pop(): T;
        push(...items: T[]): void;
        reverse(): T[];
        shift(): T;
        slice(start: number): T[];
        slice(start: number, end: number): T[];
        sort(): T[];
        sort(compareFn: (a: T, b: T) => number): T[];
        splice(start: number): T[];
        splice(start: number, deleteCount: number, ...items: T[]): T[];
        unshift(...items: T[]): number;
        lastIndexOf(searchElement: T): number;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void ): void;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void , thisArg: any): void;
        map(callbackfn: (value: T, index: number, array: T[]) => any): any[];
        map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): T[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        length: number;
    }
    interface IVector<T> extends Windows.Foundation.Collections.IIterable<T> {
        size: number;
        getAt(index: number): T;
        getView(): Windows.Foundation.Collections.IVectorView<T>;
        indexOf(value: T): { index: number; returnValue: boolean; };
        setAt(index: number, value: T): void;
        insertAt(index: number, value: T): void;
        removeAt(index: number): void;
        append(value: T): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): { items: T[]; returnValue: number; };
        replaceAll(items: T[]): void;

        toString(): string;
        toLocaleString(): string;
        concat(...items: T[][]): T[];
        join(seperator: string): string;
        pop(): T;
        push(...items: T[]): void;
        reverse(): T[];
        shift(): T;
        slice(start: number): T[];
        slice(start: number, end: number): T[];
        sort(): T[];
        sort(compareFn: (a: T, b: T) => number): T[];
        splice(start: number): T[];
        splice(start: number, deleteCount: number, ...items: T[]): T[];
        unshift(...items: T[]): number;
        lastIndexOf(searchElement: T): number;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void ): void;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void , thisArg: any): void;
        map(callbackfn: (value: T, index: number, array: T[]) => any): any[];
        map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): T[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        length: number;
    }

    export interface VectorChangedEventHandler<T> {
        (sender: Windows.Foundation.Collections.IObservableVector<T>, event: Windows.Foundation.Collections.IVectorChangedEventArgs): void;
    }
    export interface IObservableVector<T> extends Windows.Foundation.Collections.IVector<T>, Windows.Foundation.Collections.IIterable<T> {
        onvectorchanged: any/* TODO */;
    }
    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }
    export interface MapChangedEventHandler<K,V> {
        (sender: Windows.Foundation.Collections.IObservableMap<K,V>, event: Windows.Foundation.Collections.IMapChangedEventArgs<K>): void;
    }
    export interface IObservableMap<K,V> extends Windows.Foundation.Collections.IMap<K,V>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        onmapchanged: any/* TODO */;
    }
}