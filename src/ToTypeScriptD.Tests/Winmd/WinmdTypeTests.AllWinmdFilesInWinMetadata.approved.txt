

//****************************************************************
//  Generated by:  ToTypeScriptD
//  Website:       http://github.com/ToTypeScriptD/ToTypeScriptD
//  Version:       v0.0.0000.0000 SHA1:0000000 - Debug
//  Date:          mm/dd/YYYY H:MM:SS PM
//
//  Assemblies:
//    Windows.ApplicationModel.winmd
//    Windows.Data.winmd
//    Windows.Devices.winmd
//    Windows.Foundation.winmd
//    Windows.Globalization.winmd
//    Windows.Graphics.winmd
//    Windows.Management.winmd
//    Windows.Media.winmd
//    Windows.Networking.winmd
//    Windows.Security.winmd
//    Windows.Storage.winmd
//    Windows.System.winmd
//    Windows.UI.winmd
//    Windows.UI.Xaml.winmd
//    Windows.Web.winmd
//
//****************************************************************



declare module Windows.ApplicationModel.Activation {

    enum ActivationKind {
        launch,
        search,
        shareTarget,
        file,
        protocol,
        fileOpenPicker,
        fileSavePicker,
        cachedFileUpdater,
        contactPicker,
        device,
        printTaskSettings,
        cameraSettings
    }

    enum ApplicationExecutionState {
        notRunning,
        running,
        suspended,
        terminated,
        closedByUser
    }

    export class CachedFileUpdaterActivatedEventArgs implements Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class CameraSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        videoDeviceController: any;
        videoDeviceExtension: any;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ContactPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class DeviceActivatedEventArgs implements Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        deviceInformationId: string;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileOpenPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class FileSavePickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export interface IActivatedEventArgs {
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export interface ICachedFileUpdaterActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
    }

    export interface ICameraSettingsActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        videoDeviceController: any;
        videoDeviceExtension: any;
    }

    export interface IContactPickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
    }

    export interface IDeviceActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        deviceInformationId: string;
        verb: string;
    }

    export interface IFileActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
    }

    export interface IFileOpenPickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
    }

    export interface IFileSavePickerActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
    }

    export interface ILaunchActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        arguments: string;
        tileId: string;
    }

    export interface IPrintTaskSettingsActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
    }

    export interface IProtocolActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        uri: Windows.Foundation.Uri;
    }

    export interface ISearchActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        language: string;
        queryText: string;
    }

    export interface IShareTargetActivatedEventArgs extends Windows.ApplicationModel.Activation.IActivatedEventArgs {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
    }

    export interface ISplashScreen {
        add_Dismissed(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): Windows.Foundation.EventRegistrationToken;
        remove_Dismissed(cookie: Windows.Foundation.EventRegistrationToken): void;
        imageLocation: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>) => void;

    }

    export class LaunchActivatedEventArgs implements Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        arguments: string;
        tileId: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class PrintTaskSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ProtocolActivatedEventArgs implements Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        uri: Windows.Foundation.Uri;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class SearchActivatedEventArgs implements Windows.ApplicationModel.Activation.ISearchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        language: string;
        queryText: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class ShareTargetActivatedEventArgs implements Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
    }

    export class SplashScreen implements Windows.ApplicationModel.Activation.ISplashScreen {
        add_Dismissed(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): Windows.Foundation.EventRegistrationToken;
        remove_Dismissed(cookie: Windows.Foundation.EventRegistrationToken): void;
        imageLocation: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Activation.SplashScreen,any>) => void;

    }

}
declare module Windows.ApplicationModel.Background {

    enum BackgroundAccessStatus {
        unspecified,
        allowedWithAlwaysOnRealTimeConnectivity,
        allowedMayUseActiveRealTimeConnectivity,
        denied
    }

    export class BackgroundExecutionManager {
        static requestAccessAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>;
        static requestAccessAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Background.BackgroundAccessStatus>;
        static removeAccess(): void;
        static removeAccess(applicationId: string): void;
        static getAccessStatus(): Windows.ApplicationModel.Background.BackgroundAccessStatus;
        static getAccessStatus(applicationId: string): Windows.ApplicationModel.Background.BackgroundAccessStatus;
    }

    export class BackgroundTaskBuilder implements Windows.ApplicationModel.Background.IBackgroundTaskBuilder {
        constructor();
        setTrigger(trigger: Windows.ApplicationModel.Background.IBackgroundTrigger): void;
        addCondition(condition: Windows.ApplicationModel.Background.IBackgroundCondition): void;
        register(): Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        name: string;
        taskEntryPoint: string;
    }

    export interface BackgroundTaskCanceledEventHandler {
        target: Windows.ApplicationModel.Background.IBackgroundTaskInstance;
        detail: any[];
        type: string;
    }

    enum BackgroundTaskCancellationReason {
        abort,
        terminating,
        loggingOff,
        servicingUpdate
    }

    export class BackgroundTaskCompletedEventArgs implements Windows.ApplicationModel.Background.IBackgroundTaskCompletedEventArgs {
        checkResult(): void;
        instanceId: string;
    }

    export interface BackgroundTaskCompletedEventHandler {
        target: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        detail: any[];
        type: string;
    }

    export class BackgroundTaskDeferral implements Windows.ApplicationModel.Background.IBackgroundTaskDeferral {
        complete(): void;
    }

    export class BackgroundTaskProgressEventArgs implements Windows.ApplicationModel.Background.IBackgroundTaskProgressEventArgs {
        instanceId: string;
        progress: number;
    }

    export interface BackgroundTaskProgressEventHandler {
        target: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        detail: any[];
        type: string;
    }

    export class BackgroundTaskRegistration implements Windows.ApplicationModel.Background.IBackgroundTaskRegistration {
        add_Progress(handler: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Progress(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(handler: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Completed(cookie: Windows.Foundation.EventRegistrationToken): void;
        unregister(cancelTask: boolean): void;
        name: string;
        taskId: string;
        static allTasks: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Background.IBackgroundTaskRegistration>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        removeEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        oncompleted: (ev: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler) => void;
        addEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        removeEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        onprogress: (ev: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler) => void;

    }

    export interface IBackgroundCondition {
    }

    export interface IBackgroundTask {
        run(taskInstance: Windows.ApplicationModel.Background.IBackgroundTaskInstance): void;
    }

    export interface IBackgroundTaskBuilder {
        setTrigger(trigger: Windows.ApplicationModel.Background.IBackgroundTrigger): void;
        addCondition(condition: Windows.ApplicationModel.Background.IBackgroundCondition): void;
        register(): Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        name: string;
        taskEntryPoint: string;
    }

    export interface IBackgroundTaskCompletedEventArgs {
        checkResult(): void;
        instanceId: string;
    }

    export interface IBackgroundTaskDeferral {
        complete(): void;
    }

    export interface IBackgroundTaskInstance {
        add_Canceled(cancelHandler: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Canceled(cookie: Windows.Foundation.EventRegistrationToken): void;
        getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral;
        instanceId: string;
        progress: number;
        suspendedCount: number;
        task: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        triggerDetails: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        removeEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        oncanceled: (ev: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler) => void;

    }

    export interface IBackgroundTaskProgressEventArgs {
        instanceId: string;
        progress: number;
    }

    export interface IBackgroundTaskRegistration {
        add_Progress(handler: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Progress(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(handler: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Completed(cookie: Windows.Foundation.EventRegistrationToken): void;
        unregister(cancelTask: boolean): void;
        name: string;
        taskId: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        removeEventListener(eventName: "completed", listener: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler): void;
        oncompleted: (ev: Windows.ApplicationModel.Background.BackgroundTaskCompletedEventHandler) => void;
        addEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        removeEventListener(eventName: "progress", listener: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler): void;
        onprogress: (ev: Windows.ApplicationModel.Background.BackgroundTaskProgressEventHandler) => void;

    }

    export interface IBackgroundTrigger {
    }

    export interface IMaintenanceTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        freshnessTime: number;
        oneShot: boolean;
    }

    export interface INetworkOperatorHotspotAuthenticationTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
    }

    export interface INetworkOperatorNotificationTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        networkAccountId: string;
    }

    export interface ISystemCondition extends Windows.ApplicationModel.Background.IBackgroundCondition {
        conditionType: Windows.ApplicationModel.Background.SystemConditionType;
    }

    export interface ISystemTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        oneShot: boolean;
        triggerType: Windows.ApplicationModel.Background.SystemTriggerType;
    }

    export interface ITimeTrigger extends Windows.ApplicationModel.Background.IBackgroundTrigger {
        freshnessTime: number;
        oneShot: boolean;
    }

    export class MaintenanceTrigger implements Windows.ApplicationModel.Background.IMaintenanceTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(freshnessTime: number, oneShot: boolean);
        freshnessTime: number;
        oneShot: boolean;
    }

    export class NetworkOperatorHotspotAuthenticationTrigger implements Windows.ApplicationModel.Background.INetworkOperatorHotspotAuthenticationTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor();
    }

    export class NetworkOperatorNotificationTrigger implements Windows.ApplicationModel.Background.INetworkOperatorNotificationTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(networkAccountId: string);
        networkAccountId: string;
    }

    export class PushNotificationTrigger implements Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(applicationId: string);
        constructor();
    }

    export class SystemCondition implements Windows.ApplicationModel.Background.ISystemCondition, Windows.ApplicationModel.Background.IBackgroundCondition {
        constructor(conditionType: Windows.ApplicationModel.Background.SystemConditionType);
        conditionType: Windows.ApplicationModel.Background.SystemConditionType;
    }

    enum SystemConditionType {
        invalid,
        userPresent,
        userNotPresent,
        internetAvailable,
        internetNotAvailable,
        sessionConnected,
        sessionDisconnected
    }

    export class SystemTrigger implements Windows.ApplicationModel.Background.ISystemTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(triggerType: Windows.ApplicationModel.Background.SystemTriggerType, oneShot: boolean);
        oneShot: boolean;
        triggerType: Windows.ApplicationModel.Background.SystemTriggerType;
    }

    enum SystemTriggerType {
        invalid,
        smsReceived,
        userPresent,
        userAway,
        networkStateChange,
        controlChannelReset,
        internetAvailable,
        sessionConnected,
        servicingComplete,
        lockScreenApplicationAdded,
        lockScreenApplicationRemoved,
        timeZoneChange,
        onlineIdConnectedStateChange
    }

    export class TimeTrigger implements Windows.ApplicationModel.Background.ITimeTrigger, Windows.ApplicationModel.Background.IBackgroundTrigger {
        constructor(freshnessTime: number, oneShot: boolean);
        freshnessTime: number;
        oneShot: boolean;
    }

}
declare module Windows.ApplicationModel.Contacts {

    export class Contact implements Windows.ApplicationModel.Contacts.IContact {
        constructor();
        fields: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.IContactField>;
        name: string;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
    }

    export class ContactField implements Windows.ApplicationModel.Contacts.IContactField {
        constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType);
        constructor(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    enum ContactFieldCategory {
        none,
        home,
        work,
        mobile,
        other
    }

    export class ContactFieldFactory implements Windows.ApplicationModel.Contacts.IContactFieldFactory, Windows.ApplicationModel.Contacts.IContactLocationFieldFactory, Windows.ApplicationModel.Contacts.IContactInstantMessageFieldFactory {
        constructor();
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType): Windows.ApplicationModel.Contacts.ContactField;
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createField(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createLocation(unstructuredAddress: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createInstantMessage(userName: string): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
    }

    enum ContactFieldType {
        email,
        phoneNumber,
        location,
        instantMessage,
        custom
    }

    export class ContactInformation implements Windows.ApplicationModel.Contacts.IContactInformation {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        queryCustomFields(customName: string): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        customFields: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        emails: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        instantMessages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInstantMessageField>;
        locations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactLocationField>;
        name: string;
        phoneNumbers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
    }

    export class ContactInstantMessageField implements Windows.ApplicationModel.Contacts.IContactInstantMessageField, Windows.ApplicationModel.Contacts.IContactField {
        constructor(userName: string);
        constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri);
        displayText: string;
        launchUri: Windows.Foundation.Uri;
        service: string;
        userName: string;
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export class ContactLocationField implements Windows.ApplicationModel.Contacts.IContactLocationField, Windows.ApplicationModel.Contacts.IContactField {
        constructor(unstructuredAddress: string);
        constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory);
        constructor(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string);
        city: string;
        country: string;
        postalCode: string;
        region: string;
        street: string;
        unstructuredAddress: string;
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export class ContactPicker implements Windows.ApplicationModel.Contacts.IContactPicker {
        constructor();
        pickSingleContactAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Contacts.ContactInformation>;
        pickMultipleContactsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInformation>>;
        commitButtonText: string;
        desiredFields: Windows.Foundation.Collections.IVector<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
    }

    enum ContactSelectionMode {
        contacts,
        fields
    }

    export interface IContact {
        fields: Windows.Foundation.Collections.IVector<Windows.ApplicationModel.Contacts.IContactField>;
        name: string;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
    }

    export interface IContactField {
        category: Windows.ApplicationModel.Contacts.ContactFieldCategory;
        name: string;
        type: Windows.ApplicationModel.Contacts.ContactFieldType;
        value: string;
    }

    export interface IContactFieldFactory {
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType): Windows.ApplicationModel.Contacts.ContactField;
        createField(value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
        createField(name: string, value: string, type: Windows.ApplicationModel.Contacts.ContactFieldType, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactField;
    }

    export interface IContactInformation {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        queryCustomFields(customName: string): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        customFields: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        emails: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
        instantMessages: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInstantMessageField>;
        locations: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactLocationField>;
        name: string;
        phoneNumbers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactField>;
    }

    export interface IContactInstantMessageField extends Windows.ApplicationModel.Contacts.IContactField {
        displayText: string;
        launchUri: Windows.Foundation.Uri;
        service: string;
        userName: string;
    }

    export interface IContactInstantMessageFieldFactory {
        createInstantMessage(userName: string): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
        createInstantMessage(userName: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, service: string, displayText: string, verb: Windows.Foundation.Uri): Windows.ApplicationModel.Contacts.ContactInstantMessageField;
    }

    export interface IContactLocationField extends Windows.ApplicationModel.Contacts.IContactField {
        city: string;
        country: string;
        postalCode: string;
        region: string;
        street: string;
        unstructuredAddress: string;
    }

    export interface IContactLocationFieldFactory {
        createLocation(unstructuredAddress: string): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory): Windows.ApplicationModel.Contacts.ContactLocationField;
        createLocation(unstructuredAddress: string, category: Windows.ApplicationModel.Contacts.ContactFieldCategory, street: string, city: string, region: string, country: string, postalCode: string): Windows.ApplicationModel.Contacts.ContactLocationField;
    }

    export interface IContactPicker {
        pickSingleContactAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Contacts.ContactInformation>;
        pickMultipleContactsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Contacts.ContactInformation>>;
        commitButtonText: string;
        desiredFields: Windows.Foundation.Collections.IVector<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
    }

    export class KnownContactField {
        static convertNameToType(name: string): Windows.ApplicationModel.Contacts.ContactFieldType;
        static convertTypeToName(type: Windows.ApplicationModel.Contacts.ContactFieldType): string;
        static email: string;
        static instantMessage: string;
        static location: string;
        static phoneNumber: string;
    }

}
declare module Windows.ApplicationModel.Contacts.Provider {

    enum AddContactResult {
        added,
        alreadyAdded,
        unavailable
    }

    export class ContactPickerUI implements Windows.ApplicationModel.Contacts.Provider.IContactPickerUI {
        addContact(id: string, contact: Windows.ApplicationModel.Contacts.Contact): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
        removeContact(id: string): void;
        containsContact(id: string): boolean;
        add_ContactRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ContactRemoved(token: Windows.Foundation.EventRegistrationToken): void;
        desiredFields: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        removeEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        oncontactremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>) => void;

    }

    export class ContactRemovedEventArgs implements Windows.ApplicationModel.Contacts.Provider.IContactRemovedEventArgs {
        id: string;
    }

    export interface IContactPickerUI {
        addContact(id: string, contact: Windows.ApplicationModel.Contacts.Contact): Windows.ApplicationModel.Contacts.Provider.AddContactResult;
        removeContact(id: string): void;
        containsContact(id: string): boolean;
        add_ContactRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ContactRemoved(token: Windows.Foundation.EventRegistrationToken): void;
        desiredFields: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.ApplicationModel.Contacts.ContactSelectionMode;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        removeEventListener(eventName: "contactremoved", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>): void;
        oncontactremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Contacts.Provider.ContactPickerUI,Windows.ApplicationModel.Contacts.Provider.ContactRemovedEventArgs>) => void;

    }

    export interface IContactRemovedEventArgs {
        id: string;
    }

}
declare module Windows.ApplicationModel.Core {

    export class CoreApplication {
        static incrementApplicationUseCount(): void;
        static decrementApplicationUseCount(): void;
        static createNewView(runtimeType: string, entryPoint: string): Windows.ApplicationModel.Core.CoreApplicationView;
        static exit(): void;
        static add_Exiting(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_Exiting(token: Windows.Foundation.EventRegistrationToken): void;
        static add_Suspending(handler: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>): Windows.Foundation.EventRegistrationToken;
        static remove_Suspending(token: Windows.Foundation.EventRegistrationToken): void;
        static add_Resuming(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_Resuming(token: Windows.Foundation.EventRegistrationToken): void;
        static getCurrentView(): Windows.ApplicationModel.Core.CoreApplicationView;
        static run(viewSource: Windows.ApplicationModel.Core.IFrameworkViewSource): void;
        static runWithActivationFactories(activationFactoryCallback: Windows.Foundation.IGetActivationFactory): void;
        static mainView: Windows.ApplicationModel.Core.CoreApplicationView;
        static views: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Core.CoreApplicationView>;
        static id: string;
        static properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "exiting", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "exiting", listener: Windows.Foundation.EventHandler<any>): void;
        onexiting: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        onresuming: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "suspending", listener: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>): void;
        removeEventListener(eventName: "suspending", listener: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>): void;
        onsuspending: (ev: Windows.Foundation.EventHandler<Windows.ApplicationModel.SuspendingEventArgs>) => void;

    }

    export class CoreApplicationView implements Windows.ApplicationModel.Core.ICoreApplicationView {
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(token: Windows.Foundation.EventRegistrationToken): void;
        coreWindow: Windows.UI.Core.CoreWindow;
        isHosted: boolean;
        isMain: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>) => void;

    }

    export interface ICoreApplicationView {
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(token: Windows.Foundation.EventRegistrationToken): void;
        coreWindow: Windows.UI.Core.CoreWindow;
        isHosted: boolean;
        isMain: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Core.CoreApplicationView,Windows.ApplicationModel.Activation.IActivatedEventArgs>) => void;

    }

    export interface IFrameworkView {
        initialize(applicationView: Windows.ApplicationModel.Core.CoreApplicationView): void;
        setWindow(window: Windows.UI.Core.CoreWindow): void;
        load(entryPoint: string): void;
        run(): void;
        uninitialize(): void;
    }

    export interface IFrameworkViewSource {
        createView(): Windows.ApplicationModel.Core.IFrameworkView;
    }

}
declare module Windows.ApplicationModel.DataTransfer {

    export class Clipboard {
        static getContent(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        static setContent(content: Windows.ApplicationModel.DataTransfer.DataPackage): void;
        static flush(): void;
        static clear(): void;
        static add_ContentChanged(changeHandler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_ContentChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "contentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        oncontentchanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class DataPackage implements Windows.ApplicationModel.DataTransfer.IDataPackage {
        constructor();
        getView(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        add_OperationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OperationCompleted(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Destroyed(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): Windows.Foundation.EventRegistrationToken;
        remove_Destroyed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        setData(formatId: string, value: any): void;
        setDataProvider(formatId: string, delayRenderer: Windows.ApplicationModel.DataTransfer.DataProviderHandler): void;
        setText(value: string): void;
        setUri(value: Windows.Foundation.Uri): void;
        setHtmlFormat(value: string): void;
        setRtf(value: string): void;
        setBitmap(value: Windows.Storage.Streams.RandomAccessStreamReference): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>, readOnly: boolean): void;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
        resourceMap: Windows.Foundation.Collections.IMap<string,Windows.Storage.Streams.RandomAccessStreamReference>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        removeEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        ondestroyed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>) => void;
        addEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        removeEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        onoperationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>) => void;

    }

    enum DataPackageOperation {
        none,
        copy,
        move,
        link
    }

    export class DataPackagePropertySet implements Windows.ApplicationModel.DataTransfer.IDataPackagePropertySet, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
        size: number;
    }

    export class DataPackagePropertySetView implements Windows.ApplicationModel.DataTransfer.IDataPackagePropertySetView, Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        split(): DataPackagePropertySetView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVectorView<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
        size: number;
    }

    interface DataPackagePropertySetView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,any>;
        second: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DataPackageView implements Windows.ApplicationModel.DataTransfer.IDataPackageView {
        reportOperationCompleted(value: Windows.ApplicationModel.DataTransfer.DataPackageOperation): void;
        contains(formatId: string): boolean;
        getDataAsync(formatId: string): Windows.Foundation.IAsyncOperation<any>;
        getTextAsync(): Windows.Foundation.IAsyncOperation<string>;
        getTextAsync(formatId: string): Windows.Foundation.IAsyncOperation<string>;
        getUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        getHtmlFormatAsync(): Windows.Foundation.IAsyncOperation<string>;
        getResourceMapAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMapView<string,Windows.Storage.Streams.RandomAccessStreamReference>>;
        getRtfAsync(): Windows.Foundation.IAsyncOperation<string>;
        getBitmapAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
        getStorageItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        availableFormats: Windows.Foundation.Collections.IVectorView<string>;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export class DataProviderDeferral implements Windows.ApplicationModel.DataTransfer.IDataProviderDeferral {
        complete(): void;
    }

    export interface DataProviderHandler {
        target: Windows.ApplicationModel.DataTransfer.DataProviderRequest;
        detail: any[];
        type: string;
    }

    export class DataProviderRequest implements Windows.ApplicationModel.DataTransfer.IDataProviderRequest {
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataProviderDeferral;
        setData(value: any): void;
        deadline: Date;
        formatId: string;
    }

    export class DataRequest implements Windows.ApplicationModel.DataTransfer.IDataRequest {
        failWithDisplayText(value: string): void;
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataRequestDeferral;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        deadline: Date;
    }

    export class DataRequestDeferral implements Windows.ApplicationModel.DataTransfer.IDataRequestDeferral {
        complete(): void;
    }

    export class DataRequestedEventArgs implements Windows.ApplicationModel.DataTransfer.IDataRequestedEventArgs {
        request: Windows.ApplicationModel.DataTransfer.DataRequest;
    }

    export class DataTransferManager implements Windows.ApplicationModel.DataTransfer.IDataTransferManager {
        add_DataRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_DataRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_TargetApplicationChosen(eventHandler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TargetApplicationChosen(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        static showShareUI(): void;
        static getForCurrentView(): Windows.ApplicationModel.DataTransfer.DataTransferManager;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        removeEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        ondatarequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>) => void;
        addEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        removeEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        ontargetapplicationchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>) => void;

    }

    export class HtmlFormatHelper {
        static getStaticFragment(htmlFormat: string): string;
        static createHtmlFormat(htmlFragment: string): string;
    }

    export interface IDataPackage {
        getView(): Windows.ApplicationModel.DataTransfer.DataPackageView;
        add_OperationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OperationCompleted(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Destroyed(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): Windows.Foundation.EventRegistrationToken;
        remove_Destroyed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        setData(formatId: string, value: any): void;
        setDataProvider(formatId: string, delayRenderer: Windows.ApplicationModel.DataTransfer.DataProviderHandler): void;
        setText(value: string): void;
        setUri(value: Windows.Foundation.Uri): void;
        setHtmlFormat(value: string): void;
        setRtf(value: string): void;
        setBitmap(value: Windows.Storage.Streams.RandomAccessStreamReference): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>): void;
        setStorageItems(value: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageItem>, readOnly: boolean): void;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
        resourceMap: Windows.Foundation.Collections.IMap<string,Windows.Storage.Streams.RandomAccessStreamReference>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        removeEventListener(eventName: "destroyed", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>): void;
        ondestroyed: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,any>) => void;
        addEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        removeEventListener(eventName: "operationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>): void;
        onoperationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataPackage,Windows.ApplicationModel.DataTransfer.OperationCompletedEventArgs>) => void;

    }

    export interface IDataPackagePropertySet extends Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export interface IDataPackagePropertySetView extends Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        applicationListingUri: Windows.Foundation.Uri;
        applicationName: string;
        description: string;
        fileTypes: Windows.Foundation.Collections.IVectorView<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export interface IDataPackageView {
        reportOperationCompleted(value: Windows.ApplicationModel.DataTransfer.DataPackageOperation): void;
        contains(formatId: string): boolean;
        getDataAsync(formatId: string): Windows.Foundation.IAsyncOperation<any>;
        getTextAsync(): Windows.Foundation.IAsyncOperation<string>;
        getTextAsync(formatId: string): Windows.Foundation.IAsyncOperation<string>;
        getUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        getHtmlFormatAsync(): Windows.Foundation.IAsyncOperation<string>;
        getResourceMapAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMapView<string,Windows.Storage.Streams.RandomAccessStreamReference>>;
        getRtfAsync(): Windows.Foundation.IAsyncOperation<string>;
        getBitmapAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.RandomAccessStreamReference>;
        getStorageItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        availableFormats: Windows.Foundation.Collections.IVectorView<string>;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySetView;
        requestedOperation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export interface IDataProviderDeferral {
        complete(): void;
    }

    export interface IDataProviderRequest {
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataProviderDeferral;
        setData(value: any): void;
        deadline: Date;
        formatId: string;
    }

    export interface IDataRequest {
        failWithDisplayText(value: string): void;
        getDeferral(): Windows.ApplicationModel.DataTransfer.DataRequestDeferral;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        deadline: Date;
    }

    export interface IDataRequestDeferral {
        complete(): void;
    }

    export interface IDataRequestedEventArgs {
        request: Windows.ApplicationModel.DataTransfer.DataRequest;
    }

    export interface IDataTransferManager {
        add_DataRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_DataRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_TargetApplicationChosen(eventHandler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TargetApplicationChosen(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        removeEventListener(eventName: "datarequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>): void;
        ondatarequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.DataRequestedEventArgs>) => void;
        addEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        removeEventListener(eventName: "targetapplicationchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>): void;
        ontargetapplicationchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.DataTransfer.DataTransferManager,Windows.ApplicationModel.DataTransfer.TargetApplicationChosenEventArgs>) => void;

    }

    export interface IOperationCompletedEventArgs {
        operation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export interface ITargetApplicationChosenEventArgs {
        applicationName: string;
    }

    export class OperationCompletedEventArgs implements Windows.ApplicationModel.DataTransfer.IOperationCompletedEventArgs {
        operation: Windows.ApplicationModel.DataTransfer.DataPackageOperation;
    }

    export class StandardDataFormats {
        static bitmap: string;
        static html: string;
        static rtf: string;
        static storageItems: string;
        static text: string;
        static uri: string;
    }

    export class TargetApplicationChosenEventArgs implements Windows.ApplicationModel.DataTransfer.ITargetApplicationChosenEventArgs {
        applicationName: string;
    }

}
declare module Windows.ApplicationModel.DataTransfer.ShareTarget {

    export interface IQuickLink {
        id: string;
        supportedDataFormats: Windows.Foundation.Collections.IVector<string>;
        supportedFileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export interface IShareOperation {
        removeThisQuickLink(): void;
        reportStarted(): void;
        reportDataRetrieved(): void;
        reportSubmittedBackgroundTask(): void;
        reportCompleted(quicklink: Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
        reportCompleted(): void;
        reportError(value: string): void;
        data: Windows.ApplicationModel.DataTransfer.DataPackageView;
        quickLinkId: string;
    }

    export class QuickLink implements Windows.ApplicationModel.DataTransfer.ShareTarget.IQuickLink {
        constructor();
        id: string;
        supportedDataFormats: Windows.Foundation.Collections.IVector<string>;
        supportedFileTypes: Windows.Foundation.Collections.IVector<string>;
        thumbnail: Windows.Storage.Streams.RandomAccessStreamReference;
        title: string;
    }

    export class ShareOperation implements Windows.ApplicationModel.DataTransfer.ShareTarget.IShareOperation {
        removeThisQuickLink(): void;
        reportStarted(): void;
        reportDataRetrieved(): void;
        reportSubmittedBackgroundTask(): void;
        reportCompleted(quicklink: Windows.ApplicationModel.DataTransfer.ShareTarget.QuickLink): void;
        reportCompleted(): void;
        reportError(value: string): void;
        data: Windows.ApplicationModel.DataTransfer.DataPackageView;
        quickLinkId: string;
    }

}
declare module Windows.ApplicationModel {

    export class DesignMode {
        static designModeEnabled: boolean;
    }

    export interface IPackage {
        dependencies: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Package>;
        id: Windows.ApplicationModel.PackageId;
        installedLocation: Windows.Storage.StorageFolder;
        isFramework: boolean;
    }

    export interface IPackageId {
        architecture: Windows.System.ProcessorArchitecture;
        familyName: string;
        fullName: string;
        name: string;
        publisher: string;
        publisherId: string;
        resourceId: string;
        version: Windows.ApplicationModel.PackageVersion;
    }

    export interface ISuspendingDeferral {
        complete(): void;
    }

    export interface ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export interface ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

    export class Package implements Windows.ApplicationModel.IPackage {
        dependencies: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Package>;
        id: Windows.ApplicationModel.PackageId;
        installedLocation: Windows.Storage.StorageFolder;
        isFramework: boolean;
        static current: Windows.ApplicationModel.Package;
    }

    export class PackageId implements Windows.ApplicationModel.IPackageId {
        architecture: Windows.System.ProcessorArchitecture;
        familyName: string;
        fullName: string;
        name: string;
        publisher: string;
        publisherId: string;
        resourceId: string;
        version: Windows.ApplicationModel.PackageVersion;
    }

    export class PackageVersion {
        major: number;
        minor: number;
        build: number;
        revision: number;
    }

    export class SuspendingDeferral implements Windows.ApplicationModel.ISuspendingDeferral {
        complete(): void;
    }

    export class SuspendingEventArgs implements Windows.ApplicationModel.ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export class SuspendingOperation implements Windows.ApplicationModel.ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

}
declare module Windows.ApplicationModel.Resources.Core {

    export interface INamedResource {
        resolve(): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolve(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolveAll(): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        resolveAll(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        candidates: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        uri: Windows.Foundation.Uri;
    }

    export interface IResourceCandidate {
        getValueAsFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getQualifierValue(qualifierName: string): string;
        isDefault: boolean;
        isMatch: boolean;
        isMatchAsDefault: boolean;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        valueAsString: string;
    }

    export interface IResourceContext {
        reset(): void;
        reset(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
        overrideToMatch(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): void;
        clone(): Windows.ApplicationModel.Resources.Core.ResourceContext;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        qualifierValues: Windows.Foundation.Collections.IObservableMap<string,string>;
    }

    export interface IResourceManager {
        loadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        unloadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        allResourceMaps: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        defaultContext: Windows.ApplicationModel.Resources.Core.ResourceContext;
        mainResourceMap: Windows.ApplicationModel.Resources.Core.ResourceMap;
    }

    export interface IResourceMap extends Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        getValue(resource: string): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getValue(resource: string, context: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getSubtree(reference: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        uri: Windows.Foundation.Uri;
    }

    export interface IResourceQualifier {
        isDefault: boolean;
        isMatch: boolean;
        qualifierName: string;
        qualifierValue: string;
        score: number;
    }

    export class NamedResource implements Windows.ApplicationModel.Resources.Core.INamedResource {
        resolve(): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolve(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        resolveAll(): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        resolveAll(resourceContext: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        candidates: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        uri: Windows.Foundation.Uri;
    }

    export class ResourceCandidate implements Windows.ApplicationModel.Resources.Core.IResourceCandidate {
        getValueAsFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getQualifierValue(qualifierName: string): string;
        isDefault: boolean;
        isMatch: boolean;
        isMatchAsDefault: boolean;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        valueAsString: string;
    }

    export class ResourceCandidateVectorView implements Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceCandidate>, Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceCandidate> {
        getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        indexOf(value: Windows.ApplicationModel.Resources.Core.ResourceCandidate): ResourceCandidateVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceCandidateVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceCandidate>;
        size: number;
    }

    interface ResourceCandidateVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceCandidateVectorView_getMany_OUT {
        __returnValue: number;
        items: Windows.ApplicationModel.Resources.Core.ResourceCandidate[];
    }

    export class ResourceContext implements Windows.ApplicationModel.Resources.Core.IResourceContext {
        constructor();
        reset(): void;
        reset(qualifierNames: Windows.Foundation.Collections.IIterable<string>): void;
        overrideToMatch(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): void;
        clone(): Windows.ApplicationModel.Resources.Core.ResourceContext;
        static createMatchingContext(result: Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier>): Windows.ApplicationModel.Resources.Core.ResourceContext;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        qualifierValues: Windows.Foundation.Collections.IObservableMap<string,string>;
    }

    export class ResourceContextLanguagesVectorView implements Windows.Foundation.Collections.IVectorView<string>, Windows.Foundation.Collections.IIterable<string> {
        getAt(index: number): string;
        indexOf(value: string): ResourceContextLanguagesVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceContextLanguagesVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<string>;
        size: number;
    }

    interface ResourceContextLanguagesVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceContextLanguagesVectorView_getMany_OUT {
        __returnValue: number;
        items: string[];
    }

    export class ResourceManager implements Windows.ApplicationModel.Resources.Core.IResourceManager {
        loadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        unloadPriFiles(files: Windows.Foundation.Collections.IIterable<Windows.Storage.IStorageFile>): void;
        static isResourceReference(resourceReference: string): boolean;
        allResourceMaps: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        defaultContext: Windows.ApplicationModel.Resources.Core.ResourceContext;
        mainResourceMap: Windows.ApplicationModel.Resources.Core.ResourceMap;
        static current: Windows.ApplicationModel.Resources.Core.ResourceManager;
    }

    export class ResourceMap implements Windows.ApplicationModel.Resources.Core.IResourceMap, Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        getValue(resource: string): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getValue(resource: string, context: Windows.ApplicationModel.Resources.Core.ResourceContext): Windows.ApplicationModel.Resources.Core.ResourceCandidate;
        getSubtree(reference: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        lookup(key: string): Windows.ApplicationModel.Resources.Core.NamedResource;
        hasKey(key: string): boolean;
        split(): ResourceMap_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>>;
        uri: Windows.Foundation.Uri;
        size: number;
    }

    interface ResourceMap_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
        second: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
    }

    export class ResourceMapIterator implements Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>> {
        moveNext(): boolean;
        getMany(): ResourceMapIterator_getMany_OUT;
        current: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>;
        hasCurrent: boolean;
    }

    interface ResourceMapIterator_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.NamedResource>[];
    }

    export class ResourceMapMapView implements Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>> {
        lookup(key: string): Windows.ApplicationModel.Resources.Core.ResourceMap;
        hasKey(key: string): boolean;
        split(): ResourceMapMapView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>>;
        size: number;
    }

    interface ResourceMapMapView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        second: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
    }

    export class ResourceMapMapViewIterator implements Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>> {
        moveNext(): boolean;
        getMany(): ResourceMapMapViewIterator_getMany_OUT;
        current: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>;
        hasCurrent: boolean;
    }

    interface ResourceMapMapViewIterator_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.Collections.IKeyValuePair<string,Windows.ApplicationModel.Resources.Core.ResourceMap>[];
    }

    export class ResourceQualifier implements Windows.ApplicationModel.Resources.Core.IResourceQualifier {
        isDefault: boolean;
        isMatch: boolean;
        qualifierName: string;
        qualifierValue: string;
        score: number;
    }

    export class ResourceQualifierMapView implements Windows.Foundation.Collections.IMapView<string,string>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,string>> {
        lookup(key: string): string;
        hasKey(key: string): boolean;
        split(): ResourceQualifierMapView_split_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,string>>;
        size: number;
    }

    interface ResourceQualifierMapView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<string,string>;
        second: Windows.Foundation.Collections.IMapView<string,string>;
    }

    export class ResourceQualifierObservableMap implements Windows.Foundation.Collections.IObservableMap<string,string>, Windows.Foundation.Collections.IMap<string,string>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,string>> {
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): string;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,string>;
        insert(key: string, value: string): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,string>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,string>) => void;

    }

    export class ResourceQualifierVectorView implements Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Core.ResourceQualifier>, Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Resources.Core.ResourceQualifier> {
        getAt(index: number): Windows.ApplicationModel.Resources.Core.ResourceQualifier;
        indexOf(value: Windows.ApplicationModel.Resources.Core.ResourceQualifier): ResourceQualifierVectorView_indexOf_OUT;
        getMany(startIndex: number): ResourceQualifierVectorView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.ApplicationModel.Resources.Core.ResourceQualifier>;
        size: number;
    }

    interface ResourceQualifierVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ResourceQualifierVectorView_getMany_OUT {
        __returnValue: number;
        items: Windows.ApplicationModel.Resources.Core.ResourceQualifier[];
    }

}
declare module Windows.ApplicationModel.Resources {

    export interface IResourceLoader {
        getString(resource: string): string;
    }

    export class ResourceLoader implements Windows.ApplicationModel.Resources.IResourceLoader {
        constructor(name: string);
        constructor();
        getString(resource: string): string;
        static getStringForReference(uri: Windows.Foundation.Uri): string;
    }

}
declare module Windows.ApplicationModel.Resources.Management {

    export interface IIndexedResourceCandidate {
        getQualifierValue(qualifierName: string): string;
        metadata: Windows.Foundation.Collections.IMapView<string,string>;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceQualifier>;
        type: Windows.ApplicationModel.Resources.Management.IndexedResourceType;
        uri: Windows.Foundation.Uri;
        valueAsString: string;
    }

    export interface IIndexedResourceQualifier {
        qualifierName: string;
        qualifierValue: string;
    }

    export class IndexedResourceCandidate implements Windows.ApplicationModel.Resources.Management.IIndexedResourceCandidate {
        getQualifierValue(qualifierName: string): string;
        metadata: Windows.Foundation.Collections.IMapView<string,string>;
        qualifiers: Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceQualifier>;
        type: Windows.ApplicationModel.Resources.Management.IndexedResourceType;
        uri: Windows.Foundation.Uri;
        valueAsString: string;
    }

    export class IndexedResourceQualifier implements Windows.ApplicationModel.Resources.Management.IIndexedResourceQualifier {
        qualifierName: string;
        qualifierValue: string;
    }

    enum IndexedResourceType {
        string,
        path
    }

    export interface IResourceIndexer {
        indexFilePath(filePath: Windows.Foundation.Uri): Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate;
        indexFileContentsAsync(file: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate>>;
    }

    export class ResourceIndexer implements Windows.ApplicationModel.Resources.Management.IResourceIndexer {
        constructor(projectRoot: Windows.Foundation.Uri);
        indexFilePath(filePath: Windows.Foundation.Uri): Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate;
        indexFileContentsAsync(file: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.Resources.Management.IndexedResourceCandidate>>;
    }

}
declare module Windows.ApplicationModel.Search {

    export interface ILocalContentSuggestionSettings {
        aqsFilter: string;
        enabled: boolean;
        locations: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFolder>;
        propertiesToMatch: Windows.Foundation.Collections.IVector<string>;
    }

    export interface ISearchPane {
        add_VisibilityChanged(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_QueryChanged(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_QueryChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SuggestionsRequested(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SuggestionsRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_QuerySubmitted(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_QuerySubmitted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ResultSuggestionChosen(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ResultSuggestionChosen(token: Windows.Foundation.EventRegistrationToken): void;
        setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
        show(): void;
        show(query: string): void;
        trySetQueryText(query: string): boolean;
        language: string;
        placeholderText: string;
        queryText: string;
        searchHistoryContext: string;
        searchHistoryEnabled: boolean;
        showOnKeyboardInput: boolean;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        removeEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        onquerychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>) => void;
        addEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        removeEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        onquerysubmitted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>) => void;
        addEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        removeEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        onresultsuggestionchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>) => void;
        addEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        removeEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        onsuggestionsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>) => void;

    }

    export interface ISearchPaneQueryChangedEventArgs {
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export interface ISearchPaneQueryLinguisticDetails {
        queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
        queryTextCompositionLength: number;
        queryTextCompositionStart: number;
    }

    export interface ISearchPaneQuerySubmittedEventArgs {
        language: string;
        queryText: string;
    }

    export interface ISearchPaneResultSuggestionChosenEventArgs {
        tag: string;
    }

    export interface ISearchPaneSuggestionsRequest {
        getDeferral(): Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral;
        isCanceled: boolean;
        searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection;
    }

    export interface ISearchPaneSuggestionsRequestDeferral {
        complete(): void;
    }

    export interface ISearchPaneSuggestionsRequestedEventArgs extends Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        request: Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest;
    }

    export interface ISearchPaneVisibilityChangedEventArgs {
        visible: boolean;
    }

    export interface ISearchSuggestionCollection {
        appendQuerySuggestion(text: string): void;
        appendQuerySuggestions(suggestions: Windows.Foundation.Collections.IIterable<string>): void;
        appendResultSuggestion(text: string, detailText: string, tag: string, image: Windows.Storage.Streams.IRandomAccessStreamReference, imageAlternateText: string): void;
        appendSearchSeparator(label: string): void;
        size: number;
    }

    export class LocalContentSuggestionSettings implements Windows.ApplicationModel.Search.ILocalContentSuggestionSettings {
        constructor();
        aqsFilter: string;
        enabled: boolean;
        locations: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFolder>;
        propertiesToMatch: Windows.Foundation.Collections.IVector<string>;
    }

    export class SearchPane implements Windows.ApplicationModel.Search.ISearchPane {
        add_VisibilityChanged(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_QueryChanged(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_QueryChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SuggestionsRequested(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SuggestionsRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_QuerySubmitted(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_QuerySubmitted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ResultSuggestionChosen(handler: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ResultSuggestionChosen(token: Windows.Foundation.EventRegistrationToken): void;
        setLocalContentSuggestionSettings(settings: Windows.ApplicationModel.Search.LocalContentSuggestionSettings): void;
        show(): void;
        show(query: string): void;
        trySetQueryText(query: string): boolean;
        static getForCurrentView(): Windows.ApplicationModel.Search.SearchPane;
        language: string;
        placeholderText: string;
        queryText: string;
        searchHistoryContext: string;
        searchHistoryEnabled: boolean;
        showOnKeyboardInput: boolean;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        removeEventListener(eventName: "querychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>): void;
        onquerychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQueryChangedEventArgs>) => void;
        addEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        removeEventListener(eventName: "querysubmitted", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>): void;
        onquerysubmitted: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneQuerySubmittedEventArgs>) => void;
        addEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        removeEventListener(eventName: "resultsuggestionchosen", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>): void;
        onresultsuggestionchosen: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneResultSuggestionChosenEventArgs>) => void;
        addEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        removeEventListener(eventName: "suggestionsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>): void;
        onsuggestionsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestedEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.ApplicationModel.Search.SearchPane,Windows.ApplicationModel.Search.SearchPaneVisibilityChangedEventArgs>) => void;

    }

    export class SearchPaneQueryChangedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export class SearchPaneQueryLinguisticDetails implements Windows.ApplicationModel.Search.ISearchPaneQueryLinguisticDetails {
        queryTextAlternatives: Windows.Foundation.Collections.IVectorView<string>;
        queryTextCompositionLength: number;
        queryTextCompositionStart: number;
    }

    export class SearchPaneQuerySubmittedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneQuerySubmittedEventArgs {
        language: string;
        queryText: string;
    }

    export class SearchPaneResultSuggestionChosenEventArgs implements Windows.ApplicationModel.Search.ISearchPaneResultSuggestionChosenEventArgs {
        tag: string;
    }

    export class SearchPaneSuggestionsRequest implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequest {
        getDeferral(): Windows.ApplicationModel.Search.SearchPaneSuggestionsRequestDeferral;
        isCanceled: boolean;
        searchSuggestionCollection: Windows.ApplicationModel.Search.SearchSuggestionCollection;
    }

    export class SearchPaneSuggestionsRequestDeferral implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequestDeferral {
        complete(): void;
    }

    export class SearchPaneSuggestionsRequestedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneSuggestionsRequestedEventArgs, Windows.ApplicationModel.Search.ISearchPaneQueryChangedEventArgs {
        request: Windows.ApplicationModel.Search.SearchPaneSuggestionsRequest;
        language: string;
        linguisticDetails: Windows.ApplicationModel.Search.SearchPaneQueryLinguisticDetails;
        queryText: string;
    }

    export class SearchPaneVisibilityChangedEventArgs implements Windows.ApplicationModel.Search.ISearchPaneVisibilityChangedEventArgs {
        visible: boolean;
    }

    export class SearchSuggestionCollection implements Windows.ApplicationModel.Search.ISearchSuggestionCollection {
        appendQuerySuggestion(text: string): void;
        appendQuerySuggestions(suggestions: Windows.Foundation.Collections.IIterable<string>): void;
        appendResultSuggestion(text: string, detailText: string, tag: string, image: Windows.Storage.Streams.IRandomAccessStreamReference, imageAlternateText: string): void;
        appendSearchSeparator(label: string): void;
        size: number;
    }

}
declare module Windows.ApplicationModel.Store {

    export class CurrentApp {
        static requestAppPurchaseAsync(includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static requestProductPurchaseAsync(productId: string, includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static loadListingInformationAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
        static getAppReceiptAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getProductReceiptAsync(productId: string): Windows.Foundation.IAsyncOperation<string>;
        static appId: string;
        static licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
        static linkUri: Windows.Foundation.Uri;
    }

    export class CurrentAppSimulator {
        static requestAppPurchaseAsync(includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static requestProductPurchaseAsync(productId: string, includeReceipt: boolean): Windows.Foundation.IAsyncOperation<string>;
        static loadListingInformationAsync(): Windows.Foundation.IAsyncOperation<Windows.ApplicationModel.Store.ListingInformation>;
        static getAppReceiptAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getProductReceiptAsync(productId: string): Windows.Foundation.IAsyncOperation<string>;
        static reloadSimulatorAsync(simulatorSettingsFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncAction;
        static appId: string;
        static licenseInformation: Windows.ApplicationModel.Store.LicenseInformation;
        static linkUri: Windows.Foundation.Uri;
    }

    export interface ILicenseInformation {
        add_LicenseChanged(handler: Windows.ApplicationModel.Store.LicenseChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LicenseChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        expirationDate: Date;
        isActive: boolean;
        isTrial: boolean;
        productLicenses: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductLicense>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        removeEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        onlicensechanged: (ev: Windows.ApplicationModel.Store.LicenseChangedEventHandler) => void;

    }

    export interface IListingInformation {
        ageRating: number;
        currentMarket: string;
        description: string;
        formattedPrice: string;
        name: string;
        productListings: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductListing>;
    }

    export interface IProductLicense {
        expirationDate: Date;
        isActive: boolean;
        productId: string;
    }

    export interface IProductListing {
        formattedPrice: string;
        name: string;
        productId: string;
    }

    export interface LicenseChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class LicenseInformation implements Windows.ApplicationModel.Store.ILicenseInformation {
        add_LicenseChanged(handler: Windows.ApplicationModel.Store.LicenseChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LicenseChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        expirationDate: Date;
        isActive: boolean;
        isTrial: boolean;
        productLicenses: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductLicense>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        removeEventListener(eventName: "licensechanged", listener: Windows.ApplicationModel.Store.LicenseChangedEventHandler): void;
        onlicensechanged: (ev: Windows.ApplicationModel.Store.LicenseChangedEventHandler) => void;

    }

    export class ListingInformation implements Windows.ApplicationModel.Store.IListingInformation {
        ageRating: number;
        currentMarket: string;
        description: string;
        formattedPrice: string;
        name: string;
        productListings: Windows.Foundation.Collections.IMapView<string,Windows.ApplicationModel.Store.ProductListing>;
    }

    export class ProductLicense implements Windows.ApplicationModel.Store.IProductLicense {
        expirationDate: Date;
        isActive: boolean;
        productId: string;
    }

    export class ProductListing implements Windows.ApplicationModel.Store.IProductListing {
        formattedPrice: string;
        name: string;
        productId: string;
    }

}
declare module Windows.Data.Html {

    export class HtmlUtilities {
        static convertToText(html: string): string;
    }

}
declare module Windows.Data.Json {

    export interface IJsonArray extends Windows.Data.Json.IJsonValue {
        getObjectAt(index: number): Windows.Data.Json.JsonObject;
        getArrayAt(index: number): Windows.Data.Json.JsonArray;
        getStringAt(index: number): string;
        getNumberAt(index: number): number;
        getBooleanAt(index: number): boolean;
    }

    export interface IJsonObject extends Windows.Data.Json.IJsonValue {
        getNamedValue(name: string): Windows.Data.Json.JsonValue;
        setNamedValue(name: string, value: Windows.Data.Json.IJsonValue): void;
        getNamedObject(name: string): Windows.Data.Json.JsonObject;
        getNamedArray(name: string): Windows.Data.Json.JsonArray;
        getNamedString(name: string): string;
        getNamedNumber(name: string): number;
        getNamedBoolean(name: string): boolean;
    }

    export interface IJsonValue {
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        valueType: Windows.Data.Json.JsonValueType;
    }

    export class JsonArray implements Windows.Data.Json.IJsonArray, Windows.Data.Json.IJsonValue, Windows.Foundation.Collections.IVector<Windows.Data.Json.IJsonValue>, Windows.Foundation.Collections.IIterable<Windows.Data.Json.IJsonValue> {
        constructor();
        getObjectAt(index: number): Windows.Data.Json.JsonObject;
        getArrayAt(index: number): Windows.Data.Json.JsonArray;
        getStringAt(index: number): string;
        getNumberAt(index: number): number;
        getBooleanAt(index: number): boolean;
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        getAt(index: number): Windows.Data.Json.IJsonValue;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.Data.Json.IJsonValue>;
        indexOf(value: Windows.Data.Json.IJsonValue): JsonArray_indexOf_OUT;
        setAt(index: number, value: Windows.Data.Json.IJsonValue): void;
        insertAt(index: number, value: Windows.Data.Json.IJsonValue): void;
        removeAt(index: number): void;
        append(value: Windows.Data.Json.IJsonValue): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): JsonArray_getMany_OUT;
        replaceAll(items: Windows.Data.Json.IJsonValue[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Json.IJsonValue>;
        static parse(input: string): Windows.Data.Json.JsonArray;
        static tryParse(input: string): JsonArray_tryParse_OUT;
        valueType: Windows.Data.Json.JsonValueType;
        size: number;
    }

    interface JsonArray_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface JsonArray_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Json.IJsonValue[];
    }

    interface JsonArray_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonArray;
    }

    export class JsonError {
        static getStatus(hresult: number): Windows.Data.Json.JsonErrorStatus;
    }

    enum JsonErrorStatus {
        unknown,
        invalidJsonString,
        invalidJsonNumber,
        jsonValueNotFound,
        implementationLimit
    }

    export class JsonObject implements Windows.Data.Json.IJsonObject, Windows.Data.Json.IJsonValue, Windows.Foundation.Collections.IMap<string,Windows.Data.Json.IJsonValue>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Data.Json.IJsonValue>> {
        constructor();
        getNamedValue(name: string): Windows.Data.Json.JsonValue;
        setNamedValue(name: string, value: Windows.Data.Json.IJsonValue): void;
        getNamedObject(name: string): Windows.Data.Json.JsonObject;
        getNamedArray(name: string): Windows.Data.Json.JsonArray;
        getNamedString(name: string): string;
        getNamedNumber(name: string): number;
        getNamedBoolean(name: string): boolean;
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        lookup(key: string): Windows.Data.Json.IJsonValue;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Data.Json.IJsonValue>;
        insert(key: string, value: Windows.Data.Json.IJsonValue): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Data.Json.IJsonValue>>;
        static parse(input: string): Windows.Data.Json.JsonObject;
        static tryParse(input: string): JsonObject_tryParse_OUT;
        valueType: Windows.Data.Json.JsonValueType;
        size: number;
    }

    interface JsonObject_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonObject;
    }

    export class JsonValue implements Windows.Data.Json.IJsonValue {
        stringify(): string;
        getString(): string;
        getNumber(): number;
        getBoolean(): boolean;
        getArray(): Windows.Data.Json.JsonArray;
        getObject(): Windows.Data.Json.JsonObject;
        static parse(input: string): Windows.Data.Json.JsonValue;
        static tryParse(input: string): JsonValue_tryParse_OUT;
        static createBooleanValue(input: boolean): Windows.Data.Json.JsonValue;
        static createNumberValue(input: number): Windows.Data.Json.JsonValue;
        static createStringValue(input: string): Windows.Data.Json.JsonValue;
        valueType: Windows.Data.Json.JsonValueType;
    }

    interface JsonValue_tryParse_OUT {
        __returnValue: boolean;
        result: Windows.Data.Json.JsonValue;
    }

    enum JsonValueType {
        null,
        boolean,
        number,
        string,
        array,
        object
    }

}
declare module Windows.Data.Xml.Dom {

    export class DtdEntity implements Windows.Data.Xml.Dom.IDtdEntity, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        notationName: any;
        publicId: any;
        systemId: any;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class DtdNotation implements Windows.Data.Xml.Dom.IDtdNotation, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        publicId: any;
        systemId: any;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export interface IDtdEntity extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        notationName: any;
        publicId: any;
        systemId: any;
    }

    export interface IDtdNotation extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        publicId: any;
        systemId: any;
    }

    export interface IXmlAttribute extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        name: string;
        specified: boolean;
        value: string;
    }

    export interface IXmlCDataSection extends Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlCharacterData extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        data: string;
        length: number;
    }

    export interface IXmlComment extends Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlDocument extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        createElement(tagName: string): Windows.Data.Xml.Dom.XmlElement;
        createDocumentFragment(): Windows.Data.Xml.Dom.XmlDocumentFragment;
        createTextNode(data: string): Windows.Data.Xml.Dom.XmlText;
        createComment(data: string): Windows.Data.Xml.Dom.XmlComment;
        createProcessingInstruction(target: string, data: string): Windows.Data.Xml.Dom.XmlProcessingInstruction;
        createAttribute(name: string): Windows.Data.Xml.Dom.XmlAttribute;
        createEntityReference(name: string): Windows.Data.Xml.Dom.XmlEntityReference;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        createCDataSection(data: string): Windows.Data.Xml.Dom.XmlCDataSection;
        createAttributeNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlAttribute;
        createElementNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlElement;
        getElementById(elementId: string): Windows.Data.Xml.Dom.XmlElement;
        importNode(node: Windows.Data.Xml.Dom.IXmlNode, deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        doctype: Windows.Data.Xml.Dom.XmlDocumentType;
        documentElement: Windows.Data.Xml.Dom.XmlElement;
        documentUri: string;
        implementation: Windows.Data.Xml.Dom.XmlDomImplementation;
    }

    export interface IXmlDocumentFragment extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlDocumentIO {
        loadXml(xml: string): void;
        loadXml(xml: string, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): void;
        saveToFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
    }

    export interface IXmlDocumentType extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        entities: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        name: string;
        notations: Windows.Data.Xml.Dom.XmlNamedNodeMap;
    }

    export interface IXmlDomImplementation {
        hasFeature(feature: string, version: any): boolean;
    }

    export interface IXmlElement extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        getAttribute(attributeName: string): string;
        setAttribute(attributeName: string, attributeValue: string): void;
        removeAttribute(attributeName: string): void;
        getAttributeNode(attributeName: string): Windows.Data.Xml.Dom.XmlAttribute;
        setAttributeNode(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        removeAttributeNode(attributeNode: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
        getAttributeNS(namespaceUri: any, localName: string): string;
        removeAttributeNS(namespaceUri: any, localName: string): void;
        setAttributeNodeNS(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getAttributeNodeNS(namespaceUri: any, localName: string): Windows.Data.Xml.Dom.XmlAttribute;
        tagName: string;
    }

    export interface IXmlEntityReference extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
    }

    export interface IXmlLoadSettings {
        elementContentWhiteSpace: boolean;
        maxElementDepth: number;
        prohibitDtd: boolean;
        resolveExternals: boolean;
        validateOnParse: boolean;
    }

    export interface IXmlNamedNodeMap extends Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItem(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItemNS(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        length: number;
    }

    export interface IXmlNode extends Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
    }

    export interface IXmlNodeList extends Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        length: number;
    }

    export interface IXmlNodeSelector {
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
    }

    export interface IXmlNodeSerializer {
        getXml(): string;
        innerText: string;
    }

    export interface IXmlProcessingInstruction extends Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        data: string;
        target: string;
    }

    export interface IXmlText extends Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
    }

    enum NodeType {
        invalid,
        elementNode,
        attributeNode,
        textNode,
        dataSectionNode,
        entityReferenceNode,
        entityNode,
        processingInstructionNode,
        commentNode,
        documentNode,
        documentTypeNode,
        documentFragmentNode,
        notationNode
    }

    export class XmlAttribute implements Windows.Data.Xml.Dom.IXmlAttribute, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        name: string;
        specified: boolean;
        value: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlCDataSection implements Windows.Data.Xml.Dom.IXmlCDataSection, Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlComment implements Windows.Data.Xml.Dom.IXmlComment, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocument implements Windows.Data.Xml.Dom.IXmlDocument, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer, Windows.Data.Xml.Dom.IXmlDocumentIO {
        constructor();
        createElement(tagName: string): Windows.Data.Xml.Dom.XmlElement;
        createDocumentFragment(): Windows.Data.Xml.Dom.XmlDocumentFragment;
        createTextNode(data: string): Windows.Data.Xml.Dom.XmlText;
        createComment(data: string): Windows.Data.Xml.Dom.XmlComment;
        createProcessingInstruction(target: string, data: string): Windows.Data.Xml.Dom.XmlProcessingInstruction;
        createAttribute(name: string): Windows.Data.Xml.Dom.XmlAttribute;
        createEntityReference(name: string): Windows.Data.Xml.Dom.XmlEntityReference;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        createCDataSection(data: string): Windows.Data.Xml.Dom.XmlCDataSection;
        createAttributeNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlAttribute;
        createElementNS(namespaceUri: any, qualifiedName: string): Windows.Data.Xml.Dom.XmlElement;
        getElementById(elementId: string): Windows.Data.Xml.Dom.XmlElement;
        importNode(node: Windows.Data.Xml.Dom.IXmlNode, deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        loadXml(xml: string): void;
        loadXml(xml: string, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): void;
        saveToFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static loadFromUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromUriAsync(uri: Windows.Foundation.Uri, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        static loadFromFileAsync(file: Windows.Storage.IStorageFile, loadSettings: Windows.Data.Xml.Dom.XmlLoadSettings): Windows.Foundation.IAsyncOperation<Windows.Data.Xml.Dom.XmlDocument>;
        doctype: Windows.Data.Xml.Dom.XmlDocumentType;
        documentElement: Windows.Data.Xml.Dom.XmlElement;
        documentUri: string;
        implementation: Windows.Data.Xml.Dom.XmlDomImplementation;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocumentFragment implements Windows.Data.Xml.Dom.IXmlDocumentFragment, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDocumentType implements Windows.Data.Xml.Dom.IXmlDocumentType, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        entities: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        name: string;
        notations: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlDomImplementation implements Windows.Data.Xml.Dom.IXmlDomImplementation {
        hasFeature(feature: string, version: any): boolean;
    }

    export class XmlElement implements Windows.Data.Xml.Dom.IXmlElement, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        getAttribute(attributeName: string): string;
        setAttribute(attributeName: string, attributeValue: string): void;
        removeAttribute(attributeName: string): void;
        getAttributeNode(attributeName: string): Windows.Data.Xml.Dom.XmlAttribute;
        setAttributeNode(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        removeAttributeNode(attributeNode: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getElementsByTagName(tagName: string): Windows.Data.Xml.Dom.XmlNodeList;
        setAttributeNS(namespaceUri: any, qualifiedName: string, value: string): void;
        getAttributeNS(namespaceUri: any, localName: string): string;
        removeAttributeNS(namespaceUri: any, localName: string): void;
        setAttributeNodeNS(newAttribute: Windows.Data.Xml.Dom.XmlAttribute): Windows.Data.Xml.Dom.XmlAttribute;
        getAttributeNodeNS(namespaceUri: any, localName: string): Windows.Data.Xml.Dom.XmlAttribute;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        tagName: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlEntityReference implements Windows.Data.Xml.Dom.IXmlEntityReference, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlLoadSettings implements Windows.Data.Xml.Dom.IXmlLoadSettings {
        constructor();
        elementContentWhiteSpace: boolean;
        maxElementDepth: number;
        prohibitDtd: boolean;
        resolveExternals: boolean;
        validateOnParse: boolean;
    }

    export class XmlNamedNodeMap implements Windows.Data.Xml.Dom.IXmlNamedNodeMap, Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItem(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItem(name: string): Windows.Data.Xml.Dom.IXmlNode;
        getNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        removeNamedItemNS(namespaceUri: any, name: string): Windows.Data.Xml.Dom.IXmlNode;
        setNamedItemNS(node: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
        indexOf(value: Windows.Data.Xml.Dom.IXmlNode): XmlNamedNodeMap_indexOf_OUT;
        getMany(startIndex: number): XmlNamedNodeMap_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
        length: number;
        size: number;
    }

    interface XmlNamedNodeMap_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface XmlNamedNodeMap_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Xml.Dom.IXmlNode[];
    }

    export class XmlNodeList implements Windows.Data.Xml.Dom.IXmlNodeList, Windows.Foundation.Collections.IVectorView<Windows.Data.Xml.Dom.IXmlNode>, Windows.Foundation.Collections.IIterable<Windows.Data.Xml.Dom.IXmlNode> {
        item(index: number): Windows.Data.Xml.Dom.IXmlNode;
        getAt(index: number): Windows.Data.Xml.Dom.IXmlNode;
        indexOf(value: Windows.Data.Xml.Dom.IXmlNode): XmlNodeList_indexOf_OUT;
        getMany(startIndex: number): XmlNodeList_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Data.Xml.Dom.IXmlNode>;
        length: number;
        size: number;
    }

    interface XmlNodeList_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface XmlNodeList_getMany_OUT {
        __returnValue: number;
        items: Windows.Data.Xml.Dom.IXmlNode[];
    }

    export class XmlProcessingInstruction implements Windows.Data.Xml.Dom.IXmlProcessingInstruction, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        target: string;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

    export class XmlText implements Windows.Data.Xml.Dom.IXmlText, Windows.Data.Xml.Dom.IXmlCharacterData, Windows.Data.Xml.Dom.IXmlNode, Windows.Data.Xml.Dom.IXmlNodeSelector, Windows.Data.Xml.Dom.IXmlNodeSerializer {
        splitText(offset: number): Windows.Data.Xml.Dom.IXmlText;
        substringData(offset: number, count: number): string;
        appendData(data: string): void;
        insertData(offset: number, data: string): void;
        deleteData(offset: number, count: number): void;
        replaceData(offset: number, count: number, data: string): void;
        hasChildNodes(): boolean;
        insertBefore(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        replaceChild(newChild: Windows.Data.Xml.Dom.IXmlNode, referenceChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        removeChild(childNode: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        appendChild(newChild: Windows.Data.Xml.Dom.IXmlNode): Windows.Data.Xml.Dom.IXmlNode;
        cloneNode(deep: boolean): Windows.Data.Xml.Dom.IXmlNode;
        normalize(): void;
        selectSingleNode(xpath: string): Windows.Data.Xml.Dom.IXmlNode;
        selectNodes(xpath: string): Windows.Data.Xml.Dom.XmlNodeList;
        selectSingleNodeNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.IXmlNode;
        selectNodesNS(xpath: string, namespaces: any): Windows.Data.Xml.Dom.XmlNodeList;
        getXml(): string;
        data: string;
        length: number;
        attributes: Windows.Data.Xml.Dom.XmlNamedNodeMap;
        childNodes: Windows.Data.Xml.Dom.XmlNodeList;
        firstChild: Windows.Data.Xml.Dom.IXmlNode;
        lastChild: Windows.Data.Xml.Dom.IXmlNode;
        localName: any;
        namespaceUri: any;
        nextSibling: Windows.Data.Xml.Dom.IXmlNode;
        nodeName: string;
        nodeType: Windows.Data.Xml.Dom.NodeType;
        nodeValue: any;
        ownerDocument: Windows.Data.Xml.Dom.XmlDocument;
        parentNode: Windows.Data.Xml.Dom.IXmlNode;
        prefix: any;
        previousSibling: Windows.Data.Xml.Dom.IXmlNode;
        innerText: string;
    }

}
declare module Windows.Data.Xml.Xsl {

    export interface IXsltProcessor {
        transformToString(inputNode: Windows.Data.Xml.Dom.IXmlNode): string;
    }

    export class XsltProcessor implements Windows.Data.Xml.Xsl.IXsltProcessor {
        constructor(document: Windows.Data.Xml.Dom.XmlDocument);
        transformToString(inputNode: Windows.Data.Xml.Dom.IXmlNode): string;
    }

}
declare module Windows.Devices.Enumeration {

    enum DeviceClass {
        all,
        audioCapture,
        audioRender,
        portableStorageDevice,
        videoCapture
    }

    export class DeviceInformation implements Windows.Devices.Enumeration.IDeviceInformation {
        update(updateInfo: Windows.Devices.Enumeration.DeviceInformationUpdate): void;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        getGlyphThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        static createFromIdAsync(id: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
        static createFromIdAsync(id: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformation>;
        static findAllAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(deviceClass: Windows.Devices.Enumeration.DeviceClass): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(aqsFilter: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static findAllAsync(aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceInformationCollection>;
        static createWatcher(): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(deviceClass: Windows.Devices.Enumeration.DeviceClass): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(aqsFilter: string): Windows.Devices.Enumeration.DeviceWatcher;
        static createWatcher(aqsFilter: string, additionalProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Devices.Enumeration.DeviceWatcher;
        enclosureLocation: Windows.Devices.Enumeration.EnclosureLocation;
        id: string;
        isDefault: boolean;
        isEnabled: boolean;
        name: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DeviceInformationCollection implements Windows.Foundation.Collections.IVectorView<Windows.Devices.Enumeration.DeviceInformation>, Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.DeviceInformation> {
        getAt(index: number): Windows.Devices.Enumeration.DeviceInformation;
        indexOf(value: Windows.Devices.Enumeration.DeviceInformation): DeviceInformationCollection_indexOf_OUT;
        getMany(startIndex: number): DeviceInformationCollection_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.DeviceInformation>;
        size: number;
    }

    interface DeviceInformationCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface DeviceInformationCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.Devices.Enumeration.DeviceInformation[];
    }

    export class DeviceInformationUpdate implements Windows.Devices.Enumeration.IDeviceInformationUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class DeviceThumbnail implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
    }

    export class DeviceWatcher implements Windows.Devices.Enumeration.IDeviceWatcher {
        add_Added(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): Windows.Foundation.EventRegistrationToken;
        remove_Added(token: Windows.Foundation.EventRegistrationToken): void;
        add_Updated(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Updated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Removed(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Removed(token: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;

    }

    enum DeviceWatcherStatus {
        created,
        started,
        enumerationCompleted,
        stopping,
        stopped,
        aborted
    }

    export class EnclosureLocation implements Windows.Devices.Enumeration.IEnclosureLocation {
        inDock: boolean;
        inLid: boolean;
        panel: Windows.Devices.Enumeration.Panel;
    }

    export interface IDeviceInformation {
        update(updateInfo: Windows.Devices.Enumeration.DeviceInformationUpdate): void;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        getGlyphThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.DeviceThumbnail>;
        enclosureLocation: Windows.Devices.Enumeration.EnclosureLocation;
        id: string;
        isDefault: boolean;
        isEnabled: boolean;
        name: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export interface IDeviceInformationUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export interface IDeviceWatcher {
        add_Added(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): Windows.Foundation.EventRegistrationToken;
        remove_Added(token: Windows.Foundation.EventRegistrationToken): void;
        add_Updated(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Updated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Removed(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Removed(token: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformation>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.DeviceWatcher,Windows.Devices.Enumeration.DeviceInformationUpdate>) => void;

    }

    export interface IEnclosureLocation {
        inDock: boolean;
        inLid: boolean;
        panel: Windows.Devices.Enumeration.Panel;
    }

    enum Panel {
        unknown,
        front,
        back,
        top,
        bottom,
        left,
        right
    }

}
declare module Windows.Devices.Enumeration.Pnp {

    export interface IPnpObject {
        update(updateInfo: Windows.Devices.Enumeration.Pnp.PnpObjectUpdate): void;
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export interface IPnpObjectUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export interface IPnpObjectWatcher {
        add_Added(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): Windows.Foundation.EventRegistrationToken;
        remove_Added(token: Windows.Foundation.EventRegistrationToken): void;
        add_Updated(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Updated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Removed(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Removed(token: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;

    }

    export class PnpObject implements Windows.Devices.Enumeration.Pnp.IPnpObject {
        update(updateInfo: Windows.Devices.Enumeration.Pnp.PnpObjectUpdate): void;
        static createFromIdAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, id: string, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObject>;
        static findAllAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
        static findAllAsync(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Enumeration.Pnp.PnpObjectCollection>;
        static createWatcher(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
        static createWatcher(type: Windows.Devices.Enumeration.Pnp.PnpObjectType, requestedProperties: Windows.Foundation.Collections.IIterable<string>, aqsFilter: string): Windows.Devices.Enumeration.Pnp.PnpObjectWatcher;
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export class PnpObjectCollection implements Windows.Foundation.Collections.IVectorView<Windows.Devices.Enumeration.Pnp.PnpObject>, Windows.Foundation.Collections.IIterable<Windows.Devices.Enumeration.Pnp.PnpObject> {
        getAt(index: number): Windows.Devices.Enumeration.Pnp.PnpObject;
        indexOf(value: Windows.Devices.Enumeration.Pnp.PnpObject): PnpObjectCollection_indexOf_OUT;
        getMany(startIndex: number): PnpObjectCollection_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Devices.Enumeration.Pnp.PnpObject>;
        size: number;
    }

    interface PnpObjectCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PnpObjectCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.Devices.Enumeration.Pnp.PnpObject[];
    }

    enum PnpObjectType {
        unknown,
        deviceInterface,
        deviceContainer,
        device,
        deviceInterfaceClass
    }

    export class PnpObjectUpdate implements Windows.Devices.Enumeration.Pnp.IPnpObjectUpdate {
        id: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        type: Windows.Devices.Enumeration.Pnp.PnpObjectType;
    }

    export class PnpObjectWatcher implements Windows.Devices.Enumeration.Pnp.IPnpObjectWatcher {
        add_Added(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): Windows.Foundation.EventRegistrationToken;
        remove_Added(token: Windows.Foundation.EventRegistrationToken): void;
        add_Updated(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Updated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Removed(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): Windows.Foundation.EventRegistrationToken;
        remove_Removed(token: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Devices.Enumeration.DeviceWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObject>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Enumeration.Pnp.PnpObjectWatcher,Windows.Devices.Enumeration.Pnp.PnpObjectUpdate>) => void;

    }

}
declare module Windows.Devices.Geolocation {

    export class CivicAddress implements Windows.Devices.Geolocation.ICivicAddress {
        city: string;
        country: string;
        postalCode: string;
        state: string;
        timestamp: Date;
    }

    export class Geocoordinate implements Windows.Devices.Geolocation.IGeocoordinate {
        accuracy: number;
        altitude: Windows.Foundation.IReference<number>;
        altitudeAccuracy: Windows.Foundation.IReference<number>;
        heading: Windows.Foundation.IReference<number>;
        latitude: number;
        longitude: number;
        speed: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export class Geolocator implements Windows.Devices.Geolocation.IGeolocator {
        constructor();
        getGeopositionAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        getGeopositionAsync(maximumAge: Windows.Foundation.TimeSpan, timeout: Windows.Foundation.TimeSpan): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        add_PositionChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PositionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_StatusChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_StatusChanged(token: Windows.Foundation.EventRegistrationToken): void;
        desiredAccuracy: Windows.Devices.Geolocation.PositionAccuracy;
        locationStatus: Windows.Devices.Geolocation.PositionStatus;
        movementThreshold: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        removeEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        onpositionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>) => void;
        addEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        removeEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        onstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>) => void;

    }

    export class Geoposition implements Windows.Devices.Geolocation.IGeoposition {
        civicAddress: Windows.Devices.Geolocation.CivicAddress;
        coordinate: Windows.Devices.Geolocation.Geocoordinate;
    }

    export interface ICivicAddress {
        city: string;
        country: string;
        postalCode: string;
        state: string;
        timestamp: Date;
    }

    export interface IGeocoordinate {
        accuracy: number;
        altitude: Windows.Foundation.IReference<number>;
        altitudeAccuracy: Windows.Foundation.IReference<number>;
        heading: Windows.Foundation.IReference<number>;
        latitude: number;
        longitude: number;
        speed: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export interface IGeolocator {
        getGeopositionAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        getGeopositionAsync(maximumAge: Windows.Foundation.TimeSpan, timeout: Windows.Foundation.TimeSpan): Windows.Foundation.IAsyncOperation<Windows.Devices.Geolocation.Geoposition>;
        add_PositionChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PositionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_StatusChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_StatusChanged(token: Windows.Foundation.EventRegistrationToken): void;
        desiredAccuracy: Windows.Devices.Geolocation.PositionAccuracy;
        locationStatus: Windows.Devices.Geolocation.PositionStatus;
        movementThreshold: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        removeEventListener(eventName: "positionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>): void;
        onpositionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.PositionChangedEventArgs>) => void;
        addEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        removeEventListener(eventName: "statuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>): void;
        onstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Geolocation.Geolocator,Windows.Devices.Geolocation.StatusChangedEventArgs>) => void;

    }

    export interface IGeoposition {
        civicAddress: Windows.Devices.Geolocation.CivicAddress;
        coordinate: Windows.Devices.Geolocation.Geocoordinate;
    }

    export interface IPositionChangedEventArgs {
        position: Windows.Devices.Geolocation.Geoposition;
    }

    export interface IStatusChangedEventArgs {
        status: Windows.Devices.Geolocation.PositionStatus;
    }

    enum PositionAccuracy {
        default,
        high
    }

    export class PositionChangedEventArgs implements Windows.Devices.Geolocation.IPositionChangedEventArgs {
        position: Windows.Devices.Geolocation.Geoposition;
    }

    enum PositionStatus {
        ready,
        initializing,
        noData,
        disabled,
        notInitialized,
        notAvailable
    }

    export class StatusChangedEventArgs implements Windows.Devices.Geolocation.IStatusChangedEventArgs {
        status: Windows.Devices.Geolocation.PositionStatus;
    }

}
declare module Windows.Devices.Input {

    export interface IKeyboardCapabilities {
        keyboardPresent: number;
    }

    export interface IMouseCapabilities {
        horizontalWheelPresent: number;
        mousePresent: number;
        numberOfButtons: number;
        swapButtons: number;
        verticalWheelPresent: number;
    }

    export interface IMouseDevice {
        add_MouseMoved(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MouseMoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        removeEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        onmousemoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>) => void;

    }

    export interface IMouseEventArgs {
        mouseDelta: Windows.Devices.Input.MouseDelta;
    }

    export interface IPointerDevice {
        isIntegrated: boolean;
        maxContacts: number;
        physicalDeviceRect: Windows.Foundation.Rect;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        screenRect: Windows.Foundation.Rect;
        supportedUsages: Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDeviceUsage>;
    }

    export interface ITouchCapabilities {
        contacts: number;
        touchPresent: number;
    }

    export class KeyboardCapabilities implements Windows.Devices.Input.IKeyboardCapabilities {
        constructor();
        keyboardPresent: number;
    }

    export class MouseCapabilities implements Windows.Devices.Input.IMouseCapabilities {
        constructor();
        horizontalWheelPresent: number;
        mousePresent: number;
        numberOfButtons: number;
        swapButtons: number;
        verticalWheelPresent: number;
    }

    export class MouseDelta {
        x: number;
        y: number;
    }

    export class MouseDevice implements Windows.Devices.Input.IMouseDevice {
        add_MouseMoved(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MouseMoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.Devices.Input.MouseDevice;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        removeEventListener(eventName: "mousemoved", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>): void;
        onmousemoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Input.MouseDevice,Windows.Devices.Input.MouseEventArgs>) => void;

    }

    export class MouseEventArgs implements Windows.Devices.Input.IMouseEventArgs {
        mouseDelta: Windows.Devices.Input.MouseDelta;
    }

    export class PointerDevice implements Windows.Devices.Input.IPointerDevice {
        static getPointerDevice(pointerId: number): Windows.Devices.Input.PointerDevice;
        static getPointerDevices(): Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDevice>;
        isIntegrated: boolean;
        maxContacts: number;
        physicalDeviceRect: Windows.Foundation.Rect;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        screenRect: Windows.Foundation.Rect;
        supportedUsages: Windows.Foundation.Collections.IVectorView<Windows.Devices.Input.PointerDeviceUsage>;
    }

    enum PointerDeviceType {
        touch,
        pen,
        mouse
    }

    export class PointerDeviceUsage {
        usagePage: number;
        usage: number;
        minLogical: number;
        maxLogical: number;
        minPhysical: number;
        maxPhysical: number;
        unit: number;
        physicalMultiplier: number;
    }

    export class TouchCapabilities implements Windows.Devices.Input.ITouchCapabilities {
        constructor();
        contacts: number;
        touchPresent: number;
    }

}
declare module Windows.Devices.Portable {

    export class ServiceDevice {
        static getDeviceSelector(serviceType: Windows.Devices.Portable.ServiceDeviceType): string;
        static getDeviceSelectorFromServiceId(serviceId: string): string;
    }

    enum ServiceDeviceType {
        calendarService,
        contactsService,
        deviceStatusService,
        notesService,
        ringtonesService,
        smsService,
        tasksService
    }

    export class StorageDevice {
        static fromId(interfaceId: string): Windows.Storage.StorageFolder;
        static getDeviceSelector(): string;
    }

}
declare module Windows.Devices.Printers.Extensions {

    export interface IPrintNotificationEventDetails {
        eventData: string;
        printerName: string;
    }

    export interface IPrintTaskConfiguration {
        add_SaveRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SaveRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        printerExtensionContext: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        removeEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        onsaverequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>) => void;

    }

    export interface IPrintTaskConfigurationSaveRequest {
        cancel(): void;
        save(printerExtensionContext: any): void;
        getDeferral(): Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskConfigurationSaveRequestedDeferral {
        complete(): void;
    }

    export interface IPrintTaskConfigurationSaveRequestedEventArgs {
        request: Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest;
    }

    export class PrintExtensionContext {
        static fromDeviceId(deviceId: string): any;
    }

    export class PrintNotificationEventDetails implements Windows.Devices.Printers.Extensions.IPrintNotificationEventDetails {
        eventData: string;
        printerName: string;
    }

    export class PrintTaskConfiguration implements Windows.Devices.Printers.Extensions.IPrintTaskConfiguration {
        add_SaveRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SaveRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        printerExtensionContext: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        removeEventListener(eventName: "saverequested", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>): void;
        onsaverequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Printers.Extensions.PrintTaskConfiguration,Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedEventArgs>) => void;

    }

    export class PrintTaskConfigurationSaveRequest implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequest {
        cancel(): void;
        save(printerExtensionContext: any): void;
        getDeferral(): Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskConfigurationSaveRequestedDeferral implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequestedDeferral {
        complete(): void;
    }

    export class PrintTaskConfigurationSaveRequestedEventArgs implements Windows.Devices.Printers.Extensions.IPrintTaskConfigurationSaveRequestedEventArgs {
        request: Windows.Devices.Printers.Extensions.PrintTaskConfigurationSaveRequest;
    }

}
declare module Windows.Devices.Sensors {

    export class Accelerometer implements Windows.Devices.Sensors.IAccelerometer {
        getCurrentReading(): Windows.Devices.Sensors.AccelerometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Shaken(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Shaken(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.Accelerometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>) => void;
        addEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        removeEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        onshaken: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>) => void;

    }

    export class AccelerometerReading implements Windows.Devices.Sensors.IAccelerometerReading {
        accelerationX: number;
        accelerationY: number;
        accelerationZ: number;
        timestamp: Date;
    }

    export class AccelerometerReadingChangedEventArgs implements Windows.Devices.Sensors.IAccelerometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.AccelerometerReading;
    }

    export class AccelerometerShakenEventArgs implements Windows.Devices.Sensors.IAccelerometerShakenEventArgs {
        timestamp: Date;
    }

    export class Compass implements Windows.Devices.Sensors.ICompass {
        getCurrentReading(): Windows.Devices.Sensors.CompassReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.Compass;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>) => void;

    }

    export class CompassReading implements Windows.Devices.Sensors.ICompassReading {
        headingMagneticNorth: number;
        headingTrueNorth: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export class CompassReadingChangedEventArgs implements Windows.Devices.Sensors.ICompassReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.CompassReading;
    }

    export class Gyrometer implements Windows.Devices.Sensors.IGyrometer {
        getCurrentReading(): Windows.Devices.Sensors.GyrometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.Gyrometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>) => void;

    }

    export class GyrometerReading implements Windows.Devices.Sensors.IGyrometerReading {
        angularVelocityX: number;
        angularVelocityY: number;
        angularVelocityZ: number;
        timestamp: Date;
    }

    export class GyrometerReadingChangedEventArgs implements Windows.Devices.Sensors.IGyrometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.GyrometerReading;
    }

    export interface IAccelerometer {
        getCurrentReading(): Windows.Devices.Sensors.AccelerometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Shaken(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Shaken(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerReadingChangedEventArgs>) => void;
        addEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        removeEventListener(eventName: "shaken", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>): void;
        onshaken: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Accelerometer,Windows.Devices.Sensors.AccelerometerShakenEventArgs>) => void;

    }

    export interface IAccelerometerReading {
        accelerationX: number;
        accelerationY: number;
        accelerationZ: number;
        timestamp: Date;
    }

    export interface IAccelerometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.AccelerometerReading;
    }

    export interface IAccelerometerShakenEventArgs {
        timestamp: Date;
    }

    export interface ICompass {
        getCurrentReading(): Windows.Devices.Sensors.CompassReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Compass,Windows.Devices.Sensors.CompassReadingChangedEventArgs>) => void;

    }

    export interface ICompassReading {
        headingMagneticNorth: number;
        headingTrueNorth: Windows.Foundation.IReference<number>;
        timestamp: Date;
    }

    export interface ICompassReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.CompassReading;
    }

    export interface IGyrometer {
        getCurrentReading(): Windows.Devices.Sensors.GyrometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Gyrometer,Windows.Devices.Sensors.GyrometerReadingChangedEventArgs>) => void;

    }

    export interface IGyrometerReading {
        angularVelocityX: number;
        angularVelocityY: number;
        angularVelocityZ: number;
        timestamp: Date;
    }

    export interface IGyrometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.GyrometerReading;
    }

    export interface IInclinometer {
        getCurrentReading(): Windows.Devices.Sensors.InclinometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>) => void;

    }

    export interface IInclinometerReading {
        pitchDegrees: number;
        rollDegrees: number;
        timestamp: Date;
        yawDegrees: number;
    }

    export interface IInclinometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.InclinometerReading;
    }

    export interface ILightSensor {
        getCurrentReading(): Windows.Devices.Sensors.LightSensorReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>) => void;

    }

    export interface ILightSensorReading {
        illuminanceInLux: number;
        timestamp: Date;
    }

    export interface ILightSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.LightSensorReading;
    }

    export class Inclinometer implements Windows.Devices.Sensors.IInclinometer {
        getCurrentReading(): Windows.Devices.Sensors.InclinometerReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.Inclinometer;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.Inclinometer,Windows.Devices.Sensors.InclinometerReadingChangedEventArgs>) => void;

    }

    export class InclinometerReading implements Windows.Devices.Sensors.IInclinometerReading {
        pitchDegrees: number;
        rollDegrees: number;
        timestamp: Date;
        yawDegrees: number;
    }

    export class InclinometerReadingChangedEventArgs implements Windows.Devices.Sensors.IInclinometerReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.InclinometerReading;
    }

    export interface IOrientationSensor {
        getCurrentReading(): Windows.Devices.Sensors.OrientationSensorReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>) => void;

    }

    export interface IOrientationSensorReading {
        quaternion: Windows.Devices.Sensors.SensorQuaternion;
        rotationMatrix: Windows.Devices.Sensors.SensorRotationMatrix;
        timestamp: Date;
    }

    export interface IOrientationSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.OrientationSensorReading;
    }

    export interface ISensorQuaternion {
        w: number;
        x: number;
        y: number;
        z: number;
    }

    export interface ISensorRotationMatrix {
        m11: number;
        m12: number;
        m13: number;
        m21: number;
        m22: number;
        m23: number;
        m31: number;
        m32: number;
        m33: number;
    }

    export interface ISimpleOrientationSensor {
        getCurrentOrientation(): Windows.Devices.Sensors.SimpleOrientation;
        add_OrientationChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OrientationChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        onorientationchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>) => void;

    }

    export interface ISimpleOrientationSensorOrientationChangedEventArgs {
        orientation: Windows.Devices.Sensors.SimpleOrientation;
        timestamp: Date;
    }

    export class LightSensor implements Windows.Devices.Sensors.ILightSensor {
        getCurrentReading(): Windows.Devices.Sensors.LightSensorReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.LightSensor;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.LightSensor,Windows.Devices.Sensors.LightSensorReadingChangedEventArgs>) => void;

    }

    export class LightSensorReading implements Windows.Devices.Sensors.ILightSensorReading {
        illuminanceInLux: number;
        timestamp: Date;
    }

    export class LightSensorReadingChangedEventArgs implements Windows.Devices.Sensors.ILightSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.LightSensorReading;
    }

    export class OrientationSensor implements Windows.Devices.Sensors.IOrientationSensor {
        getCurrentReading(): Windows.Devices.Sensors.OrientationSensorReading;
        add_ReadingChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ReadingChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.OrientationSensor;
        minimumReportInterval: number;
        reportInterval: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        removeEventListener(eventName: "readingchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>): void;
        onreadingchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.OrientationSensor,Windows.Devices.Sensors.OrientationSensorReadingChangedEventArgs>) => void;

    }

    export class OrientationSensorReading implements Windows.Devices.Sensors.IOrientationSensorReading {
        quaternion: Windows.Devices.Sensors.SensorQuaternion;
        rotationMatrix: Windows.Devices.Sensors.SensorRotationMatrix;
        timestamp: Date;
    }

    export class OrientationSensorReadingChangedEventArgs implements Windows.Devices.Sensors.IOrientationSensorReadingChangedEventArgs {
        reading: Windows.Devices.Sensors.OrientationSensorReading;
    }

    export class SensorQuaternion implements Windows.Devices.Sensors.ISensorQuaternion {
        w: number;
        x: number;
        y: number;
        z: number;
    }

    export class SensorRotationMatrix implements Windows.Devices.Sensors.ISensorRotationMatrix {
        m11: number;
        m12: number;
        m13: number;
        m21: number;
        m22: number;
        m23: number;
        m31: number;
        m32: number;
        m33: number;
    }

    enum SimpleOrientation {
        notRotated,
        rotated90DegreesCounterclockwise,
        rotated180DegreesCounterclockwise,
        rotated270DegreesCounterclockwise,
        faceup,
        facedown
    }

    export class SimpleOrientationSensor implements Windows.Devices.Sensors.ISimpleOrientationSensor {
        getCurrentOrientation(): Windows.Devices.Sensors.SimpleOrientation;
        add_OrientationChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OrientationChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Devices.Sensors.SimpleOrientationSensor;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>): void;
        onorientationchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Devices.Sensors.SimpleOrientationSensor,Windows.Devices.Sensors.SimpleOrientationSensorOrientationChangedEventArgs>) => void;

    }

    export class SimpleOrientationSensorOrientationChangedEventArgs implements Windows.Devices.Sensors.ISimpleOrientationSensorOrientationChangedEventArgs {
        orientation: Windows.Devices.Sensors.SimpleOrientation;
        timestamp: Date;
    }

}
declare module Windows.Devices.Sms {

    enum CellularClass {
        none,
        gsm,
        cdma
    }

    export class DeleteSmsMessageOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class DeleteSmsMessagesOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class GetSmsDeviceOperation implements Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Devices.Sms.SmsDevice;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.SmsDevice>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Devices.Sms.SmsDevice) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class GetSmsMessageOperation implements Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Devices.Sms.ISmsMessage;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Devices.Sms.ISmsMessage>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Devices.Sms.ISmsMessage) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class GetSmsMessagesOperation implements Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        progress: Windows.Foundation.AsyncOperationProgressHandler<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface ISmsBinaryMessage extends Windows.Devices.Sms.ISmsMessage {
        getData(): any;
        setData(value: any): void;
        format: Windows.Devices.Sms.SmsDataFormat;
    }

    export interface ISmsDevice {
        sendMessageAsync(message: Windows.Devices.Sms.ISmsMessage): Windows.Devices.Sms.SendSmsMessageOperation;
        calculateLength(message: Windows.Devices.Sms.SmsTextMessage): Windows.Devices.Sms.SmsEncodedLength;
        add_SmsMessageReceived(eventHandler: Windows.Devices.Sms.SmsMessageReceivedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SmsMessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_SmsDeviceStatusChanged(eventHandler: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SmsDeviceStatusChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        accountPhoneNumber: string;
        cellularClass: Windows.Devices.Sms.CellularClass;
        deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
        messageStore: Windows.Devices.Sms.SmsDeviceMessageStore;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        removeEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        onsmsdevicestatuschanged: (ev: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler) => void;
        addEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        removeEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        onsmsmessagereceived: (ev: Windows.Devices.Sms.SmsMessageReceivedEventHandler) => void;

    }

    export interface ISmsDeviceMessageStore {
        deleteMessageAsync(messageId: number): Windows.Foundation.IAsyncAction;
        deleteMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncAction;
        getMessageAsync(messageId: number): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>;
        getMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        maxMessages: number;
    }

    export interface ISmsMessage {
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

    export interface ISmsMessageReceivedEventArgs {
        binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
        textMessage: Windows.Devices.Sms.SmsTextMessage;
    }

    export interface ISmsReceivedEventDetails {
        deviceId: string;
        messageIndex: number;
    }

    export interface ISmsTextMessage extends Windows.Devices.Sms.ISmsMessage {
        toBinaryMessages(format: Windows.Devices.Sms.SmsDataFormat): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsBinaryMessage>;
        body: string;
        encoding: Windows.Devices.Sms.SmsEncoding;
        from: string;
        partCount: number;
        partNumber: number;
        partReferenceId: number;
        timestamp: Date;
        to: string;
    }

    export class SendSmsMessageOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class SmsBinaryMessage implements Windows.Devices.Sms.ISmsBinaryMessage, Windows.Devices.Sms.ISmsMessage {
        constructor();
        getData(): any;
        setData(value: any): void;
        format: Windows.Devices.Sms.SmsDataFormat;
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

    enum SmsDataFormat {
        unknown,
        cdmaSubmit,
        gsmSubmit,
        cdmaDeliver,
        gsmDeliver
    }

    export class SmsDevice implements Windows.Devices.Sms.ISmsDevice {
        sendMessageAsync(message: Windows.Devices.Sms.ISmsMessage): Windows.Devices.Sms.SendSmsMessageOperation;
        calculateLength(message: Windows.Devices.Sms.SmsTextMessage): Windows.Devices.Sms.SmsEncodedLength;
        add_SmsMessageReceived(eventHandler: Windows.Devices.Sms.SmsMessageReceivedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SmsMessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_SmsDeviceStatusChanged(eventHandler: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SmsDeviceStatusChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        static getDeviceSelector(): string;
        static fromIdAsync(deviceInstanceId: string): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>;
        static getDefaultAsync(): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.SmsDevice>;
        accountPhoneNumber: string;
        cellularClass: Windows.Devices.Sms.CellularClass;
        deviceStatus: Windows.Devices.Sms.SmsDeviceStatus;
        messageStore: Windows.Devices.Sms.SmsDeviceMessageStore;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        removeEventListener(eventName: "smsdevicestatuschanged", listener: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler): void;
        onsmsdevicestatuschanged: (ev: Windows.Devices.Sms.SmsDeviceStatusChangedEventHandler) => void;
        addEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        removeEventListener(eventName: "smsmessagereceived", listener: Windows.Devices.Sms.SmsMessageReceivedEventHandler): void;
        onsmsmessagereceived: (ev: Windows.Devices.Sms.SmsMessageReceivedEventHandler) => void;

    }

    export class SmsDeviceMessageStore implements Windows.Devices.Sms.ISmsDeviceMessageStore {
        deleteMessageAsync(messageId: number): Windows.Foundation.IAsyncAction;
        deleteMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncAction;
        getMessageAsync(messageId: number): Windows.Foundation.IAsyncOperation<Windows.Devices.Sms.ISmsMessage>;
        getMessagesAsync(messageFilter: Windows.Devices.Sms.SmsMessageFilter): Windows.Foundation.IAsyncOperationWithProgress<Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsMessage>,number>;
        maxMessages: number;
    }

    enum SmsDeviceStatus {
        off,
        ready,
        simNotInserted,
        badSim,
        deviceFailure,
        subscriptionNotActivated,
        deviceLocked,
        deviceBlocked
    }

    export interface SmsDeviceStatusChangedEventHandler {
        target: Windows.Devices.Sms.SmsDevice;
        detail: any[];
        type: string;
    }

    export class SmsEncodedLength {
        segmentCount: number;
        characterCountLastSegment: number;
        charactersPerSegment: number;
        byteCountLastSegment: number;
        bytesPerSegment: number;
    }

    enum SmsEncoding {
        unknown,
        optimal,
        sevenBitAscii,
        unicode,
        gsmSevenBit
    }

    enum SmsMessageClass {
        none,
        class0,
        class1,
        class2,
        class3
    }

    enum SmsMessageFilter {
        all,
        unread,
        read,
        sent,
        draft
    }

    export class SmsMessageReceivedEventArgs implements Windows.Devices.Sms.ISmsMessageReceivedEventArgs {
        binaryMessage: Windows.Devices.Sms.SmsBinaryMessage;
        textMessage: Windows.Devices.Sms.SmsTextMessage;
    }

    export interface SmsMessageReceivedEventHandler {
        target: Windows.Devices.Sms.SmsDevice;
        detail: any[];
        type: string;
    }

    enum SmsMessageType {
        binary,
        text
    }

    export class SmsReceivedEventDetails implements Windows.Devices.Sms.ISmsReceivedEventDetails {
        deviceId: string;
        messageIndex: number;
    }

    export class SmsTextMessage implements Windows.Devices.Sms.ISmsTextMessage, Windows.Devices.Sms.ISmsMessage {
        constructor();
        toBinaryMessages(format: Windows.Devices.Sms.SmsDataFormat): Windows.Foundation.Collections.IVectorView<Windows.Devices.Sms.ISmsBinaryMessage>;
        static fromBinaryMessage(binaryMessage: Windows.Devices.Sms.SmsBinaryMessage): Windows.Devices.Sms.SmsTextMessage;
        static fromBinaryData(format: Windows.Devices.Sms.SmsDataFormat, value: any): Windows.Devices.Sms.SmsTextMessage;
        body: string;
        encoding: Windows.Devices.Sms.SmsEncoding;
        from: string;
        partCount: number;
        partNumber: number;
        partReferenceId: number;
        timestamp: Date;
        to: string;
        id: number;
        messageClass: Windows.Devices.Sms.SmsMessageClass;
    }

}
declare module Windows.Foundation {

    export interface AsyncActionCompletedHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    export interface AsyncActionProgressHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncActionWithProgressCompletedHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationCompletedHandler<TResult> {
        target: Windows.Foundation.IAsyncOperation<TResult>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationProgressHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    enum AsyncStatus {
        started,
        completed,
        canceled,
        error
    }

    export class DateTime {
        universalTime: number;
    }

    export interface EventHandler<T> {
        target: any;
        detail: any[];
        type: string;
    }

    export class EventRegistrationToken {
        value: number;
    }

    export class HResult {
        value: number;
    }

    export interface IAsyncAction extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
    }

    export interface IAsyncActionWithProgress<TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        progress: Windows.Foundation.AsyncActionProgressHandler<TProgress>;
        completed: Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>;
    }

    export interface IAsyncInfo {
        cancel(): void;
        close(): void;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export interface IAsyncOperation<TResult> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<TResult>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IAsyncOperationWithProgress<TResult, TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        progress: Windows.Foundation.AsyncOperationProgressHandler<TResult,TProgress>;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult,TProgress>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IClosable {
        close(): void;
    }

    export interface IGetActivationFactory {
        getActivationFactory(activatableClassId: string): any;
    }

    export interface IPropertyValue {
        getUInt8(): number;
        getInt16(): number;
        getUInt16(): number;
        getInt32(): number;
        getUInt32(): number;
        getInt64(): number;
        getUInt64(): number;
        getSingle(): number;
        getDouble(): number;
        getChar16(): number;
        getBoolean(): boolean;
        getString(): string;
        getGuid(): string;
        getDateTime(): Date;
        getTimeSpan(): Windows.Foundation.TimeSpan;
        getPoint(): Windows.Foundation.Point;
        getSize(): Windows.Foundation.Size;
        getRect(): Windows.Foundation.Rect;
        getUInt8Array(): IPropertyValue_getUInt8Array_OUT;
        getInt16Array(): IPropertyValue_getInt16Array_OUT;
        getUInt16Array(): IPropertyValue_getUInt16Array_OUT;
        getInt32Array(): IPropertyValue_getInt32Array_OUT;
        getUInt32Array(): IPropertyValue_getUInt32Array_OUT;
        getInt64Array(): IPropertyValue_getInt64Array_OUT;
        getUInt64Array(): IPropertyValue_getUInt64Array_OUT;
        getSingleArray(): IPropertyValue_getSingleArray_OUT;
        getDoubleArray(): IPropertyValue_getDoubleArray_OUT;
        getChar16Array(): IPropertyValue_getChar16Array_OUT;
        getBooleanArray(): IPropertyValue_getBooleanArray_OUT;
        getStringArray(): IPropertyValue_getStringArray_OUT;
        getInspectableArray(): IPropertyValue_getInspectableArray_OUT;
        getGuidArray(): IPropertyValue_getGuidArray_OUT;
        getDateTimeArray(): IPropertyValue_getDateTimeArray_OUT;
        getTimeSpanArray(): IPropertyValue_getTimeSpanArray_OUT;
        getPointArray(): IPropertyValue_getPointArray_OUT;
        getSizeArray(): IPropertyValue_getSizeArray_OUT;
        getRectArray(): IPropertyValue_getRectArray_OUT;
        isNumericScalar: boolean;
        type: Windows.Foundation.PropertyType;
    }

    interface IPropertyValue_getUInt8Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getSingleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getDoubleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getChar16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getBooleanArray_OUT {
        value: boolean[];
    }

    interface IPropertyValue_getStringArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getInspectableArray_OUT {
        value: any[];
    }

    interface IPropertyValue_getGuidArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getDateTimeArray_OUT {
        value: Date[];
    }

    interface IPropertyValue_getTimeSpanArray_OUT {
        value: Windows.Foundation.TimeSpan[];
    }

    interface IPropertyValue_getPointArray_OUT {
        value: Windows.Foundation.Point[];
    }

    interface IPropertyValue_getSizeArray_OUT {
        value: Windows.Foundation.Size[];
    }

    interface IPropertyValue_getRectArray_OUT {
        value: Windows.Foundation.Rect[];
    }

    export interface IReference<T> extends Windows.Foundation.IPropertyValue {
        value: T;
    }

    export interface IReferenceArray<T> extends Windows.Foundation.IPropertyValue {
        value: T[];
    }

    export interface IUriRuntimeClass {
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
    }

    export interface IUriRuntimeClassWithAbsoluteCanonicalUri {
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export interface IWwwFormUrlDecoderEntry {
        name: string;
        value: string;
    }

    export interface IWwwFormUrlDecoderRuntimeClass extends Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        getFirstValueByName(name: string): string;
    }

    export class Point {
        x: number;
        y: number;
    }

    enum PropertyType {
        empty,
        uInt8,
        int16,
        uInt16,
        int32,
        uInt32,
        int64,
        uInt64,
        single,
        double,
        char16,
        boolean,
        string,
        inspectable,
        dateTime,
        timeSpan,
        guid,
        point,
        size,
        rect,
        otherType,
        uInt8Array,
        int16Array,
        uInt16Array,
        int32Array,
        uInt32Array,
        int64Array,
        uInt64Array,
        singleArray,
        doubleArray,
        char16Array,
        booleanArray,
        stringArray,
        inspectableArray,
        dateTimeArray,
        timeSpanArray,
        guidArray,
        pointArray,
        sizeArray,
        rectArray,
        otherTypeArray
    }

    export class PropertyValue {
        static createEmpty(): any;
        static createUInt8(value: number): any;
        static createInt16(value: number): any;
        static createUInt16(value: number): any;
        static createInt32(value: number): any;
        static createUInt32(value: number): any;
        static createInt64(value: number): any;
        static createUInt64(value: number): any;
        static createSingle(value: number): any;
        static createDouble(value: number): any;
        static createChar16(value: number): any;
        static createBoolean(value: boolean): any;
        static createString(value: string): any;
        static createInspectable(value: any): any;
        static createGuid(value: string): any;
        static createDateTime(value: Date): any;
        static createTimeSpan(value: Windows.Foundation.TimeSpan): any;
        static createPoint(value: Windows.Foundation.Point): any;
        static createSize(value: Windows.Foundation.Size): any;
        static createRect(value: Windows.Foundation.Rect): any;
        static createUInt8Array(value: any): any;
        static createInt16Array(value: number[]): any;
        static createUInt16Array(value: number[]): any;
        static createInt32Array(value: number[]): any;
        static createUInt32Array(value: number[]): any;
        static createInt64Array(value: number[]): any;
        static createUInt64Array(value: number[]): any;
        static createSingleArray(value: number[]): any;
        static createDoubleArray(value: number[]): any;
        static createChar16Array(value: number[]): any;
        static createBooleanArray(value: boolean[]): any;
        static createStringArray(value: string[]): any;
        static createInspectableArray(value: any[]): any;
        static createGuidArray(value: string[]): any;
        static createDateTimeArray(value: Date[]): any;
        static createTimeSpanArray(value: Windows.Foundation.TimeSpan[]): any;
        static createPointArray(value: Windows.Foundation.Point[]): any;
        static createSizeArray(value: Windows.Foundation.Size[]): any;
        static createRectArray(value: Windows.Foundation.Rect[]): any;
    }

    export class Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class Size {
        width: number;
        height: number;
    }

    export class TimeSpan {
        duration: number;
    }

    export interface TypedEventHandler<TSender, TResult> {
        target: TSender;
        detail: any[];
        type: string;
    }

    export class Uri implements Windows.Foundation.IUriRuntimeClass, Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri {
        constructor(uri: string);
        constructor(baseUri: string, relativeUri: string);
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        static unescapeComponent(toUnescape: string): string;
        static escapeComponent(toEscape: string): string;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export class WwwFormUrlDecoder implements Windows.Foundation.IWwwFormUrlDecoderRuntimeClass, Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        constructor(query: string);
        getFirstValueByName(name: string): string;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.IWwwFormUrlDecoderEntry>;
        getAt(index: number): Windows.Foundation.IWwwFormUrlDecoderEntry;
        indexOf(value: Windows.Foundation.IWwwFormUrlDecoderEntry): WwwFormUrlDecoder_indexOf_OUT;
        getMany(startIndex: number): WwwFormUrlDecoder_getMany_OUT;
        size: number;
    }

    interface WwwFormUrlDecoder_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface WwwFormUrlDecoder_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.IWwwFormUrlDecoderEntry[];
    }

}
declare module Windows.Foundation.Collections {

    enum CollectionChange {
        reset,
        itemInserted,
        itemRemoved,
        itemChanged
    }

    export interface IIterable<T> {
        first(): Windows.Foundation.Collections.IIterator<T>;
    }

    export interface IIterator<T> {
        moveNext(): boolean;
        getMany(): IIterator_getMany_OUT<T>;
        current: T;
        hasCurrent: boolean;
    }

    interface IIterator_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IKeyValuePair<K, V> {
        key: K;
        value: V;
    }

    export interface IMap<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        getView(): Windows.Foundation.Collections.IMapView<K,V>;
        insert(key: K, value: V): boolean;
        remove(key: K): void;
        clear(): void;
        size: number;
    }

    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }

    export interface IMapView<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        split(): IMapView_split_OUT<K, V>;
        size: number;
    }

    interface IMapView_split_OUT<K, V> {
        first: Windows.Foundation.Collections.IMapView<K,V>;
        second: Windows.Foundation.Collections.IMapView<K,V>;
    }

    export interface IObservableMap<K, V> extends Windows.Foundation.Collections.IMap<K,V> {
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<K,V>) => void;

    }

    export interface IObservableVector<T> extends Windows.Foundation.Collections.IVector<T> {
        add_VectorChanged(vhnd: Windows.Foundation.Collections.VectorChangedEventHandler<T>): Windows.Foundation.EventRegistrationToken;
        remove_VectorChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        removeEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        onvectorchanged: (ev: Windows.Foundation.Collections.VectorChangedEventHandler<T>) => void;

    }

    export interface IPropertySet extends Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
    }

    export interface IVector<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        getView(): Windows.Foundation.Collections.IVectorView<T>;
        indexOf(value: T): IVector_indexOf_OUT<T>;
        setAt(index: number, value: T): void;
        insertAt(index: number, value: T): void;
        removeAt(index: number): void;
        append(value: T): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): IVector_getMany_OUT<T>;
        replaceAll(items: T[]): void;
        size: number;
    }

    interface IVector_indexOf_OUT<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVector_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IVectorChangedEventArgs {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        index: number;
    }

    export interface IVectorView<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        indexOf(value: T): IVectorView_indexOf_OUT<T>;
        getMany(startIndex: number): IVectorView_getMany_OUT<T>;
        size: number;
    }

    interface IVectorView_indexOf_OUT<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVectorView_getMany_OUT<T> {
        __returnValue: number;
        items: T[];
    }

    export interface MapChangedEventHandler<K, V> {
        target: Windows.Foundation.Collections.IObservableMap<K,V>;
        detail: any[];
        type: string;
    }

    export class PropertySet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export interface VectorChangedEventHandler<T> {
        target: Windows.Foundation.Collections.IObservableVector<T>;
        detail: any[];
        type: string;
    }

}
declare module Windows.Foundation.Diagnostics {

    enum ErrorOptions {
        none,
        suppressExceptions,
        forceExceptions,
        useSetErrorInfo,
        suppressSetErrorInfo
    }

    export interface IErrorReportingSettings {
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

    export class RuntimeBrokerErrorSettings implements Windows.Foundation.Diagnostics.IErrorReportingSettings {
        constructor();
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

}
declare module Windows.Foundation.Metadata {

    export class ActivatableAttribute {
        constructor(version: number);
        constructor(type: string /*System.Type?*/, version: number);
    }

    export class AllowMultipleAttribute {
        constructor();
    }

    enum AttributeTargets {
        delegate,
        enum,
        event,
        field,
        interface,
        method,
        parameter,
        property,
        runtimeClass,
        struct,
        interfaceImpl,
        all
    }

    export class AttributeUsageAttribute {
        constructor(targets: Windows.Foundation.Metadata.AttributeTargets);
    }

    export class ComposableAttribute {
        constructor(type: string /*System.Type?*/, compositionType: Windows.Foundation.Metadata.CompositionType, version: number);
    }

    enum CompositionType {
        protected,
        public
    }

    export class DefaultAttribute {
        constructor();
    }

    export class DefaultOverloadAttribute {
        constructor();
    }

    export class DualApiPartitionAttribute {
        constructor();
        version: number;
    }

    export class ExclusiveToAttribute {
        constructor(typeName: string /*System.Type?*/);
    }

    enum GCPressureAmount {
        low,
        medium,
        high
    }

    export class GCPressureAttribute {
        constructor();
        amount: Windows.Foundation.Metadata.GCPressureAmount;
    }

    export class GuidAttribute {
        constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number);
    }

    export class HasVariantAttribute {
        constructor();
    }

    export class LengthIsAttribute {
        constructor(indexLengthParameter: number);
    }

    export class MarshalingBehaviorAttribute {
        constructor(behavior: Windows.Foundation.Metadata.MarshalingType);
    }

    enum MarshalingType {
        invalidMarshaling,
        none,
        agile,
        standard
    }

    export class MuseAttribute {
        constructor();
        version: number;
    }

    export class OverloadAttribute {
        constructor(method: string);
    }

    export class OverridableAttribute {
        constructor();
    }

    export class ProtectedAttribute {
        constructor();
    }

    export class RangeAttribute {
        constructor(minValue: number, maxValue: number);
    }

    export class StaticAttribute {
        constructor(type: string /*System.Type?*/, version: number);
    }

    export class ThreadingAttribute {
        constructor(model: Windows.Foundation.Metadata.ThreadingModel);
    }

    enum ThreadingModel {
        invalidThreading,
        sta,
        mta,
        both
    }

    export class VariantAttribute {
        constructor();
    }

    export class VersionAttribute {
        constructor(version: number);
    }

    export class WebHostHiddenAttribute {
        constructor();
    }

}
declare module Windows.Globalization {

    export class ApplicationLanguages {
        static languages: Windows.Foundation.Collections.IVectorView<string>;
        static manifestLanguages: Windows.Foundation.Collections.IVectorView<string>;
        static primaryLanguageOverride: string;
    }

    export class Calendar implements Windows.Globalization.ICalendar {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, calendar: string, clock: string);
        constructor();
        clone(): Windows.Globalization.Calendar;
        setToMin(): void;
        setToMax(): void;
        getCalendarSystem(): string;
        changeCalendarSystem(value: string): void;
        getClock(): string;
        changeClock(value: string): void;
        getDateTime(): Date;
        setDateTime(value: Date): void;
        setToNow(): void;
        addEras(eras: number): void;
        eraAsString(): string;
        eraAsString(idealLength: number): string;
        addYears(years: number): void;
        yearAsString(): string;
        yearAsTruncatedString(remainingDigits: number): string;
        yearAsPaddedString(minDigits: number): string;
        addMonths(months: number): void;
        monthAsString(): string;
        monthAsString(idealLength: number): string;
        monthAsSoloString(): string;
        monthAsSoloString(idealLength: number): string;
        monthAsNumericString(): string;
        monthAsPaddedNumericString(minDigits: number): string;
        addWeeks(weeks: number): void;
        addDays(days: number): void;
        dayAsString(): string;
        dayAsPaddedString(minDigits: number): string;
        dayOfWeekAsString(): string;
        dayOfWeekAsString(idealLength: number): string;
        dayOfWeekAsSoloString(): string;
        dayOfWeekAsSoloString(idealLength: number): string;
        addPeriods(periods: number): void;
        periodAsString(): string;
        periodAsString(idealLength: number): string;
        addHours(hours: number): void;
        hourAsString(): string;
        hourAsPaddedString(minDigits: number): string;
        addMinutes(minutes: number): void;
        minuteAsString(): string;
        minuteAsPaddedString(minDigits: number): string;
        addSeconds(seconds: number): void;
        secondAsString(): string;
        secondAsPaddedString(minDigits: number): string;
        addNanoseconds(nanoseconds: number): void;
        nanosecondAsString(): string;
        nanosecondAsPaddedString(minDigits: number): string;
        compare(other: Windows.Globalization.Calendar): number;
        compareDateTime(other: Date): number;
        copyTo(other: Windows.Globalization.Calendar): void;
        day: number;
        dayOfWeek: Windows.Globalization.DayOfWeek;
        era: number;
        firstDayInThisMonth: number;
        firstEra: number;
        firstHourInThisPeriod: number;
        firstMinuteInThisHour: number;
        firstMonthInThisYear: number;
        firstPeriodInThisDay: number;
        firstSecondInThisMinute: number;
        firstYearInThisEra: number;
        hour: number;
        isDaylightSavingTime: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        lastDayInThisMonth: number;
        lastEra: number;
        lastHourInThisPeriod: number;
        lastMinuteInThisHour: number;
        lastMonthInThisYear: number;
        lastPeriodInThisDay: number;
        lastSecondInThisMinute: number;
        lastYearInThisEra: number;
        minute: number;
        month: number;
        nanosecond: number;
        numberOfDaysInThisMonth: number;
        numberOfEras: number;
        numberOfHoursInThisPeriod: number;
        numberOfMinutesInThisHour: number;
        numberOfMonthsInThisYear: number;
        numberOfPeriodsInThisDay: number;
        numberOfSecondsInThisMinute: number;
        numberOfYearsInThisEra: number;
        numeralSystem: string;
        period: number;
        resolvedLanguage: string;
        second: number;
        year: number;
    }

    export class CalendarIdentifiers {
        static gregorian: string;
        static hebrew: string;
        static hijri: string;
        static japanese: string;
        static julian: string;
        static korean: string;
        static taiwan: string;
        static thai: string;
        static umAlQura: string;
    }

    export class ClockIdentifiers {
        static twelveHour: string;
        static twentyFourHour: string;
    }

    enum DayOfWeek {
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday,
        saturday
    }

    export class GeographicRegion implements Windows.Globalization.IGeographicRegion {
        constructor(geographicRegionCode: string);
        constructor();
        static isSupported(geographicRegionCode: string): boolean;
        code: string;
        codeThreeDigit: string;
        codeThreeLetter: string;
        codeTwoLetter: string;
        currenciesInUse: Windows.Foundation.Collections.IVectorView<string>;
        displayName: string;
        nativeName: string;
    }

    export interface ICalendar {
        clone(): Windows.Globalization.Calendar;
        setToMin(): void;
        setToMax(): void;
        getCalendarSystem(): string;
        changeCalendarSystem(value: string): void;
        getClock(): string;
        changeClock(value: string): void;
        getDateTime(): Date;
        setDateTime(value: Date): void;
        setToNow(): void;
        addEras(eras: number): void;
        eraAsString(): string;
        eraAsString(idealLength: number): string;
        addYears(years: number): void;
        yearAsString(): string;
        yearAsTruncatedString(remainingDigits: number): string;
        yearAsPaddedString(minDigits: number): string;
        addMonths(months: number): void;
        monthAsString(): string;
        monthAsString(idealLength: number): string;
        monthAsSoloString(): string;
        monthAsSoloString(idealLength: number): string;
        monthAsNumericString(): string;
        monthAsPaddedNumericString(minDigits: number): string;
        addWeeks(weeks: number): void;
        addDays(days: number): void;
        dayAsString(): string;
        dayAsPaddedString(minDigits: number): string;
        dayOfWeekAsString(): string;
        dayOfWeekAsString(idealLength: number): string;
        dayOfWeekAsSoloString(): string;
        dayOfWeekAsSoloString(idealLength: number): string;
        addPeriods(periods: number): void;
        periodAsString(): string;
        periodAsString(idealLength: number): string;
        addHours(hours: number): void;
        hourAsString(): string;
        hourAsPaddedString(minDigits: number): string;
        addMinutes(minutes: number): void;
        minuteAsString(): string;
        minuteAsPaddedString(minDigits: number): string;
        addSeconds(seconds: number): void;
        secondAsString(): string;
        secondAsPaddedString(minDigits: number): string;
        addNanoseconds(nanoseconds: number): void;
        nanosecondAsString(): string;
        nanosecondAsPaddedString(minDigits: number): string;
        compare(other: Windows.Globalization.Calendar): number;
        compareDateTime(other: Date): number;
        copyTo(other: Windows.Globalization.Calendar): void;
        day: number;
        dayOfWeek: Windows.Globalization.DayOfWeek;
        era: number;
        firstDayInThisMonth: number;
        firstEra: number;
        firstHourInThisPeriod: number;
        firstMinuteInThisHour: number;
        firstMonthInThisYear: number;
        firstPeriodInThisDay: number;
        firstSecondInThisMinute: number;
        firstYearInThisEra: number;
        hour: number;
        isDaylightSavingTime: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        lastDayInThisMonth: number;
        lastEra: number;
        lastHourInThisPeriod: number;
        lastMinuteInThisHour: number;
        lastMonthInThisYear: number;
        lastPeriodInThisDay: number;
        lastSecondInThisMinute: number;
        lastYearInThisEra: number;
        minute: number;
        month: number;
        nanosecond: number;
        numberOfDaysInThisMonth: number;
        numberOfEras: number;
        numberOfHoursInThisPeriod: number;
        numberOfMinutesInThisHour: number;
        numberOfMonthsInThisYear: number;
        numberOfPeriodsInThisDay: number;
        numberOfSecondsInThisMinute: number;
        numberOfYearsInThisEra: number;
        numeralSystem: string;
        period: number;
        resolvedLanguage: string;
        second: number;
        year: number;
    }

    export interface IGeographicRegion {
        code: string;
        codeThreeDigit: string;
        codeThreeLetter: string;
        codeTwoLetter: string;
        currenciesInUse: Windows.Foundation.Collections.IVectorView<string>;
        displayName: string;
        nativeName: string;
    }

    export interface ILanguage {
        displayName: string;
        languageTag: string;
        nativeName: string;
        script: string;
    }

    export class Language implements Windows.Globalization.ILanguage {
        constructor(languageTag: string);
        static isWellFormed(languageTag: string): boolean;
        displayName: string;
        languageTag: string;
        nativeName: string;
        script: string;
        static currentInputMethodLanguageTag: string;
    }

}
declare module Windows.Globalization.Collation {

    export class CharacterGrouping implements Windows.Globalization.Collation.ICharacterGrouping {
        first: string;
        label: string;
    }

    export class CharacterGroupings implements Windows.Globalization.Collation.ICharacterGroupings, Windows.Foundation.Collections.IVectorView<Windows.Globalization.Collation.CharacterGrouping>, Windows.Foundation.Collections.IIterable<Windows.Globalization.Collation.CharacterGrouping> {
        constructor();
        lookup(text: string): string;
        getAt(index: number): Windows.Globalization.Collation.CharacterGrouping;
        indexOf(value: Windows.Globalization.Collation.CharacterGrouping): CharacterGroupings_indexOf_OUT;
        getMany(startIndex: number): CharacterGroupings_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Globalization.Collation.CharacterGrouping>;
        size: number;
    }

    interface CharacterGroupings_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface CharacterGroupings_getMany_OUT {
        __returnValue: number;
        items: Windows.Globalization.Collation.CharacterGrouping[];
    }

    export interface ICharacterGrouping {
        first: string;
        label: string;
    }

    export interface ICharacterGroupings extends Windows.Foundation.Collections.IVectorView<Windows.Globalization.Collation.CharacterGrouping>, Windows.Foundation.Collections.IIterable<Windows.Globalization.Collation.CharacterGrouping> {
        lookup(text: string): string;
    }

}
declare module Windows.Globalization.DateTimeFormatting {

    export class DateTimeFormatter implements Windows.Globalization.DateTimeFormatting.IDateTimeFormatter {
        constructor(formatTemplate: string);
        constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(formatTemplate: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat);
        constructor(hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>);
        constructor(yearFormat: Windows.Globalization.DateTimeFormatting.YearFormat, monthFormat: Windows.Globalization.DateTimeFormatting.MonthFormat, dayFormat: Windows.Globalization.DateTimeFormatting.DayFormat, dayOfWeekFormat: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat, hourFormat: Windows.Globalization.DateTimeFormatting.HourFormat, minuteFormat: Windows.Globalization.DateTimeFormatting.MinuteFormat, secondFormat: Windows.Globalization.DateTimeFormatting.SecondFormat, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string, calendar: string, clock: string);
        format(value: Date): string;
        calendar: string;
        clock: string;
        geographicRegion: string;
        includeDay: Windows.Globalization.DateTimeFormatting.DayFormat;
        includeDayOfWeek: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat;
        includeHour: Windows.Globalization.DateTimeFormatting.HourFormat;
        includeMinute: Windows.Globalization.DateTimeFormatting.MinuteFormat;
        includeMonth: Windows.Globalization.DateTimeFormatting.MonthFormat;
        includeSecond: Windows.Globalization.DateTimeFormatting.SecondFormat;
        includeYear: Windows.Globalization.DateTimeFormatting.YearFormat;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        patterns: Windows.Foundation.Collections.IVectorView<string>;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
        template: string;
        static longDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static longTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static shortDate: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
        static shortTime: Windows.Globalization.DateTimeFormatting.DateTimeFormatter;
    }

    enum DayFormat {
        none,
        default
    }

    enum DayOfWeekFormat {
        none,
        default,
        abbreviated,
        full
    }

    enum HourFormat {
        none,
        default
    }

    export interface IDateTimeFormatter {
        format(value: Date): string;
        calendar: string;
        clock: string;
        geographicRegion: string;
        includeDay: Windows.Globalization.DateTimeFormatting.DayFormat;
        includeDayOfWeek: Windows.Globalization.DateTimeFormatting.DayOfWeekFormat;
        includeHour: Windows.Globalization.DateTimeFormatting.HourFormat;
        includeMinute: Windows.Globalization.DateTimeFormatting.MinuteFormat;
        includeMonth: Windows.Globalization.DateTimeFormatting.MonthFormat;
        includeSecond: Windows.Globalization.DateTimeFormatting.SecondFormat;
        includeYear: Windows.Globalization.DateTimeFormatting.YearFormat;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        patterns: Windows.Foundation.Collections.IVectorView<string>;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
        template: string;
    }

    enum MinuteFormat {
        none,
        default
    }

    enum MonthFormat {
        none,
        default,
        abbreviated,
        full,
        numeric
    }

    enum SecondFormat {
        none,
        default
    }

    enum YearFormat {
        none,
        default,
        abbreviated,
        full
    }

}
declare module Windows.Globalization.Fonts {

    export interface ILanguageFont {
        fontFamily: string;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        scaleFactor: number;
    }

    export interface ILanguageFontGroup {
        documentAlternate1Font: Windows.Globalization.Fonts.LanguageFont;
        documentAlternate2Font: Windows.Globalization.Fonts.LanguageFont;
        documentHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        fixedWidthTextFont: Windows.Globalization.Fonts.LanguageFont;
        modernDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        traditionalDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        uICaptionFont: Windows.Globalization.Fonts.LanguageFont;
        uIHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uINotificationHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uITextFont: Windows.Globalization.Fonts.LanguageFont;
        uITitleFont: Windows.Globalization.Fonts.LanguageFont;
    }

    export class LanguageFont implements Windows.Globalization.Fonts.ILanguageFont {
        fontFamily: string;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        scaleFactor: number;
    }

    export class LanguageFontGroup implements Windows.Globalization.Fonts.ILanguageFontGroup {
        constructor(languageTag: string);
        documentAlternate1Font: Windows.Globalization.Fonts.LanguageFont;
        documentAlternate2Font: Windows.Globalization.Fonts.LanguageFont;
        documentHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        fixedWidthTextFont: Windows.Globalization.Fonts.LanguageFont;
        modernDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        traditionalDocumentFont: Windows.Globalization.Fonts.LanguageFont;
        uICaptionFont: Windows.Globalization.Fonts.LanguageFont;
        uIHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uINotificationHeadingFont: Windows.Globalization.Fonts.LanguageFont;
        uITextFont: Windows.Globalization.Fonts.LanguageFont;
        uITitleFont: Windows.Globalization.Fonts.LanguageFont;
    }

}
declare module Windows.Globalization.NumberFormatting {

    export class CurrencyFormatter implements Windows.Globalization.NumberFormatting.ICurrencyFormatter, Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(currencyCode: string);
        constructor(currencyCode: string, languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        currency: string;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export class DecimalFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export interface ICurrencyFormatter extends Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        currency: string;
    }

    export interface INumberFormatter {
        format(value: number): string;
    }

    export interface INumberFormatter2 {
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
    }

    export interface INumberFormatterOptions {
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export interface INumberParser {
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
    }

    export class PercentFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

    export class PermilleFormatter implements Windows.Globalization.NumberFormatting.INumberFormatterOptions, Windows.Globalization.NumberFormatting.INumberFormatter, Windows.Globalization.NumberFormatting.INumberFormatter2, Windows.Globalization.NumberFormatting.INumberParser {
        constructor(languages: Windows.Foundation.Collections.IIterable<string>, geographicRegion: string);
        constructor();
        format(value: number): string;
        formatInt(value: number): string;
        formatUInt(value: number): string;
        formatDouble(value: number): string;
        parseInt(text: string): Windows.Foundation.IReference<number>;
        parseUInt(text: string): Windows.Foundation.IReference<number>;
        parseDouble(text: string): Windows.Foundation.IReference<number>;
        fractionDigits: number;
        geographicRegion: string;
        integerDigits: number;
        isDecimalPointAlwaysDisplayed: boolean;
        isGrouped: boolean;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        numeralSystem: string;
        resolvedGeographicRegion: string;
        resolvedLanguage: string;
    }

}
declare module Windows.Graphics.Display {

    enum DisplayOrientations {
        none,
        landscape,
        portrait,
        landscapeFlipped,
        portraitFlipped
    }

    export class DisplayProperties {
        static add_OrientationChanged(handler: Windows.Graphics.Display.DisplayPropertiesEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_OrientationChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static add_LogicalDpiChanged(handler: Windows.Graphics.Display.DisplayPropertiesEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_LogicalDpiChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static add_StereoEnabledChanged(handler: Windows.Graphics.Display.DisplayPropertiesEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_StereoEnabledChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getColorProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        static add_ColorProfileChanged(handler: Windows.Graphics.Display.DisplayPropertiesEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_ColorProfileChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static add_DisplayContentsInvalidated(handler: Windows.Graphics.Display.DisplayPropertiesEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_DisplayContentsInvalidated(token: Windows.Foundation.EventRegistrationToken): void;
        static autoRotationPreferences: Windows.Graphics.Display.DisplayOrientations;
        static currentOrientation: Windows.Graphics.Display.DisplayOrientations;
        static logicalDpi: number;
        static nativeOrientation: Windows.Graphics.Display.DisplayOrientations;
        static resolutionScale: Windows.Graphics.Display.ResolutionScale;
        static stereoEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "colorprofilechanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        oncolorprofilechanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "displaycontentsinvalidated", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        ondisplaycontentsinvalidated: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "logicaldpichanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onlogicaldpichanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "orientationchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onorientationchanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;
        addEventListener(eventName: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        removeEventListener(eventName: "stereoenabledchanged", listener: Windows.Graphics.Display.DisplayPropertiesEventHandler): void;
        onstereoenabledchanged: (ev: Windows.Graphics.Display.DisplayPropertiesEventHandler) => void;

    }

    export interface DisplayPropertiesEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum ResolutionScale {
        invalid,
        scale100Percent,
        scale140Percent,
        scale180Percent
    }

}
declare module Windows.Graphics.Imaging {

    enum BitmapAlphaMode {
        premultiplied,
        straight,
        ignore
    }

    export class BitmapBounds {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class BitmapCodecInformation implements Windows.Graphics.Imaging.IBitmapCodecInformation {
        codecId: string;
        fileExtensions: Windows.Foundation.Collections.IVectorView<string>;
        friendlyName: string;
        mimeTypes: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class BitmapDecoder implements Windows.Graphics.Imaging.IBitmapDecoder, Windows.Graphics.Imaging.IBitmapFrame {
        getPreviewAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getFrameAsync(frameIndex: number): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapFrame>;
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        static getDecoderInformationEnumerator(): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
        static createAsync(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
        static createAsync(decoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapDecoder>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        decoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        frameCount: number;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
        static bmpDecoderId: string;
        static gifDecoderId: string;
        static icoDecoderId: string;
        static jpegDecoderId: string;
        static jpegXRDecoderId: string;
        static pngDecoderId: string;
        static tiffDecoderId: string;
    }

    export class BitmapEncoder implements Windows.Graphics.Imaging.IBitmapEncoder {
        setPixelData(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, width: number, height: number, dpiX: number, dpiY: number, pixels: any): void;
        goToNextFrameAsync(): Windows.Foundation.IAsyncAction;
        goToNextFrameAsync(encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        flushAsync(): Windows.Foundation.IAsyncAction;
        static getEncoderInformationEnumerator(): Windows.Foundation.Collections.IVectorView<Windows.Graphics.Imaging.BitmapCodecInformation>;
        static createAsync(encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createAsync(encoderId: string, stream: Windows.Storage.Streams.IRandomAccessStream, encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createForTranscodingAsync(stream: Windows.Storage.Streams.IRandomAccessStream, bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        static createForInPlacePropertyEncodingAsync(bitmapDecoder: Windows.Graphics.Imaging.BitmapDecoder): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapEncoder>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapTransform: Windows.Graphics.Imaging.BitmapTransform;
        encoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        generatedThumbnailHeight: number;
        generatedThumbnailWidth: number;
        isThumbnailGenerated: boolean;
        static bmpEncoderId: string;
        static gifEncoderId: string;
        static jpegEncoderId: string;
        static jpegXREncoderId: string;
        static pngEncoderId: string;
        static tiffEncoderId: string;
    }

    enum BitmapFlip {
        none,
        horizontal,
        vertical
    }

    export class BitmapFrame implements Windows.Graphics.Imaging.IBitmapFrame {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
    }

    enum BitmapInterpolationMode {
        nearestNeighbor,
        linear,
        cubic,
        fant
    }

    enum BitmapPixelFormat {
        unknown,
        rgba16,
        rgba8,
        bgra8
    }

    export class BitmapProperties implements Windows.Graphics.Imaging.IBitmapProperties, Windows.Graphics.Imaging.IBitmapPropertiesView {
        setPropertiesAsync(propertiesToSet: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export class BitmapPropertiesView implements Windows.Graphics.Imaging.IBitmapPropertiesView {
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export class BitmapPropertySet implements Windows.Foundation.Collections.IMap<string,Windows.Graphics.Imaging.BitmapTypedValue>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>> {
        constructor();
        lookup(key: string): Windows.Graphics.Imaging.BitmapTypedValue;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Imaging.BitmapTypedValue>;
        insert(key: string, value: Windows.Graphics.Imaging.BitmapTypedValue): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>;
        size: number;
    }

    enum BitmapRotation {
        none,
        clockwise90Degrees,
        clockwise180Degrees,
        clockwise270Degrees
    }

    export class BitmapTransform implements Windows.Graphics.Imaging.IBitmapTransform {
        constructor();
        bounds: Windows.Graphics.Imaging.BitmapBounds;
        flip: Windows.Graphics.Imaging.BitmapFlip;
        interpolationMode: Windows.Graphics.Imaging.BitmapInterpolationMode;
        rotation: Windows.Graphics.Imaging.BitmapRotation;
        scaledHeight: number;
        scaledWidth: number;
    }

    export class BitmapTypedValue implements Windows.Graphics.Imaging.IBitmapTypedValue {
        constructor(value: any, type: Windows.Foundation.PropertyType);
        type: Windows.Foundation.PropertyType;
        value: any;
    }

    enum ColorManagementMode {
        doNotColorManage,
        colorManageToSRgb
    }

    enum ExifOrientationMode {
        ignoreExifOrientation,
        respectExifOrientation
    }

    export interface IBitmapCodecInformation {
        codecId: string;
        fileExtensions: Windows.Foundation.Collections.IVectorView<string>;
        friendlyName: string;
        mimeTypes: Windows.Foundation.Collections.IVectorView<string>;
    }

    export interface IBitmapDecoder {
        getPreviewAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getFrameAsync(frameIndex: number): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapFrame>;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        decoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        frameCount: number;
    }

    export interface IBitmapEncoder {
        setPixelData(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, width: number, height: number, dpiX: number, dpiY: number, pixels: any): void;
        goToNextFrameAsync(): Windows.Foundation.IAsyncAction;
        goToNextFrameAsync(encodingOptions: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
        flushAsync(): Windows.Foundation.IAsyncAction;
        bitmapContainerProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapProperties: Windows.Graphics.Imaging.BitmapProperties;
        bitmapTransform: Windows.Graphics.Imaging.BitmapTransform;
        encoderInformation: Windows.Graphics.Imaging.BitmapCodecInformation;
        generatedThumbnailHeight: number;
        generatedThumbnailWidth: number;
        isThumbnailGenerated: boolean;
    }

    export interface IBitmapFrame {
        getThumbnailAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.ImageStream>;
        getPixelDataAsync(): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        getPixelDataAsync(pixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat, alphaMode: Windows.Graphics.Imaging.BitmapAlphaMode, transform: Windows.Graphics.Imaging.BitmapTransform, exifOrientationMode: Windows.Graphics.Imaging.ExifOrientationMode, colorManagementMode: Windows.Graphics.Imaging.ColorManagementMode): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.PixelDataProvider>;
        bitmapAlphaMode: Windows.Graphics.Imaging.BitmapAlphaMode;
        bitmapPixelFormat: Windows.Graphics.Imaging.BitmapPixelFormat;
        bitmapProperties: Windows.Graphics.Imaging.BitmapPropertiesView;
        dpiX: number;
        dpiY: number;
        orientedPixelHeight: number;
        orientedPixelWidth: number;
        pixelHeight: number;
        pixelWidth: number;
    }

    export interface IBitmapProperties extends Windows.Graphics.Imaging.IBitmapPropertiesView {
        setPropertiesAsync(propertiesToSet: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Graphics.Imaging.BitmapTypedValue>>): Windows.Foundation.IAsyncAction;
    }

    export interface IBitmapPropertiesView {
        getPropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Graphics.Imaging.BitmapPropertySet>;
    }

    export interface IBitmapTransform {
        bounds: Windows.Graphics.Imaging.BitmapBounds;
        flip: Windows.Graphics.Imaging.BitmapFlip;
        interpolationMode: Windows.Graphics.Imaging.BitmapInterpolationMode;
        rotation: Windows.Graphics.Imaging.BitmapRotation;
        scaledHeight: number;
        scaledWidth: number;
    }

    export interface IBitmapTypedValue {
        type: Windows.Foundation.PropertyType;
        value: any;
    }

    export class ImageStream implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
    }

    export interface IPixelDataProvider {
        detachPixelData(): any;
    }

    enum JpegSubsamplingMode {
        default,
        y4Cb2Cr0,
        y4Cb2Cr2,
        y4Cb4Cr4
    }

    export class PixelDataProvider implements Windows.Graphics.Imaging.IPixelDataProvider {
        detachPixelData(): any;
    }

    enum PngFilterMode {
        automatic,
        none,
        sub,
        up,
        average,
        paeth,
        adaptive
    }

    enum TiffCompressionMode {
        automatic,
        none,
        ccitt3,
        ccitt4,
        lzw,
        rle,
        zip,
        lzwhDifferencing
    }

}
declare module Windows.Graphics.Printing {

    export interface IPrintDocumentSource {
    }

    export interface IPrintManager {
        add_PrintTaskRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PrintTaskRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        removeEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        onprinttaskrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>) => void;

    }

    export interface IPrintTask {
        add_Previewing(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): Windows.Foundation.EventRegistrationToken;
        remove_Previewing(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Submitting(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): Windows.Foundation.EventRegistrationToken;
        remove_Submitting(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Progressing(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Progressing(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        options: Windows.Graphics.Printing.PrintTaskOptions;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        source: Windows.Graphics.Printing.IPrintDocumentSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>) => void;
        addEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onpreviewing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;
        addEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        removeEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        onprogressing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>) => void;
        addEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onsubmitting: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;

    }

    export interface IPrintTaskCompletedEventArgs {
        completion: Windows.Graphics.Printing.PrintTaskCompletion;
    }

    export interface IPrintTaskOptionsCore {
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
    }

    export interface IPrintTaskOptionsCoreProperties {
        binding: Windows.Graphics.Printing.PrintBinding;
        collation: Windows.Graphics.Printing.PrintCollation;
        colorMode: Windows.Graphics.Printing.PrintColorMode;
        duplex: Windows.Graphics.Printing.PrintDuplex;
        holePunch: Windows.Graphics.Printing.PrintHolePunch;
        maxCopies: number;
        mediaSize: Windows.Graphics.Printing.PrintMediaSize;
        mediaType: Windows.Graphics.Printing.PrintMediaType;
        minCopies: number;
        numberOfCopies: number;
        orientation: Windows.Graphics.Printing.PrintOrientation;
        printQuality: Windows.Graphics.Printing.PrintQuality;
        staple: Windows.Graphics.Printing.PrintStaple;
    }

    export interface IPrintTaskOptionsCoreUIConfiguration {
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
    }

    export interface IPrintTaskProgressingEventArgs {
        documentPageCount: number;
    }

    export interface IPrintTaskRequest {
        createPrintTask(title: string, handler: Windows.Graphics.Printing.PrintTaskSourceRequestedHandler): Windows.Graphics.Printing.PrintTask;
        getDeferral(): Windows.Graphics.Printing.PrintTaskRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskRequestedDeferral {
        complete(): void;
    }

    export interface IPrintTaskRequestedEventArgs {
        request: Windows.Graphics.Printing.PrintTaskRequest;
    }

    export interface IPrintTaskSourceRequestedArgs {
        setSource(source: Windows.Graphics.Printing.IPrintDocumentSource): void;
        getDeferral(): Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral;
        deadline: Date;
    }

    export interface IPrintTaskSourceRequestedDeferral {
        complete(): void;
    }

    enum PrintBinding {
        default,
        notAvailable,
        printerCustom,
        none,
        bale,
        bindBottom,
        bindLeft,
        bindRight,
        bindTop,
        booklet,
        edgeStitchBottom,
        edgeStitchLeft,
        edgeStitchRight,
        edgeStitchTop,
        fold,
        jogOffset,
        trim
    }

    enum PrintCollation {
        default,
        notAvailable,
        printerCustom,
        collated,
        uncollated
    }

    enum PrintColorMode {
        default,
        notAvailable,
        printerCustom,
        color,
        grayscale,
        monochrome
    }

    enum PrintDuplex {
        default,
        notAvailable,
        printerCustom,
        oneSided,
        twoSidedShortEdge,
        twoSidedLongEdge
    }

    enum PrintHolePunch {
        default,
        notAvailable,
        printerCustom,
        none,
        leftEdge,
        rightEdge,
        topEdge,
        bottomEdge
    }

    export class PrintManager implements Windows.Graphics.Printing.IPrintManager {
        add_PrintTaskRequested(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PrintTaskRequested(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.Graphics.Printing.PrintManager;
        static showPrintUIAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        removeEventListener(eventName: "printtaskrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>): void;
        onprinttaskrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintManager,Windows.Graphics.Printing.PrintTaskRequestedEventArgs>) => void;

    }

    enum PrintMediaSize {
        default,
        notAvailable,
        printerCustom,
        businessCard,
        creditCard,
        isoA0,
        isoA1,
        isoA10,
        isoA2,
        isoA3,
        isoA3Extra,
        isoA3Rotated,
        isoA4,
        isoA4Extra,
        isoA4Rotated,
        isoA5,
        isoA5Extra,
        isoA5Rotated,
        isoA6,
        isoA6Rotated,
        isoA7,
        isoA8,
        isoA9,
        isoB0,
        isoB1,
        isoB10,
        isoB2,
        isoB3,
        isoB4,
        isoB4Envelope,
        isoB5Envelope,
        isoB5Extra,
        isoB7,
        isoB8,
        isoB9,
        isoC0,
        isoC1,
        isoC10,
        isoC2,
        isoC3,
        isoC3Envelope,
        isoC4,
        isoC4Envelope,
        isoC5,
        isoC5Envelope,
        isoC6,
        isoC6C5Envelope,
        isoC6Envelope,
        isoC7,
        isoC8,
        isoC9,
        isoDLEnvelope,
        isoDLEnvelopeRotated,
        isoSRA3,
        japan2LPhoto,
        japanChou3Envelope,
        japanChou3EnvelopeRotated,
        japanChou4Envelope,
        japanChou4EnvelopeRotated,
        japanDoubleHagakiPostcard,
        japanDoubleHagakiPostcardRotated,
        japanHagakiPostcard,
        japanHagakiPostcardRotated,
        japanKaku2Envelope,
        japanKaku2EnvelopeRotated,
        japanKaku3Envelope,
        japanKaku3EnvelopeRotated,
        japanLPhoto,
        japanQuadrupleHagakiPostcard,
        japanYou1Envelope,
        japanYou2Envelope,
        japanYou3Envelope,
        japanYou4Envelope,
        japanYou4EnvelopeRotated,
        japanYou6Envelope,
        japanYou6EnvelopeRotated,
        jisB0,
        jisB1,
        jisB10,
        jisB2,
        jisB3,
        jisB4,
        jisB4Rotated,
        jisB5,
        jisB5Rotated,
        jisB6,
        jisB6Rotated,
        jisB7,
        jisB8,
        jisB9,
        northAmerica10x11,
        northAmerica10x12,
        northAmerica10x14,
        northAmerica11x17,
        northAmerica14x17,
        northAmerica4x6,
        northAmerica4x8,
        northAmerica5x7,
        northAmerica8x10,
        northAmerica9x11,
        northAmericaArchitectureASheet,
        northAmericaArchitectureBSheet,
        northAmericaArchitectureCSheet,
        northAmericaArchitectureDSheet,
        northAmericaArchitectureESheet,
        northAmericaCSheet,
        northAmericaDSheet,
        northAmericaESheet,
        northAmericaExecutive,
        northAmericaGermanLegalFanfold,
        northAmericaGermanStandardFanfold,
        northAmericaLegal,
        northAmericaLegalExtra,
        northAmericaLetter,
        northAmericaLetterExtra,
        northAmericaLetterPlus,
        northAmericaLetterRotated,
        northAmericaMonarchEnvelope,
        northAmericaNote,
        northAmericaNumber10Envelope,
        northAmericaNumber10EnvelopeRotated,
        northAmericaNumber11Envelope,
        northAmericaNumber12Envelope,
        northAmericaNumber14Envelope,
        northAmericaNumber9Envelope,
        northAmericaPersonalEnvelope,
        northAmericaQuarto,
        northAmericaStatement,
        northAmericaSuperA,
        northAmericaSuperB,
        northAmericaTabloid,
        northAmericaTabloidExtra,
        otherMetricA3Plus,
        otherMetricA4Plus,
        otherMetricFolio,
        otherMetricInviteEnvelope,
        otherMetricItalianEnvelope,
        prc10Envelope,
        prc10EnvelopeRotated,
        prc16K,
        prc16KRotated,
        prc1Envelope,
        prc1EnvelopeRotated,
        prc2Envelope,
        prc2EnvelopeRotated,
        prc32K,
        prc32KBig,
        prc32KRotated,
        prc3Envelope,
        prc3EnvelopeRotated,
        prc4Envelope,
        prc4EnvelopeRotated,
        prc5Envelope,
        prc5EnvelopeRotated,
        prc6Envelope,
        prc6EnvelopeRotated,
        prc7Envelope,
        prc7EnvelopeRotated,
        prc8Envelope,
        prc8EnvelopeRotated,
        prc9Envelope,
        prc9EnvelopeRotated,
        roll04Inch,
        roll06Inch,
        roll08Inch,
        roll12Inch,
        roll15Inch,
        roll18Inch,
        roll22Inch,
        roll24Inch,
        roll30Inch,
        roll36Inch,
        roll54Inch
    }

    enum PrintMediaType {
        default,
        notAvailable,
        printerCustom,
        autoSelect,
        archival,
        backPrintFilm,
        bond,
        cardStock,
        continuous,
        envelopePlain,
        envelopeWindow,
        fabric,
        highResolution,
        label,
        multiLayerForm,
        multiPartForm,
        photographic,
        photographicFilm,
        photographicGlossy,
        photographicHighGloss,
        photographicMatte,
        photographicSatin,
        photographicSemiGloss,
        plain,
        screen,
        screenPaged,
        stationery,
        tabStockFull,
        tabStockPreCut,
        transparency,
        tShirtTransfer,
        none
    }

    enum PrintOrientation {
        default,
        notAvailable,
        printerCustom,
        portrait,
        portraitFlipped,
        landscape,
        landscapeFlipped
    }

    export class PrintPageDescription {
        pageSize: Windows.Foundation.Size;
        imageableRect: Windows.Foundation.Rect;
        dpiX: number;
        dpiY: number;
    }

    enum PrintQuality {
        default,
        notAvailable,
        printerCustom,
        automatic,
        draft,
        fax,
        high,
        normal,
        photographic,
        text
    }

    enum PrintStaple {
        default,
        notAvailable,
        printerCustom,
        none,
        stapleTopLeft,
        stapleTopRight,
        stapleBottomLeft,
        stapleBottomRight,
        stapleDualLeft,
        stapleDualRight,
        stapleDualTop,
        stapleDualBottom,
        saddleStitch
    }

    export class PrintTask implements Windows.Graphics.Printing.IPrintTask {
        add_Previewing(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): Windows.Foundation.EventRegistrationToken;
        remove_Previewing(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Submitting(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): Windows.Foundation.EventRegistrationToken;
        remove_Submitting(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Progressing(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Progressing(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        options: Windows.Graphics.Printing.PrintTaskOptions;
        properties: Windows.ApplicationModel.DataTransfer.DataPackagePropertySet;
        source: Windows.Graphics.Printing.IPrintDocumentSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskCompletedEventArgs>) => void;
        addEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "previewing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onpreviewing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;
        addEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        removeEventListener(eventName: "progressing", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>): void;
        onprogressing: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,Windows.Graphics.Printing.PrintTaskProgressingEventArgs>) => void;
        addEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        removeEventListener(eventName: "submitting", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>): void;
        onsubmitting: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.PrintTask,any>) => void;

    }

    export class PrintTaskCompletedEventArgs implements Windows.Graphics.Printing.IPrintTaskCompletedEventArgs {
        completion: Windows.Graphics.Printing.PrintTaskCompletion;
    }

    enum PrintTaskCompletion {
        abandoned,
        canceled,
        failed,
        submitted
    }

    export class PrintTaskOptions implements Windows.Graphics.Printing.IPrintTaskOptionsCore, Windows.Graphics.Printing.IPrintTaskOptionsCoreProperties, Windows.Graphics.Printing.IPrintTaskOptionsCoreUIConfiguration {
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
        binding: Windows.Graphics.Printing.PrintBinding;
        collation: Windows.Graphics.Printing.PrintCollation;
        colorMode: Windows.Graphics.Printing.PrintColorMode;
        duplex: Windows.Graphics.Printing.PrintDuplex;
        holePunch: Windows.Graphics.Printing.PrintHolePunch;
        maxCopies: number;
        mediaSize: Windows.Graphics.Printing.PrintMediaSize;
        mediaType: Windows.Graphics.Printing.PrintMediaType;
        minCopies: number;
        numberOfCopies: number;
        orientation: Windows.Graphics.Printing.PrintOrientation;
        printQuality: Windows.Graphics.Printing.PrintQuality;
        staple: Windows.Graphics.Printing.PrintStaple;
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
    }

    export class PrintTaskProgressingEventArgs implements Windows.Graphics.Printing.IPrintTaskProgressingEventArgs {
        documentPageCount: number;
    }

    export class PrintTaskRequest implements Windows.Graphics.Printing.IPrintTaskRequest {
        createPrintTask(title: string, handler: Windows.Graphics.Printing.PrintTaskSourceRequestedHandler): Windows.Graphics.Printing.PrintTask;
        getDeferral(): Windows.Graphics.Printing.PrintTaskRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskRequestedDeferral implements Windows.Graphics.Printing.IPrintTaskRequestedDeferral {
        complete(): void;
    }

    export class PrintTaskRequestedEventArgs implements Windows.Graphics.Printing.IPrintTaskRequestedEventArgs {
        request: Windows.Graphics.Printing.PrintTaskRequest;
    }

    export class PrintTaskSourceRequestedArgs implements Windows.Graphics.Printing.IPrintTaskSourceRequestedArgs {
        setSource(source: Windows.Graphics.Printing.IPrintDocumentSource): void;
        getDeferral(): Windows.Graphics.Printing.PrintTaskSourceRequestedDeferral;
        deadline: Date;
    }

    export class PrintTaskSourceRequestedDeferral implements Windows.Graphics.Printing.IPrintTaskSourceRequestedDeferral {
        complete(): void;
    }

    export interface PrintTaskSourceRequestedHandler {
        target: Windows.Graphics.Printing.PrintTaskSourceRequestedArgs;
        detail: any[];
        type: string;
    }

    export class StandardPrintTaskOptions {
        static binding: string;
        static collation: string;
        static colorMode: string;
        static copies: string;
        static duplex: string;
        static holePunch: string;
        static inputBin: string;
        static mediaSize: string;
        static mediaType: string;
        static nUp: string;
        static orientation: string;
        static printQuality: string;
        static staple: string;
    }

}
declare module Windows.Graphics.Printing.OptionDetails {

    export interface IPrintCustomItemDetails {
        itemDisplayName: string;
        itemId: string;
    }

    export interface IPrintCustomItemListOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails {
        addItem(itemId: string, displayName: string): void;
    }

    export interface IPrintCustomOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        displayName: string;
    }

    export interface IPrintCustomTextOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxCharacters: number;
    }

    export interface IPrintItemListOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export interface IPrintNumberOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxValue: number;
        minValue: number;
    }

    export interface IPrintOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
    }

    export interface IPrintTaskOptionChangedEventArgs {
        optionId: any;
    }

    export interface IPrintTaskOptionDetails {
        createItemListOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
        createTextOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
        add_OptionChanged(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OptionChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_BeginValidation(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): Windows.Foundation.EventRegistrationToken;
        remove_BeginValidation(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        options: Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        removeEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        onbeginvalidation: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>) => void;
        addEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        removeEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        onoptionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>) => void;

    }

    export interface IPrintTextOptionDetails extends Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails {
        maxCharacters: number;
    }

    export class PrintBindingOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCollationOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintColorModeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCopiesOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintNumberOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        maxValue: number;
        minValue: number;
    }

    export class PrintCustomItemDetails implements Windows.Graphics.Printing.OptionDetails.IPrintCustomItemDetails {
        itemDisplayName: string;
        itemId: string;
    }

    export class PrintCustomItemListOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomItemListOptionDetails {
        trySetValue(value: any): boolean;
        addItem(itemId: string, displayName: string): void;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        displayName: string;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintCustomTextOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintCustomTextOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        displayName: string;
        maxCharacters: number;
    }

    export class PrintDuplexOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintHolePunchOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintMediaSizeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintMediaTypeOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    enum PrintOptionStates {
        none,
        enabled,
        constrained
    }

    enum PrintOptionType {
        unknown,
        number,
        text,
        itemList
    }

    export class PrintOrientationOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintQualityOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintStapleOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails, Windows.Graphics.Printing.OptionDetails.IPrintItemListOptionDetails {
        trySetValue(value: any): boolean;
        errorText: string;
        optionId: string;
        optionType: Windows.Graphics.Printing.OptionDetails.PrintOptionType;
        state: Windows.Graphics.Printing.OptionDetails.PrintOptionStates;
        value: any;
        items: Windows.Foundation.Collections.IVectorView<any>;
    }

    export class PrintTaskOptionChangedEventArgs implements Windows.Graphics.Printing.OptionDetails.IPrintTaskOptionChangedEventArgs {
        optionId: any;
    }

    export class PrintTaskOptionDetails implements Windows.Graphics.Printing.OptionDetails.IPrintTaskOptionDetails, Windows.Graphics.Printing.IPrintTaskOptionsCore, Windows.Graphics.Printing.IPrintTaskOptionsCoreUIConfiguration {
        createItemListOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomItemListOptionDetails;
        createTextOption(optionId: string, displayName: string): Windows.Graphics.Printing.OptionDetails.PrintCustomTextOptionDetails;
        add_OptionChanged(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_OptionChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_BeginValidation(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): Windows.Foundation.EventRegistrationToken;
        remove_BeginValidation(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        getPageDescription(jobPageNumber: number): Windows.Graphics.Printing.PrintPageDescription;
        static getFromPrintTaskOptions(printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions): Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails;
        options: Windows.Foundation.Collections.IMapView<string,Windows.Graphics.Printing.OptionDetails.IPrintOptionDetails>;
        displayedOptions: Windows.Foundation.Collections.IVector<string>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        removeEventListener(eventName: "beginvalidation", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>): void;
        onbeginvalidation: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,any>) => void;
        addEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        removeEventListener(eventName: "optionchanged", listener: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>): void;
        onoptionchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Graphics.Printing.OptionDetails.PrintTaskOptionDetails,Windows.Graphics.Printing.OptionDetails.PrintTaskOptionChangedEventArgs>) => void;

    }

}
declare module Windows.Management.Core {

    export class ApplicationDataManager implements Windows.Management.Core.IApplicationDataManager {
        static createForPackageFamily(packageFamilyName: string): Windows.Storage.ApplicationData;
    }

    export interface IApplicationDataManager {
    }

}
declare module Windows.Management.Deployment {

    enum DeploymentOptions {
        none,
        forceApplicationShutdown,
        developmentMode
    }

    export class DeploymentProgress {
        state: Windows.Management.Deployment.DeploymentProgressState;
        percentage: number;
    }

    enum DeploymentProgressState {
        queued,
        processing
    }

    export class DeploymentResult implements Windows.Management.Deployment.IDeploymentResult {
        activityId: string;
        errorText: string;
        extendedErrorCode: Windows.Foundation.HResult;
    }

    export interface IDeploymentResult {
        activityId: string;
        errorText: string;
        extendedErrorCode: Windows.Foundation.HResult;
    }

    export interface IPackageManager {
        addPackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        updatePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        removePackageAsync(packageFullName: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        stagePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        registerPackageAsync(manifestUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackages(packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findUsers(packageFullName: string): Windows.Foundation.Collections.IIterable<Windows.Management.Deployment.PackageUserInformation>;
        setPackageState(packageFullName: string, packageState: Windows.Management.Deployment.PackageState): void;
        findPackage(packageFullName: string): Windows.ApplicationModel.Package;
        cleanupPackageForUserAsync(packageName: string, userSecurityId: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackageForUser(userSecurityId: string, packageFullName: string): Windows.ApplicationModel.Package;
    }

    export interface IPackageUserInformation {
        installState: Windows.Management.Deployment.PackageInstallState;
        userSecurityId: string;
    }

    enum PackageInstallState {
        notInstalled,
        staged,
        installed
    }

    export class PackageManager implements Windows.Management.Deployment.IPackageManager {
        constructor();
        addPackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        updatePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        removePackageAsync(packageFullName: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        stagePackageAsync(packageUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        registerPackageAsync(manifestUri: Windows.Foundation.Uri, dependencyPackageUris: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, deploymentOptions: Windows.Management.Deployment.DeploymentOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackages(packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageName: string, packagePublisher: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findUsers(packageFullName: string): Windows.Foundation.Collections.IIterable<Windows.Management.Deployment.PackageUserInformation>;
        setPackageState(packageFullName: string, packageState: Windows.Management.Deployment.PackageState): void;
        findPackage(packageFullName: string): Windows.ApplicationModel.Package;
        cleanupPackageForUserAsync(packageName: string, userSecurityId: string): Windows.Foundation.IAsyncOperationWithProgress<Windows.Management.Deployment.DeploymentResult,Windows.Management.Deployment.DeploymentProgress>;
        findPackages(packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackagesForUser(userSecurityId: string, packageFamilyName: string): Windows.Foundation.Collections.IIterable<Windows.ApplicationModel.Package>;
        findPackageForUser(userSecurityId: string, packageFullName: string): Windows.ApplicationModel.Package;
    }

    enum PackageState {
        normal,
        licenseInvalid,
        modified,
        tampered
    }

    export class PackageUserInformation implements Windows.Management.Deployment.IPackageUserInformation {
        installState: Windows.Management.Deployment.PackageInstallState;
        userSecurityId: string;
    }

}
declare module Windows.Media.Capture {

    export class CameraCaptureUI implements Windows.Media.Capture.ICameraCaptureUI {
        constructor();
        captureFileAsync(mode: Windows.Media.Capture.CameraCaptureUIMode): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        photoSettings: Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings;
        videoSettings: Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings;
    }

    enum CameraCaptureUIMaxPhotoResolution {
        highestAvailable,
        verySmallQvga,
        smallVga,
        mediumXga,
        large3M,
        veryLarge5M
    }

    enum CameraCaptureUIMaxVideoResolution {
        highestAvailable,
        lowDefinition,
        standardDefinition,
        highDefinition
    }

    enum CameraCaptureUIMode {
        photoOrVideo,
        photo,
        video
    }

    export class CameraCaptureUIPhotoCaptureSettings implements Windows.Media.Capture.ICameraCaptureUIPhotoCaptureSettings {
        allowCropping: boolean;
        croppedAspectRatio: Windows.Foundation.Size;
        croppedSizeInPixels: Windows.Foundation.Size;
        format: Windows.Media.Capture.CameraCaptureUIPhotoFormat;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution;
    }

    enum CameraCaptureUIPhotoFormat {
        jpeg,
        png,
        jpegXR
    }

    export class CameraCaptureUIVideoCaptureSettings implements Windows.Media.Capture.ICameraCaptureUIVideoCaptureSettings {
        allowTrimming: boolean;
        format: Windows.Media.Capture.CameraCaptureUIVideoFormat;
        maxDurationInSeconds: number;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxVideoResolution;
    }

    enum CameraCaptureUIVideoFormat {
        mp4,
        wmv
    }

    export class CameraOptionsUI {
        static show(mediaCapture: Windows.Media.Capture.MediaCapture): void;
    }

    export interface ICameraCaptureUI {
        captureFileAsync(mode: Windows.Media.Capture.CameraCaptureUIMode): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        photoSettings: Windows.Media.Capture.CameraCaptureUIPhotoCaptureSettings;
        videoSettings: Windows.Media.Capture.CameraCaptureUIVideoCaptureSettings;
    }

    export interface ICameraCaptureUIPhotoCaptureSettings {
        allowCropping: boolean;
        croppedAspectRatio: Windows.Foundation.Size;
        croppedSizeInPixels: Windows.Foundation.Size;
        format: Windows.Media.Capture.CameraCaptureUIPhotoFormat;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxPhotoResolution;
    }

    export interface ICameraCaptureUIVideoCaptureSettings {
        allowTrimming: boolean;
        format: Windows.Media.Capture.CameraCaptureUIVideoFormat;
        maxDurationInSeconds: number;
        maxResolution: Windows.Media.Capture.CameraCaptureUIMaxVideoResolution;
    }

    export interface IMediaCapture {
        initializeAsync(): Windows.Foundation.IAsyncAction;
        initializeAsync(mediaCaptureInitializationSettings: Windows.Media.Capture.MediaCaptureInitializationSettings): Windows.Foundation.IAsyncAction;
        startRecordToStorageFileAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        startRecordToStreamAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopRecordAsync(): Windows.Foundation.IAsyncAction;
        capturePhotoToStorageFileAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        capturePhotoToStreamAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        addEffectAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, effectActivationID: string, effectSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        clearEffectsAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.IAsyncAction;
        setEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string, propertyValue: any): void;
        getEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string): any;
        add_Failed(errorEventHandler: Windows.Media.Capture.MediaCaptureFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Failed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_RecordLimitationExceeded(recordLimitationExceededEventHandler: Windows.Media.Capture.RecordLimitationExceededEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RecordLimitationExceeded(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        setPreviewMirroring(value: boolean): void;
        getPreviewMirroring(): boolean;
        setPreviewRotation(value: Windows.Media.Capture.VideoRotation): void;
        getPreviewRotation(): Windows.Media.Capture.VideoRotation;
        setRecordRotation(value: Windows.Media.Capture.VideoRotation): void;
        getRecordRotation(): Windows.Media.Capture.VideoRotation;
        audioDeviceController: Windows.Media.Devices.AudioDeviceController;
        mediaCaptureSettings: Windows.Media.Capture.MediaCaptureSettings;
        videoDeviceController: Windows.Media.Devices.VideoDeviceController;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        removeEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        onfailed: (ev: Windows.Media.Capture.MediaCaptureFailedEventHandler) => void;
        addEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        removeEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        onrecordlimitationexceeded: (ev: Windows.Media.Capture.RecordLimitationExceededEventHandler) => void;

    }

    export interface IMediaCaptureFailedEventArgs {
        code: number;
        message: string;
    }

    export interface IMediaCaptureInitializationSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceId: string;
    }

    export interface IMediaCaptureSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceCharacteristic: Windows.Media.Capture.VideoDeviceCharacteristic;
        videoDeviceId: string;
    }

    export interface IMediaCaptureVideoPreview {
        startPreviewAsync(): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopPreviewAsync(): Windows.Foundation.IAsyncAction;
    }

    export class MediaCapture implements Windows.Media.Capture.IMediaCapture, Windows.Media.Capture.IMediaCaptureVideoPreview {
        constructor();
        initializeAsync(): Windows.Foundation.IAsyncAction;
        initializeAsync(mediaCaptureInitializationSettings: Windows.Media.Capture.MediaCaptureInitializationSettings): Windows.Foundation.IAsyncAction;
        startRecordToStorageFileAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        startRecordToStreamAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startRecordToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopRecordAsync(): Windows.Foundation.IAsyncAction;
        capturePhotoToStorageFileAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        capturePhotoToStreamAsync(type: Windows.Media.MediaProperties.ImageEncodingProperties, stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        addEffectAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, effectActivationID: string, effectSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        clearEffectsAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.IAsyncAction;
        setEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string, propertyValue: any): void;
        getEncoderProperty(mediaStreamType: Windows.Media.Capture.MediaStreamType, propertyId: string): any;
        add_Failed(errorEventHandler: Windows.Media.Capture.MediaCaptureFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Failed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_RecordLimitationExceeded(recordLimitationExceededEventHandler: Windows.Media.Capture.RecordLimitationExceededEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RecordLimitationExceeded(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        setPreviewMirroring(value: boolean): void;
        getPreviewMirroring(): boolean;
        setPreviewRotation(value: Windows.Media.Capture.VideoRotation): void;
        getPreviewRotation(): Windows.Media.Capture.VideoRotation;
        setRecordRotation(value: Windows.Media.Capture.VideoRotation): void;
        getRecordRotation(): Windows.Media.Capture.VideoRotation;
        startPreviewAsync(): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customMediaSink: Windows.Media.IMediaExtension): Windows.Foundation.IAsyncAction;
        startPreviewToCustomSinkAsync(encodingProfile: Windows.Media.MediaProperties.MediaEncodingProfile, customSinkActivationId: string, customSinkSettings: Windows.Foundation.Collections.IPropertySet): Windows.Foundation.IAsyncAction;
        stopPreviewAsync(): Windows.Foundation.IAsyncAction;
        audioDeviceController: Windows.Media.Devices.AudioDeviceController;
        mediaCaptureSettings: Windows.Media.Capture.MediaCaptureSettings;
        videoDeviceController: Windows.Media.Devices.VideoDeviceController;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        removeEventListener(eventName: "failed", listener: Windows.Media.Capture.MediaCaptureFailedEventHandler): void;
        onfailed: (ev: Windows.Media.Capture.MediaCaptureFailedEventHandler) => void;
        addEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        removeEventListener(eventName: "recordlimitationexceeded", listener: Windows.Media.Capture.RecordLimitationExceededEventHandler): void;
        onrecordlimitationexceeded: (ev: Windows.Media.Capture.RecordLimitationExceededEventHandler) => void;

    }

    export class MediaCaptureFailedEventArgs implements Windows.Media.Capture.IMediaCaptureFailedEventArgs {
        code: number;
        message: string;
    }

    export interface MediaCaptureFailedEventHandler {
        target: Windows.Media.Capture.MediaCapture;
        detail: any[];
        type: string;
    }

    export class MediaCaptureInitializationSettings implements Windows.Media.Capture.IMediaCaptureInitializationSettings {
        constructor();
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceId: string;
    }

    export class MediaCaptureSettings implements Windows.Media.Capture.IMediaCaptureSettings {
        audioDeviceId: string;
        photoCaptureSource: Windows.Media.Capture.PhotoCaptureSource;
        streamingCaptureMode: Windows.Media.Capture.StreamingCaptureMode;
        videoDeviceCharacteristic: Windows.Media.Capture.VideoDeviceCharacteristic;
        videoDeviceId: string;
    }

    enum MediaStreamType {
        videoPreview,
        videoRecord,
        audio,
        photo
    }

    enum PhotoCaptureSource {
        auto,
        videoPreview,
        photo
    }

    enum PowerlineFrequency {
        disabled,
        fiftyHertz,
        sixtyHertz
    }

    export interface RecordLimitationExceededEventHandler {
        target: Windows.Media.Capture.MediaCapture;
        detail: any[];
        type: string;
    }

    enum StreamingCaptureMode {
        audioAndVideo,
        audio,
        video
    }

    enum VideoDeviceCharacteristic {
        allStreamsIndependent,
        previewRecordStreamsIdentical,
        previewPhotoStreamsIdentical,
        recordPhotoStreamsIdentical,
        allStreamsIdentical
    }

    enum VideoRotation {
        none,
        clockwise90Degrees,
        clockwise180Degrees,
        clockwise270Degrees
    }

}
declare module Windows.Media.Devices {

    export class AudioDeviceController implements Windows.Media.Devices.IAudioDeviceController, Windows.Media.Devices.IMediaDeviceController {
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
        muted: boolean;
        volumePercent: number;
    }

    enum AudioDeviceRole {
        default,
        communications
    }

    export class CallControl implements Windows.Media.Devices.ICallControl {
        indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
        indicateNewOutgoingCall(): number;
        indicateActiveCall(callToken: number): void;
        endCall(callToken: number): void;
        add_AnswerRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AnswerRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_HangUpRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_HangUpRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_DialRequested(handler: Windows.Media.Devices.DialRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DialRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_RedialRequested(handler: Windows.Media.Devices.RedialRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RedialRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_KeypadPressed(handler: Windows.Media.Devices.KeypadPressedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeypadPressed(token: Windows.Foundation.EventRegistrationToken): void;
        add_AudioTransferRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AudioTransferRequested(token: Windows.Foundation.EventRegistrationToken): void;
        static getDefault(): Windows.Media.Devices.CallControl;
        static fromId(deviceInterfaceId: string): Windows.Media.Devices.CallControl;
        hasRinger: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onanswerrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onaudiotransferrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        removeEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        ondialrequested: (ev: Windows.Media.Devices.DialRequestedEventHandler) => void;
        addEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onhanguprequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        removeEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        onkeypadpressed: (ev: Windows.Media.Devices.KeypadPressedEventHandler) => void;
        addEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        removeEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        onredialrequested: (ev: Windows.Media.Devices.RedialRequestedEventHandler) => void;

    }

    export interface CallControlEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export class DefaultAudioCaptureDeviceChangedEventArgs implements Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export class DefaultAudioRenderDeviceChangedEventArgs implements Windows.Media.Devices.IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export class DialRequestedEventArgs implements Windows.Media.Devices.IDialRequestedEventArgs {
        handled(): void;
        contact: any;
    }

    export interface DialRequestedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export interface IAdvancedVideoCaptureDeviceController {
        setDeviceProperty(propertyId: string, propertyValue: any): void;
        getDeviceProperty(propertyId: string): any;
    }

    export interface IAudioDeviceController extends Windows.Media.Devices.IMediaDeviceController {
        muted: boolean;
        volumePercent: number;
    }

    export interface ICallControl {
        indicateNewIncomingCall(enableRinger: boolean, callerId: string): number;
        indicateNewOutgoingCall(): number;
        indicateActiveCall(callToken: number): void;
        endCall(callToken: number): void;
        add_AnswerRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AnswerRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_HangUpRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_HangUpRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_DialRequested(handler: Windows.Media.Devices.DialRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DialRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_RedialRequested(handler: Windows.Media.Devices.RedialRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RedialRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_KeypadPressed(handler: Windows.Media.Devices.KeypadPressedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeypadPressed(token: Windows.Foundation.EventRegistrationToken): void;
        add_AudioTransferRequested(handler: Windows.Media.Devices.CallControlEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AudioTransferRequested(token: Windows.Foundation.EventRegistrationToken): void;
        hasRinger: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "answerrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onanswerrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "audiotransferrequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onaudiotransferrequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        removeEventListener(eventName: "dialrequested", listener: Windows.Media.Devices.DialRequestedEventHandler): void;
        ondialrequested: (ev: Windows.Media.Devices.DialRequestedEventHandler) => void;
        addEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        removeEventListener(eventName: "hanguprequested", listener: Windows.Media.Devices.CallControlEventHandler): void;
        onhanguprequested: (ev: Windows.Media.Devices.CallControlEventHandler) => void;
        addEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        removeEventListener(eventName: "keypadpressed", listener: Windows.Media.Devices.KeypadPressedEventHandler): void;
        onkeypadpressed: (ev: Windows.Media.Devices.KeypadPressedEventHandler) => void;
        addEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        removeEventListener(eventName: "redialrequested", listener: Windows.Media.Devices.RedialRequestedEventHandler): void;
        onredialrequested: (ev: Windows.Media.Devices.RedialRequestedEventHandler) => void;

    }

    export interface IDefaultAudioDeviceChangedEventArgs {
        id: string;
        role: Windows.Media.Devices.AudioDeviceRole;
    }

    export interface IDialRequestedEventArgs {
        handled(): void;
        contact: any;
    }

    export interface IKeypadPressedEventArgs {
        telephonyKey: Windows.Media.Devices.TelephonyKey;
    }

    export interface IMediaDeviceControl {
        tryGetValue(): IMediaDeviceControl_tryGetValue_OUT;
        trySetValue(value: number): boolean;
        tryGetAuto(): IMediaDeviceControl_tryGetAuto_OUT;
        trySetAuto(value: boolean): boolean;
        capabilities: Windows.Media.Devices.MediaDeviceControlCapabilities;
    }

    interface IMediaDeviceControl_tryGetValue_OUT {
        __returnValue: boolean;
        value: number;
    }

    interface IMediaDeviceControl_tryGetAuto_OUT {
        __returnValue: boolean;
        value: boolean;
    }

    export interface IMediaDeviceControlCapabilities {
        autoModeSupported: boolean;
        default: number;
        max: number;
        min: number;
        step: number;
        supported: boolean;
    }

    export interface IMediaDeviceController {
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
    }

    export interface IRedialRequestedEventArgs {
        handled(): void;
    }

    export interface IVideoDeviceController extends Windows.Media.Devices.IMediaDeviceController {
        trySetPowerlineFrequency(value: Windows.Media.Capture.PowerlineFrequency): boolean;
        tryGetPowerlineFrequency(): IVideoDeviceController_tryGetPowerlineFrequency_OUT;
        backlightCompensation: Windows.Media.Devices.MediaDeviceControl;
        brightness: Windows.Media.Devices.MediaDeviceControl;
        contrast: Windows.Media.Devices.MediaDeviceControl;
        exposure: Windows.Media.Devices.MediaDeviceControl;
        focus: Windows.Media.Devices.MediaDeviceControl;
        hue: Windows.Media.Devices.MediaDeviceControl;
        pan: Windows.Media.Devices.MediaDeviceControl;
        roll: Windows.Media.Devices.MediaDeviceControl;
        tilt: Windows.Media.Devices.MediaDeviceControl;
        whiteBalance: Windows.Media.Devices.MediaDeviceControl;
        zoom: Windows.Media.Devices.MediaDeviceControl;
    }

    interface IVideoDeviceController_tryGetPowerlineFrequency_OUT {
        __returnValue: boolean;
        value: Windows.Media.Capture.PowerlineFrequency;
    }

    export class KeypadPressedEventArgs implements Windows.Media.Devices.IKeypadPressedEventArgs {
        telephonyKey: Windows.Media.Devices.TelephonyKey;
    }

    export interface KeypadPressedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    export class MediaDevice {
        static getAudioCaptureSelector(): string;
        static getAudioRenderSelector(): string;
        static getVideoCaptureSelector(): string;
        static getDefaultAudioCaptureId(role: Windows.Media.Devices.AudioDeviceRole): string;
        static getDefaultAudioRenderId(role: Windows.Media.Devices.AudioDeviceRole): string;
        static add_DefaultAudioCaptureDeviceChanged(handler: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        static remove_DefaultAudioCaptureDeviceChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_DefaultAudioRenderDeviceChanged(handler: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        static remove_DefaultAudioRenderDeviceChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>): void;
        removeEventListener(eventName: "defaultaudiocapturedevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>): void;
        ondefaultaudiocapturedevicechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioCaptureDeviceChangedEventArgs>) => void;
        addEventListener(eventName: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>): void;
        removeEventListener(eventName: "defaultaudiorenderdevicechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>): void;
        ondefaultaudiorenderdevicechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Media.Devices.DefaultAudioRenderDeviceChangedEventArgs>) => void;

    }

    export class MediaDeviceControl implements Windows.Media.Devices.IMediaDeviceControl {
        tryGetValue(): MediaDeviceControl_tryGetValue_OUT;
        trySetValue(value: number): boolean;
        tryGetAuto(): MediaDeviceControl_tryGetAuto_OUT;
        trySetAuto(value: boolean): boolean;
        capabilities: Windows.Media.Devices.MediaDeviceControlCapabilities;
    }

    interface MediaDeviceControl_tryGetValue_OUT {
        __returnValue: boolean;
        value: number;
    }

    interface MediaDeviceControl_tryGetAuto_OUT {
        __returnValue: boolean;
        value: boolean;
    }

    export class MediaDeviceControlCapabilities implements Windows.Media.Devices.IMediaDeviceControlCapabilities {
        autoModeSupported: boolean;
        default: number;
        max: number;
        min: number;
        step: number;
        supported: boolean;
    }

    export class RedialRequestedEventArgs implements Windows.Media.Devices.IRedialRequestedEventArgs {
        handled(): void;
    }

    export interface RedialRequestedEventHandler {
        target: Windows.Media.Devices.CallControl;
        detail: any[];
        type: string;
    }

    enum TelephonyKey {
        d0,
        d1,
        d2,
        d3,
        d4,
        d5,
        d6,
        d7,
        d8,
        d9,
        star,
        pound,
        a,
        b,
        c,
        d
    }

    export class VideoDeviceController implements Windows.Media.Devices.IVideoDeviceController, Windows.Media.Devices.IMediaDeviceController, Windows.Media.Devices.IAdvancedVideoCaptureDeviceController {
        trySetPowerlineFrequency(value: Windows.Media.Capture.PowerlineFrequency): boolean;
        tryGetPowerlineFrequency(): VideoDeviceController_tryGetPowerlineFrequency_OUT;
        getAvailableMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Foundation.Collections.IVectorView<Windows.Media.MediaProperties.IMediaEncodingProperties>;
        getMediaStreamProperties(mediaStreamType: Windows.Media.Capture.MediaStreamType): Windows.Media.MediaProperties.IMediaEncodingProperties;
        setMediaStreamPropertiesAsync(mediaStreamType: Windows.Media.Capture.MediaStreamType, mediaEncodingProperties: Windows.Media.MediaProperties.IMediaEncodingProperties): Windows.Foundation.IAsyncAction;
        setDeviceProperty(propertyId: string, propertyValue: any): void;
        getDeviceProperty(propertyId: string): any;
        backlightCompensation: Windows.Media.Devices.MediaDeviceControl;
        brightness: Windows.Media.Devices.MediaDeviceControl;
        contrast: Windows.Media.Devices.MediaDeviceControl;
        exposure: Windows.Media.Devices.MediaDeviceControl;
        focus: Windows.Media.Devices.MediaDeviceControl;
        hue: Windows.Media.Devices.MediaDeviceControl;
        pan: Windows.Media.Devices.MediaDeviceControl;
        roll: Windows.Media.Devices.MediaDeviceControl;
        tilt: Windows.Media.Devices.MediaDeviceControl;
        whiteBalance: Windows.Media.Devices.MediaDeviceControl;
        zoom: Windows.Media.Devices.MediaDeviceControl;
    }

    interface VideoDeviceController_tryGetPowerlineFrequency_OUT {
        __returnValue: boolean;
        value: Windows.Media.Capture.PowerlineFrequency;
    }

}
declare module Windows.Media {

    export interface IMediaExtension {
        setProperties(configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    export interface IMediaExtensionManager {
        registerSchemeHandler(activatableClassId: string, scheme: string): void;
        registerSchemeHandler(activatableClassId: string, scheme: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    export class MediaControl {
        static add_SoundLevelChanged(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_SoundLevelChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_PlayPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_PlayPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_PausePressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_PausePressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_StopPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_StopPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_PlayPauseTogglePressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_PlayPauseTogglePressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_RecordPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_RecordPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_NextTrackPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_NextTrackPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_PreviousTrackPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_PreviousTrackPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_FastForwardPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_FastForwardPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_RewindPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_RewindPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_ChannelUpPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_ChannelUpPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_ChannelDownPressed(handler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_ChannelDownPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        static albumArt: Windows.Foundation.Uri;
        static artistName: string;
        static isPlaying: boolean;
        static soundLevel: Windows.Media.SoundLevel;
        static trackName: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "channeldownpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onchanneldownpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "channeluppressed", listener: Windows.Foundation.EventHandler<any>): void;
        onchanneluppressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "fastforwardpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onfastforwardpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "nexttrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onnexttrackpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "pausepressed", listener: Windows.Foundation.EventHandler<any>): void;
        onpausepressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "playpausetogglepressed", listener: Windows.Foundation.EventHandler<any>): void;
        onplaypausetogglepressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "playpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onplaypressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "previoustrackpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onprevioustrackpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recordpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onrecordpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "rewindpressed", listener: Windows.Foundation.EventHandler<any>): void;
        onrewindpressed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "soundlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        onsoundlevelchanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "stoppressed", listener: Windows.Foundation.EventHandler<any>): void;
        onstoppressed: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class MediaExtensionManager implements Windows.Media.IMediaExtensionManager {
        constructor();
        registerSchemeHandler(activatableClassId: string, scheme: string): void;
        registerSchemeHandler(activatableClassId: string, scheme: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string): void;
        registerByteStreamHandler(activatableClassId: string, fileExtension: string, mimeType: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerAudioEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoDecoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string): void;
        registerVideoEncoder(activatableClassId: string, inputSubtype: string, outputSubtype: string, configuration: Windows.Foundation.Collections.IPropertySet): void;
    }

    enum SoundLevel {
        muted,
        low,
        full
    }

    export class VideoEffects {
        static videoStabilization: string;
    }

}
declare module Windows.Media.MediaProperties {

    export class AudioEncodingProperties implements Windows.Media.MediaProperties.IAudioEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        bitrate: number;
        bitsPerSample: number;
        channelCount: number;
        sampleRate: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    enum AudioEncodingQuality {
        auto,
        high,
        medium,
        low
    }

    export class ContainerEncodingProperties implements Windows.Media.MediaProperties.IContainerEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IAudioEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        bitrate: number;
        bitsPerSample: number;
        channelCount: number;
        sampleRate: number;
    }

    export interface IContainerEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
    }

    export interface IImageEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        height: number;
        width: number;
    }

    export class ImageEncodingProperties implements Windows.Media.MediaProperties.IImageEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        static createJpeg(): Windows.Media.MediaProperties.ImageEncodingProperties;
        static createPng(): Windows.Media.MediaProperties.ImageEncodingProperties;
        static createJpegXR(): Windows.Media.MediaProperties.ImageEncodingProperties;
        height: number;
        width: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IMediaEncodingProfile {
        audio: Windows.Media.MediaProperties.AudioEncodingProperties;
        container: Windows.Media.MediaProperties.ContainerEncodingProperties;
        video: Windows.Media.MediaProperties.VideoEncodingProperties;
    }

    export interface IMediaEncodingProperties {
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    export interface IMediaRatio {
        denominator: number;
        numerator: number;
    }

    export interface IVideoEncodingProperties extends Windows.Media.MediaProperties.IMediaEncodingProperties {
        bitrate: number;
        frameRate: Windows.Media.MediaProperties.MediaRatio;
        height: number;
        pixelAspectRatio: Windows.Media.MediaProperties.MediaRatio;
        width: number;
    }

    export class MediaEncodingProfile implements Windows.Media.MediaProperties.IMediaEncodingProfile {
        constructor();
        static createM4a(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createMp3(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createWma(quality: Windows.Media.MediaProperties.AudioEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createMp4(quality: Windows.Media.MediaProperties.VideoEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createWmv(quality: Windows.Media.MediaProperties.VideoEncodingQuality): Windows.Media.MediaProperties.MediaEncodingProfile;
        static createFromFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
        static createFromStreamAsync(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.Media.MediaProperties.MediaEncodingProfile>;
        audio: Windows.Media.MediaProperties.AudioEncodingProperties;
        container: Windows.Media.MediaProperties.ContainerEncodingProperties;
        video: Windows.Media.MediaProperties.VideoEncodingProperties;
    }

    export class MediaPropertySet implements Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
    }

    export class MediaRatio implements Windows.Media.MediaProperties.IMediaRatio {
        denominator: number;
        numerator: number;
    }

    export class VideoEncodingProperties implements Windows.Media.MediaProperties.IVideoEncodingProperties, Windows.Media.MediaProperties.IMediaEncodingProperties {
        constructor();
        bitrate: number;
        frameRate: Windows.Media.MediaProperties.MediaRatio;
        height: number;
        pixelAspectRatio: Windows.Media.MediaProperties.MediaRatio;
        width: number;
        properties: Windows.Media.MediaProperties.MediaPropertySet;
        subtype: string;
        type: string;
    }

    enum VideoEncodingQuality {
        auto,
        hD1080p,
        hD720p,
        wvga,
        ntsc,
        pal,
        vga,
        qvga
    }

}
declare module Windows.Media.Playlists {

    export interface IPlaylist {
        saveAsync(): Windows.Foundation.IAsyncAction;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption, playlistFormat: Windows.Media.Playlists.PlaylistFormat): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        files: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFile>;
    }

    export class Playlist implements Windows.Media.Playlists.IPlaylist {
        constructor();
        saveAsync(): Windows.Foundation.IAsyncAction;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        saveAsAsync(saveLocation: Windows.Storage.IStorageFolder, desiredName: string, option: Windows.Storage.NameCollisionOption, playlistFormat: Windows.Media.Playlists.PlaylistFormat): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static loadAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Media.Playlists.Playlist>;
        files: Windows.Foundation.Collections.IVector<Windows.Storage.StorageFile>;
    }

    enum PlaylistFormat {
        windowsMedia,
        zune,
        m3u
    }

}
declare module Windows.Media.PlayTo {

    export class CurrentTimeChangeRequestedEventArgs implements Windows.Media.PlayTo.ICurrentTimeChangeRequestedEventArgs {
        time: Windows.Foundation.TimeSpan;
    }

    export interface ICurrentTimeChangeRequestedEventArgs {
        time: Windows.Foundation.TimeSpan;
    }

    export interface IMuteChangeRequestedEventArgs {
        mute: boolean;
    }

    export interface IPlaybackRateChangeRequestedEventArgs {
        rate: number;
    }

    export interface IPlayToConnection {
        add_StateChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_StateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Transferred(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Transferred(token: Windows.Foundation.EventRegistrationToken): void;
        add_Error(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Error(token: Windows.Foundation.EventRegistrationToken): void;
        state: Windows.Media.PlayTo.PlayToConnectionState;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        removeEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        onerror: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>) => void;
        addEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        onstatechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>) => void;
        addEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        removeEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        ontransferred: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>) => void;

    }

    export interface IPlayToConnectionErrorEventArgs {
        code: Windows.Media.PlayTo.PlayToConnectionError;
        message: string;
    }

    export interface IPlayToConnectionStateChangedEventArgs {
        currentState: Windows.Media.PlayTo.PlayToConnectionState;
        previousState: Windows.Media.PlayTo.PlayToConnectionState;
    }

    export interface IPlayToConnectionTransferredEventArgs {
        currentSource: Windows.Media.PlayTo.PlayToSource;
        previousSource: Windows.Media.PlayTo.PlayToSource;
    }

    export interface IPlayToManager {
        add_SourceRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_SourceSelected(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceSelected(token: Windows.Foundation.EventRegistrationToken): void;
        defaultSourceSelection: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        onsourcerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>) => void;
        addEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        removeEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        onsourceselected: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>) => void;

    }

    export interface IPlayToReceiver {
        add_PlayRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_PlayRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_PauseRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_PauseRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_SourceChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_PlaybackRateChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PlaybackRateChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentTimeChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CurrentTimeChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_MuteChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MuteChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_VolumeChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VolumeChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_TimeUpdateRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_TimeUpdateRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_StopRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_StopRequested(token: Windows.Foundation.EventRegistrationToken): void;
        notifyVolumeChange(volume: number, mute: boolean): void;
        notifyRateChange(rate: number): void;
        notifyLoadedMetadata(): void;
        notifyTimeUpdate(currentTime: Windows.Foundation.TimeSpan): void;
        notifyDurationChange(duration: Windows.Foundation.TimeSpan): void;
        notifySeeking(): void;
        notifySeeked(): void;
        notifyPaused(): void;
        notifyPlaying(): void;
        notifyEnded(): void;
        notifyError(): void;
        notifyStopped(): void;
        startAsync(): Windows.Foundation.IAsyncAction;
        stopAsync(): Windows.Foundation.IAsyncAction;
        friendlyName: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        oncurrenttimechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        onmutechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onpauserequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onplayrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        onplaybackratechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        onsourcechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onstoprequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        ontimeupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        onvolumechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>) => void;

    }

    export interface IPlayToSource {
        playNext(): void;
        connection: Windows.Media.PlayTo.PlayToConnection;
        next: Windows.Media.PlayTo.PlayToSource;
    }

    export interface IPlayToSourceDeferral {
        complete(): void;
    }

    export interface IPlayToSourceRequest {
        displayErrorString(errorString: string): void;
        getDeferral(): Windows.Media.PlayTo.PlayToSourceDeferral;
        setSource(value: Windows.Media.PlayTo.PlayToSource): void;
        deadline: Date;
    }

    export interface IPlayToSourceRequestedEventArgs {
        sourceRequest: Windows.Media.PlayTo.PlayToSourceRequest;
    }

    export interface IPlayToSourceSelectedEventArgs {
        friendlyName: string;
        icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
    }

    export interface ISourceChangeRequestedEventArgs {
        album: string;
        author: string;
        date: Windows.Foundation.IReference<Date>;
        description: string;
        genre: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        rating: Windows.Foundation.IReference<number>;
        stream: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export interface IVolumeChangeRequestedEventArgs {
        volume: number;
    }

    export class MuteChangeRequestedEventArgs implements Windows.Media.PlayTo.IMuteChangeRequestedEventArgs {
        mute: boolean;
    }

    export class PlaybackRateChangeRequestedEventArgs implements Windows.Media.PlayTo.IPlaybackRateChangeRequestedEventArgs {
        rate: number;
    }

    export class PlayToConnection implements Windows.Media.PlayTo.IPlayToConnection {
        add_StateChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_StateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Transferred(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Transferred(token: Windows.Foundation.EventRegistrationToken): void;
        add_Error(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Error(token: Windows.Foundation.EventRegistrationToken): void;
        state: Windows.Media.PlayTo.PlayToConnectionState;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        removeEventListener(eventName: "error", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>): void;
        onerror: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionErrorEventArgs>) => void;
        addEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "statechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>): void;
        onstatechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionStateChangedEventArgs>) => void;
        addEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        removeEventListener(eventName: "transferred", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>): void;
        ontransferred: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToConnection,Windows.Media.PlayTo.PlayToConnectionTransferredEventArgs>) => void;

    }

    enum PlayToConnectionError {
        none,
        deviceNotResponding,
        deviceError,
        deviceLocked
    }

    export class PlayToConnectionErrorEventArgs implements Windows.Media.PlayTo.IPlayToConnectionErrorEventArgs {
        code: Windows.Media.PlayTo.PlayToConnectionError;
        message: string;
    }

    enum PlayToConnectionState {
        disconnected,
        connected,
        rendering
    }

    export class PlayToConnectionStateChangedEventArgs implements Windows.Media.PlayTo.IPlayToConnectionStateChangedEventArgs {
        currentState: Windows.Media.PlayTo.PlayToConnectionState;
        previousState: Windows.Media.PlayTo.PlayToConnectionState;
    }

    export class PlayToConnectionTransferredEventArgs implements Windows.Media.PlayTo.IPlayToConnectionTransferredEventArgs {
        currentSource: Windows.Media.PlayTo.PlayToSource;
        previousSource: Windows.Media.PlayTo.PlayToSource;
    }

    export class PlayToManager implements Windows.Media.PlayTo.IPlayToManager {
        add_SourceRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_SourceSelected(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceSelected(token: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.Media.PlayTo.PlayToManager;
        static showPlayToUI(): void;
        defaultSourceSelection: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>): void;
        onsourcerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceRequestedEventArgs>) => void;
        addEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        removeEventListener(eventName: "sourceselected", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>): void;
        onsourceselected: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToManager,Windows.Media.PlayTo.PlayToSourceSelectedEventArgs>) => void;

    }

    export class PlayToReceiver implements Windows.Media.PlayTo.IPlayToReceiver {
        constructor();
        add_PlayRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_PlayRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_PauseRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_PauseRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_SourceChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SourceChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_PlaybackRateChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PlaybackRateChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentTimeChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CurrentTimeChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_MuteChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MuteChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_VolumeChangeRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VolumeChangeRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_TimeUpdateRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_TimeUpdateRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_StopRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): Windows.Foundation.EventRegistrationToken;
        remove_StopRequested(token: Windows.Foundation.EventRegistrationToken): void;
        notifyVolumeChange(volume: number, mute: boolean): void;
        notifyRateChange(rate: number): void;
        notifyLoadedMetadata(): void;
        notifyTimeUpdate(currentTime: Windows.Foundation.TimeSpan): void;
        notifyDurationChange(duration: Windows.Foundation.TimeSpan): void;
        notifySeeking(): void;
        notifySeeked(): void;
        notifyPaused(): void;
        notifyPlaying(): void;
        notifyEnded(): void;
        notifyError(): void;
        notifyStopped(): void;
        startAsync(): Windows.Foundation.IAsyncAction;
        stopAsync(): Windows.Foundation.IAsyncAction;
        friendlyName: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "currenttimechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>): void;
        oncurrenttimechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.CurrentTimeChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "mutechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>): void;
        onmutechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.MuteChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "pauserequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onpauserequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "playrequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onplayrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "playbackratechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>): void;
        onplaybackratechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.PlaybackRateChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "sourcechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>): void;
        onsourcechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.SourceChangeRequestedEventArgs>) => void;
        addEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "stoprequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        onstoprequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        removeEventListener(eventName: "timeupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>): void;
        ontimeupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,any>) => void;
        addEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        removeEventListener(eventName: "volumechangerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>): void;
        onvolumechangerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Media.PlayTo.PlayToReceiver,Windows.Media.PlayTo.VolumeChangeRequestedEventArgs>) => void;

    }

    export class PlayToSource implements Windows.Media.PlayTo.IPlayToSource {
        playNext(): void;
        connection: Windows.Media.PlayTo.PlayToConnection;
        next: Windows.Media.PlayTo.PlayToSource;
    }

    export class PlayToSourceDeferral implements Windows.Media.PlayTo.IPlayToSourceDeferral {
        complete(): void;
    }

    export class PlayToSourceRequest implements Windows.Media.PlayTo.IPlayToSourceRequest {
        displayErrorString(errorString: string): void;
        getDeferral(): Windows.Media.PlayTo.PlayToSourceDeferral;
        setSource(value: Windows.Media.PlayTo.PlayToSource): void;
        deadline: Date;
    }

    export class PlayToSourceRequestedEventArgs implements Windows.Media.PlayTo.IPlayToSourceRequestedEventArgs {
        sourceRequest: Windows.Media.PlayTo.PlayToSourceRequest;
    }

    export class PlayToSourceSelectedEventArgs implements Windows.Media.PlayTo.IPlayToSourceSelectedEventArgs {
        friendlyName: string;
        icon: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        supportsAudio: boolean;
        supportsImage: boolean;
        supportsVideo: boolean;
    }

    export class SourceChangeRequestedEventArgs implements Windows.Media.PlayTo.ISourceChangeRequestedEventArgs {
        album: string;
        author: string;
        date: Windows.Foundation.IReference<Date>;
        description: string;
        genre: string;
        properties: Windows.Foundation.Collections.IMapView<string,any>;
        rating: Windows.Foundation.IReference<number>;
        stream: Windows.Storage.Streams.IRandomAccessStreamWithContentType;
        thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference;
        title: string;
    }

    export class VolumeChangeRequestedEventArgs implements Windows.Media.PlayTo.IVolumeChangeRequestedEventArgs {
        volume: number;
    }

}
declare module Windows.Media.Protection {

    export class ComponentLoadFailedEventArgs implements Windows.Media.Protection.IComponentLoadFailedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        information: Windows.Media.Protection.RevocationAndRenewalInformation;
    }

    export interface ComponentLoadFailedEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

    export class ComponentRenewal {
        static renewSystemComponentsAsync(information: Windows.Media.Protection.RevocationAndRenewalInformation): Windows.Foundation.IAsyncOperationWithProgress<Windows.Media.Protection.RenewalStatus,number>;
    }

    export interface IComponentLoadFailedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        information: Windows.Media.Protection.RevocationAndRenewalInformation;
    }

    export interface IMediaProtectionManager {
        add_ServiceRequested(handler: Windows.Media.Protection.ServiceRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ServiceRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_RebootNeeded(handler: Windows.Media.Protection.RebootNeededEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RebootNeeded(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ComponentLoadFailed(handler: Windows.Media.Protection.ComponentLoadFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ComponentLoadFailed(cookie: Windows.Foundation.EventRegistrationToken): void;
        properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        removeEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        oncomponentloadfailed: (ev: Windows.Media.Protection.ComponentLoadFailedEventHandler) => void;
        addEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        removeEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        onrebootneeded: (ev: Windows.Media.Protection.RebootNeededEventHandler) => void;
        addEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        removeEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        onservicerequested: (ev: Windows.Media.Protection.ServiceRequestedEventHandler) => void;

    }

    export interface IMediaProtectionServiceCompletion {
        complete(success: boolean): void;
    }

    export interface IMediaProtectionServiceRequest {
        protectionSystem: string;
        type: string;
    }

    export interface IRevocationAndRenewalInformation {
        items: Windows.Foundation.Collections.IVector<Windows.Media.Protection.RevocationAndRenewalItem>;
    }

    export interface IRevocationAndRenewalItem {
        headerHash: string;
        name: string;
        publicKeyHash: string;
        reasons: Windows.Media.Protection.RevocationAndRenewalReasons;
        renewalId: string;
    }

    export interface IServiceRequestedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        request: Windows.Media.Protection.IMediaProtectionServiceRequest;
    }

    export class MediaProtectionManager implements Windows.Media.Protection.IMediaProtectionManager {
        constructor();
        add_ServiceRequested(handler: Windows.Media.Protection.ServiceRequestedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ServiceRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_RebootNeeded(handler: Windows.Media.Protection.RebootNeededEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RebootNeeded(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ComponentLoadFailed(handler: Windows.Media.Protection.ComponentLoadFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ComponentLoadFailed(cookie: Windows.Foundation.EventRegistrationToken): void;
        properties: Windows.Foundation.Collections.IPropertySet;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        removeEventListener(eventName: "componentloadfailed", listener: Windows.Media.Protection.ComponentLoadFailedEventHandler): void;
        oncomponentloadfailed: (ev: Windows.Media.Protection.ComponentLoadFailedEventHandler) => void;
        addEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        removeEventListener(eventName: "rebootneeded", listener: Windows.Media.Protection.RebootNeededEventHandler): void;
        onrebootneeded: (ev: Windows.Media.Protection.RebootNeededEventHandler) => void;
        addEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        removeEventListener(eventName: "servicerequested", listener: Windows.Media.Protection.ServiceRequestedEventHandler): void;
        onservicerequested: (ev: Windows.Media.Protection.ServiceRequestedEventHandler) => void;

    }

    export class MediaProtectionServiceCompletion implements Windows.Media.Protection.IMediaProtectionServiceCompletion {
        complete(success: boolean): void;
    }

    export interface RebootNeededEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

    enum RenewalStatus {
        notStarted,
        updatesInProgress,
        userCancelled,
        appComponentsMayNeedUpdating,
        noComponentsFound
    }

    export class RevocationAndRenewalInformation implements Windows.Media.Protection.IRevocationAndRenewalInformation {
        items: Windows.Foundation.Collections.IVector<Windows.Media.Protection.RevocationAndRenewalItem>;
    }

    export class RevocationAndRenewalItem implements Windows.Media.Protection.IRevocationAndRenewalItem {
        headerHash: string;
        name: string;
        publicKeyHash: string;
        reasons: Windows.Media.Protection.RevocationAndRenewalReasons;
        renewalId: string;
    }

    enum RevocationAndRenewalReasons {
        userModeComponentLoad,
        kernelModeComponentLoad,
        appComponent,
        globalRevocationListLoadFailed,
        invalidGlobalRevocationListSignature,
        globalRevocationListAbsent,
        componentRevoked,
        invalidComponentCertificateExtendedKeyUse,
        componentCertificateRevoked,
        invalidComponentCertificateRoot,
        componentHighSecurityCertificateRevoked,
        componentLowSecurityCertificateRevoked,
        bootDriverVerificationFailed,
        componentSignedWithTestCertificate,
        encryptionFailure
    }

    export class ServiceRequestedEventArgs implements Windows.Media.Protection.IServiceRequestedEventArgs {
        completion: Windows.Media.Protection.MediaProtectionServiceCompletion;
        request: Windows.Media.Protection.IMediaProtectionServiceRequest;
    }

    export interface ServiceRequestedEventHandler {
        target: Windows.Media.Protection.MediaProtectionManager;
        detail: any[];
        type: string;
    }

}
declare module Windows.Media.Transcoding {

    export interface IMediaTranscoder {
        addAudioEffect(activatableClassId: string): void;
        addAudioEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(activatableClassId: string): void;
        addVideoEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        clearEffects(): void;
        prepareFileTranscodeAsync(source: Windows.Storage.IStorageFile, destination: Windows.Storage.IStorageFile, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        prepareStreamTranscodeAsync(source: Windows.Storage.Streams.IRandomAccessStream, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        alwaysReencode: boolean;
        hardwareAccelerationEnabled: boolean;
        trimStartTime: Windows.Foundation.TimeSpan;
        trimStopTime: Windows.Foundation.TimeSpan;
    }

    export interface IPrepareTranscodeResult {
        transcodeAsync(): Windows.Foundation.IAsyncActionWithProgress<number>;
        canTranscode: boolean;
        failureReason: Windows.Media.Transcoding.TranscodeFailureReason;
    }

    export class MediaTranscoder implements Windows.Media.Transcoding.IMediaTranscoder {
        constructor();
        addAudioEffect(activatableClassId: string): void;
        addAudioEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(activatableClassId: string): void;
        addVideoEffect(activatableClassId: string, effectRequired: boolean, configuration: Windows.Foundation.Collections.IPropertySet): void;
        clearEffects(): void;
        prepareFileTranscodeAsync(source: Windows.Storage.IStorageFile, destination: Windows.Storage.IStorageFile, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        prepareStreamTranscodeAsync(source: Windows.Storage.Streams.IRandomAccessStream, destination: Windows.Storage.Streams.IRandomAccessStream, profile: Windows.Media.MediaProperties.MediaEncodingProfile): Windows.Foundation.IAsyncOperation<Windows.Media.Transcoding.PrepareTranscodeResult>;
        alwaysReencode: boolean;
        hardwareAccelerationEnabled: boolean;
        trimStartTime: Windows.Foundation.TimeSpan;
        trimStopTime: Windows.Foundation.TimeSpan;
    }

    export class PrepareTranscodeResult implements Windows.Media.Transcoding.IPrepareTranscodeResult {
        transcodeAsync(): Windows.Foundation.IAsyncActionWithProgress<number>;
        canTranscode: boolean;
        failureReason: Windows.Media.Transcoding.TranscodeFailureReason;
    }

    enum TranscodeFailureReason {
        none,
        unknown,
        invalidProfile,
        codecNotFound
    }

}
declare module Windows.Networking.BackgroundTransfer {

    export class BackgroundDownloader implements Windows.Networking.BackgroundTransfer.IBackgroundDownloader, Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        constructor();
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownloadAsync(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.DownloadOperation>;
        setRequestHeader(headerName: string, headerValue: string): void;
        static getCurrentDownloadsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.DownloadOperation>>;
        static getCurrentDownloadsAsync(group: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.DownloadOperation>>;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export class BackgroundDownloadProgress {
        bytesReceived: number;
        totalBytesToReceive: number;
        status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus;
        hasResponseChanged: boolean;
        hasRestarted: boolean;
    }

    export class BackgroundTransferContentPart implements Windows.Networking.BackgroundTransfer.IBackgroundTransferContentPart {
        constructor(name: string);
        constructor(name: string, fileName: string);
        constructor();
        setHeader(headerName: string, headerValue: string): void;
        setText(value: string): void;
        setFile(value: Windows.Storage.IStorageFile): void;
    }

    enum BackgroundTransferCostPolicy {
        default,
        unrestrictedOnly,
        always
    }

    export class BackgroundTransferError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    enum BackgroundTransferStatus {
        idle,
        running,
        pausedByApplication,
        pausedCostedNetwork,
        pausedNoNetwork,
        completed,
        canceled,
        error
    }

    export class BackgroundUploader implements Windows.Networking.BackgroundTransfer.IBackgroundUploader, Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        constructor();
        createUpload(uri: Windows.Foundation.Uri, sourceFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.UploadOperation;
        createUploadFromStreamAsync(uri: Windows.Foundation.Uri, sourceStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string, boundary: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        setRequestHeader(headerName: string, headerValue: string): void;
        static getCurrentUploadsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.UploadOperation>>;
        static getCurrentUploadsAsync(group: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.BackgroundTransfer.UploadOperation>>;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export class BackgroundUploadProgress {
        bytesReceived: number;
        bytesSent: number;
        totalBytesToReceive: number;
        totalBytesToSend: number;
        status: Windows.Networking.BackgroundTransfer.BackgroundTransferStatus;
        hasResponseChanged: boolean;
        hasRestarted: boolean;
    }

    export class DownloadOperation implements Windows.Networking.BackgroundTransfer.IDownloadOperation, Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        pause(): void;
        resume(): void;
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        progress: Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress;
        resultFile: Windows.Storage.IStorageFile;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

    export interface IBackgroundDownloader extends Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownload(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.DownloadOperation;
        createDownloadAsync(uri: Windows.Foundation.Uri, resultFile: Windows.Storage.IStorageFile, requestBodyStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.DownloadOperation>;
    }

    export interface IBackgroundTransferBase {
        setRequestHeader(headerName: string, headerValue: string): void;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        method: string;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
    }

    export interface IBackgroundTransferContentPart {
        setHeader(headerName: string, headerValue: string): void;
        setText(value: string): void;
        setFile(value: Windows.Storage.IStorageFile): void;
    }

    export interface IBackgroundTransferContentPartFactory {
        createWithName(name: string): Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart;
        createWithNameAndFileName(name: string, fileName: string): Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart;
    }

    export interface IBackgroundTransferOperation {
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

    export interface IBackgroundUploader extends Windows.Networking.BackgroundTransfer.IBackgroundTransferBase {
        createUpload(uri: Windows.Foundation.Uri, sourceFile: Windows.Storage.IStorageFile): Windows.Networking.BackgroundTransfer.UploadOperation;
        createUploadFromStreamAsync(uri: Windows.Foundation.Uri, sourceStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
        createUploadAsync(uri: Windows.Foundation.Uri, parts: Windows.Foundation.Collections.IIterable<Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart>, subType: string, boundary: string): Windows.Foundation.IAsyncOperation<Windows.Networking.BackgroundTransfer.UploadOperation>;
    }

    export interface IDownloadOperation extends Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.DownloadOperation,Windows.Networking.BackgroundTransfer.DownloadOperation>;
        pause(): void;
        resume(): void;
        progress: Windows.Networking.BackgroundTransfer.BackgroundDownloadProgress;
        resultFile: Windows.Storage.IStorageFile;
    }

    export interface IResponseInformation {
        actualUri: Windows.Foundation.Uri;
        headers: Windows.Foundation.Collections.IMapView<string,string>;
        isResumable: boolean;
        statusCode: number;
    }

    export interface IUploadOperation extends Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        progress: Windows.Networking.BackgroundTransfer.BackgroundUploadProgress;
        sourceFile: Windows.Storage.IStorageFile;
    }

    export class ResponseInformation implements Windows.Networking.BackgroundTransfer.IResponseInformation {
        actualUri: Windows.Foundation.Uri;
        headers: Windows.Foundation.Collections.IMapView<string,string>;
        isResumable: boolean;
        statusCode: number;
    }

    export class UploadOperation implements Windows.Networking.BackgroundTransfer.IUploadOperation, Windows.Networking.BackgroundTransfer.IBackgroundTransferOperation {
        startAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        attachAsync(): Windows.Foundation.IAsyncOperationWithProgress<Windows.Networking.BackgroundTransfer.UploadOperation,Windows.Networking.BackgroundTransfer.UploadOperation>;
        getResultStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getResponseInformation(): Windows.Networking.BackgroundTransfer.ResponseInformation;
        progress: Windows.Networking.BackgroundTransfer.BackgroundUploadProgress;
        sourceFile: Windows.Storage.IStorageFile;
        costPolicy: Windows.Networking.BackgroundTransfer.BackgroundTransferCostPolicy;
        group: string;
        guid: string;
        method: string;
        requestedUri: Windows.Foundation.Uri;
    }

}
declare module Windows.Networking.Connectivity {

    export class ConnectionCost implements Windows.Networking.Connectivity.IConnectionCost {
        approachingDataLimit: boolean;
        networkCostType: Windows.Networking.Connectivity.NetworkCostType;
        overDataLimit: boolean;
        roaming: boolean;
    }

    export class ConnectionProfile implements Windows.Networking.Connectivity.IConnectionProfile {
        getNetworkConnectivityLevel(): Windows.Networking.Connectivity.NetworkConnectivityLevel;
        getNetworkNames(): Windows.Foundation.Collections.IVectorView<string>;
        getConnectionCost(): Windows.Networking.Connectivity.ConnectionCost;
        getDataPlanStatus(): Windows.Networking.Connectivity.DataPlanStatus;
        getLocalUsage(StartTime: Date, EndTime: Date): Windows.Networking.Connectivity.DataUsage;
        getLocalUsage(StartTime: Date, EndTime: Date, States: Windows.Networking.Connectivity.RoamingStates): Windows.Networking.Connectivity.DataUsage;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkSecuritySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
        profileName: string;
    }

    export class DataPlanStatus implements Windows.Networking.Connectivity.IDataPlanStatus {
        dataLimitInMegabytes: Windows.Foundation.IReference<number>;
        dataPlanUsage: Windows.Networking.Connectivity.DataPlanUsage;
        inboundBitsPerSecond: Windows.Foundation.IReference<number>;
        maxTransferSizeInMegabytes: Windows.Foundation.IReference<number>;
        nextBillingCycle: Windows.Foundation.IReference<Date>;
        outboundBitsPerSecond: Windows.Foundation.IReference<number>;
    }

    export class DataPlanUsage implements Windows.Networking.Connectivity.IDataPlanUsage {
        lastSyncTime: Date;
        megabytesUsed: number;
    }

    export class DataUsage implements Windows.Networking.Connectivity.IDataUsage {
        bytesReceived: number;
        bytesSent: number;
    }

    export interface IConnectionCost {
        approachingDataLimit: boolean;
        networkCostType: Windows.Networking.Connectivity.NetworkCostType;
        overDataLimit: boolean;
        roaming: boolean;
    }

    export interface IConnectionProfile {
        getNetworkConnectivityLevel(): Windows.Networking.Connectivity.NetworkConnectivityLevel;
        getNetworkNames(): Windows.Foundation.Collections.IVectorView<string>;
        getConnectionCost(): Windows.Networking.Connectivity.ConnectionCost;
        getDataPlanStatus(): Windows.Networking.Connectivity.DataPlanStatus;
        getLocalUsage(StartTime: Date, EndTime: Date): Windows.Networking.Connectivity.DataUsage;
        getLocalUsage(StartTime: Date, EndTime: Date, States: Windows.Networking.Connectivity.RoamingStates): Windows.Networking.Connectivity.DataUsage;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkSecuritySettings: Windows.Networking.Connectivity.NetworkSecuritySettings;
        profileName: string;
    }

    export interface IDataPlanStatus {
        dataLimitInMegabytes: Windows.Foundation.IReference<number>;
        dataPlanUsage: Windows.Networking.Connectivity.DataPlanUsage;
        inboundBitsPerSecond: Windows.Foundation.IReference<number>;
        maxTransferSizeInMegabytes: Windows.Foundation.IReference<number>;
        nextBillingCycle: Windows.Foundation.IReference<Date>;
        outboundBitsPerSecond: Windows.Foundation.IReference<number>;
    }

    export interface IDataPlanUsage {
        lastSyncTime: Date;
        megabytesUsed: number;
    }

    export interface IDataUsage {
        bytesReceived: number;
        bytesSent: number;
    }

    export interface IIPInformation {
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        prefixLength: Windows.Foundation.IReference<number>;
    }

    export interface ILanIdentifier {
        infrastructureId: Windows.Networking.Connectivity.LanIdentifierData;
        networkAdapterId: string;
        portId: Windows.Networking.Connectivity.LanIdentifierData;
    }

    export interface ILanIdentifierData {
        type: number;
        value: Windows.Foundation.Collections.IVectorView<number>;
    }

    export interface INetworkAdapter {
        getConnectedProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile>;
        ianaInterfaceType: number;
        inboundMaxBitsPerSecond: number;
        networkAdapterId: string;
        networkItem: Windows.Networking.Connectivity.NetworkItem;
        outboundMaxBitsPerSecond: number;
    }

    export interface INetworkItem {
        getNetworkTypes(): Windows.Networking.Connectivity.NetworkTypes;
        networkId: string;
    }

    export interface INetworkSecuritySettings {
        networkAuthenticationType: Windows.Networking.Connectivity.NetworkAuthenticationType;
        networkEncryptionType: Windows.Networking.Connectivity.NetworkEncryptionType;
    }

    export class IPInformation implements Windows.Networking.Connectivity.IIPInformation {
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        prefixLength: Windows.Foundation.IReference<number>;
    }

    export interface IProxyConfiguration {
        canConnectDirectly: boolean;
        proxyUris: Windows.Foundation.Collections.IVectorView<Windows.Foundation.Uri>;
    }

    export class LanIdentifier implements Windows.Networking.Connectivity.ILanIdentifier {
        infrastructureId: Windows.Networking.Connectivity.LanIdentifierData;
        networkAdapterId: string;
        portId: Windows.Networking.Connectivity.LanIdentifierData;
    }

    export class LanIdentifierData implements Windows.Networking.Connectivity.ILanIdentifierData {
        type: number;
        value: Windows.Foundation.Collections.IVectorView<number>;
    }

    export class NetworkAdapter implements Windows.Networking.Connectivity.INetworkAdapter {
        getConnectedProfileAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile>;
        ianaInterfaceType: number;
        inboundMaxBitsPerSecond: number;
        networkAdapterId: string;
        networkItem: Windows.Networking.Connectivity.NetworkItem;
        outboundMaxBitsPerSecond: number;
    }

    enum NetworkAuthenticationType {
        none,
        unknown,
        open80211,
        sharedKey80211,
        wpa,
        wpaPsk,
        wpaNone,
        rsna,
        rsnaPsk,
        ihv
    }

    enum NetworkConnectivityLevel {
        none,
        localAccess,
        constrainedInternetAccess,
        internetAccess
    }

    enum NetworkCostType {
        unknown,
        unrestricted,
        fixed,
        variable
    }

    enum NetworkEncryptionType {
        none,
        unknown,
        wep,
        wep40,
        wep104,
        tkip,
        ccmp,
        wpaUseGroup,
        rsnUseGroup,
        ihv
    }

    export class NetworkInformation {
        static getConnectionProfiles(): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile>;
        static getInternetConnectionProfile(): Windows.Networking.Connectivity.ConnectionProfile;
        static getLanIdentifiers(): Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.LanIdentifier>;
        static getHostNames(): Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName>;
        static getProxyConfigurationAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ProxyConfiguration>;
        static getSortedEndpointPairs(destinationList: Windows.Foundation.Collections.IIterable<Windows.Networking.EndpointPair>, sortOptions: Windows.Networking.HostNameSortOptions): Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>;
        static add_NetworkStatusChanged(networkStatusHandler: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_NetworkStatusChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler): void;
        removeEventListener(eventName: "networkstatuschanged", listener: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler): void;
        onnetworkstatuschanged: (ev: Windows.Networking.Connectivity.NetworkStatusChangedEventHandler) => void;

    }

    export class NetworkItem implements Windows.Networking.Connectivity.INetworkItem {
        getNetworkTypes(): Windows.Networking.Connectivity.NetworkTypes;
        networkId: string;
    }

    export class NetworkSecuritySettings implements Windows.Networking.Connectivity.INetworkSecuritySettings {
        networkAuthenticationType: Windows.Networking.Connectivity.NetworkAuthenticationType;
        networkEncryptionType: Windows.Networking.Connectivity.NetworkEncryptionType;
    }

    export interface NetworkStatusChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum NetworkTypes {
        none,
        internet,
        privateNetwork
    }

    export class ProxyConfiguration implements Windows.Networking.Connectivity.IProxyConfiguration {
        canConnectDirectly: boolean;
        proxyUris: Windows.Foundation.Collections.IVectorView<Windows.Foundation.Uri>;
    }

    enum RoamingStates {
        none,
        notRoaming,
        roaming
    }

}
declare module Windows.Networking {

    export class EndpointPair implements Windows.Networking.IEndpointPair {
        constructor(localHostName: Windows.Networking.HostName, localServiceName: string, remoteHostName: Windows.Networking.HostName, remoteServiceName: string);
        localHostName: Windows.Networking.HostName;
        localServiceName: string;
        remoteHostName: Windows.Networking.HostName;
        remoteServiceName: string;
    }

    export class HostName implements Windows.Networking.IHostName {
        constructor(hostName: string);
        isEqual(hostName: Windows.Networking.HostName): boolean;
        static compare(value1: string, value2: string): number;
        canonicalName: string;
        displayName: string;
        iPInformation: Windows.Networking.Connectivity.IPInformation;
        rawName: string;
        type: Windows.Networking.HostNameType;
    }

    enum HostNameSortOptions {
        none,
        optimizeForLongConnections
    }

    enum HostNameType {
        domainName,
        ipv4,
        ipv6,
        bluetooth
    }

    export interface IEndpointPair {
        localHostName: Windows.Networking.HostName;
        localServiceName: string;
        remoteHostName: Windows.Networking.HostName;
        remoteServiceName: string;
    }

    export interface IHostName {
        isEqual(hostName: Windows.Networking.HostName): boolean;
        canonicalName: string;
        displayName: string;
        iPInformation: Windows.Networking.Connectivity.IPInformation;
        rawName: string;
        type: Windows.Networking.HostNameType;
    }

}
declare module Windows.Networking.NetworkOperators {

    enum DataClasses {
        none,
        gprs,
        edge,
        umts,
        hsdpa,
        hsupa,
        lteAdvanced,
        cdma1xRtt,
        cdma1xEvdo,
        cdma1xEvdoRevA,
        cdma1xEvdv,
        cdma3xRtt,
        cdma1xEvdoRevB,
        cdmaUmb,
        custom
    }

    export class HotspotAuthenticationContext implements Windows.Networking.NetworkOperators.IHotspotAuthenticationContext {
        issueCredentials(userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean): void;
        abortAuthentication(markAsManual: boolean): void;
        skipAuthentication(): void;
        triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
        static tryGetAuthenticationContext(evenToken: string): HotspotAuthenticationContext_tryGetAuthenticationContext_OUT;
        authenticationUrl: Windows.Foundation.Uri;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        redirectMessageUrl: Windows.Foundation.Uri;
        redirectMessageXml: Windows.Data.Xml.Dom.XmlDocument;
        wirelessNetworkId: any;
    }

    interface HotspotAuthenticationContext_tryGetAuthenticationContext_OUT {
        __returnValue: boolean;
        context: Windows.Networking.NetworkOperators.HotspotAuthenticationContext;
    }

    export class HotspotAuthenticationEventDetails implements Windows.Networking.NetworkOperators.IHotspotAuthenticationEventDetails {
        eventToken: string;
    }

    export interface IHotspotAuthenticationContext {
        issueCredentials(userName: string, password: string, extraParameters: string, markAsManualConnectOnFailure: boolean): void;
        abortAuthentication(markAsManual: boolean): void;
        skipAuthentication(): void;
        triggerAttentionRequired(packageRelativeApplicationId: string, applicationParameters: string): void;
        authenticationUrl: Windows.Foundation.Uri;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        redirectMessageUrl: Windows.Foundation.Uri;
        redirectMessageXml: Windows.Data.Xml.Dom.XmlDocument;
        wirelessNetworkId: any;
    }

    export interface IHotspotAuthenticationEventDetails {
        eventToken: string;
    }

    export interface IMobileBroadbandAccount {
        currentDeviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
        currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
        networkAccountId: string;
        serviceProviderGuid: string;
        serviceProviderName: string;
    }

    export interface IMobileBroadbandAccountEventArgs {
        networkAccountId: string;
    }

    export interface IMobileBroadbandAccountUpdatedEventArgs {
        hasDeviceInformationChanged: boolean;
        hasNetworkChanged: boolean;
        networkAccountId: string;
    }

    export interface IMobileBroadbandAccountWatcher {
        add_AccountAdded(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountAdded(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AccountUpdated(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountUpdated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AccountRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountRemoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(cookie: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        removeEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        onaccountupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;

    }

    export interface IMobileBroadbandDeviceInformation {
        cellularClass: Windows.Devices.Sms.CellularClass;
        currentRadioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState;
        customDataClass: string;
        dataClasses: Windows.Networking.NetworkOperators.DataClasses;
        deviceId: string;
        deviceType: Windows.Networking.NetworkOperators.MobileBroadbandDeviceType;
        firmwareInformation: string;
        manufacturer: string;
        mobileEquipmentId: string;
        model: string;
        networkDeviceStatus: Windows.Networking.NetworkOperators.NetworkDeviceStatus;
        simIccId: string;
        subscriberId: string;
        telephoneNumbers: Windows.Foundation.Collections.IVectorView<string>;
    }

    export interface IMobileBroadbandNetwork {
        showConnectionUI(): void;
        accessPointName: string;
        activationNetworkError: number;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkRegistrationState: Windows.Networking.NetworkOperators.NetworkRegistrationState;
        packetAttachNetworkError: number;
        registeredDataClass: Windows.Networking.NetworkOperators.DataClasses;
        registeredProviderId: string;
        registeredProviderName: string;
        registrationNetworkError: number;
    }

    export interface INetworkOperatorNotificationEventDetails {
        encodingType: number;
        message: string;
        networkAccountId: string;
        notificationType: Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType;
        ruleId: string;
        smsMessage: Windows.Devices.Sms.ISmsMessage;
    }

    export interface IProvisionedProfile {
        updateCost(value: Windows.Networking.Connectivity.NetworkCostType): void;
        updateUsage(value: Windows.Networking.NetworkOperators.ProfileUsage): void;
    }

    export interface IProvisionFromXmlDocumentResults {
        allElementsProvisioned: boolean;
        provisionResultsXml: string;
    }

    export interface IProvisioningAgent {
        provisionFromXmlDocumentAsync(provisioningXmlDocument: string): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>;
        getProvisionedProfile(mediaType: Windows.Networking.NetworkOperators.ProfileMediaType, profileName: string): Windows.Networking.NetworkOperators.ProvisionedProfile;
    }

    export interface IUssdMessage {
        getPayload(): any;
        setPayload(value: any): void;
        dataCodingScheme: number;
        payloadAsText: string;
    }

    export interface IUssdReply {
        message: Windows.Networking.NetworkOperators.UssdMessage;
        resultCode: Windows.Networking.NetworkOperators.UssdResultCode;
    }

    export interface IUssdSession {
        sendMessageAndGetReplyAsync(message: Windows.Networking.NetworkOperators.UssdMessage): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.UssdReply>;
        close(): void;
    }

    export class MobileBroadbandAccount implements Windows.Networking.NetworkOperators.IMobileBroadbandAccount {
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.MobileBroadbandAccount;
        currentDeviceInformation: Windows.Networking.NetworkOperators.MobileBroadbandDeviceInformation;
        currentNetwork: Windows.Networking.NetworkOperators.MobileBroadbandNetwork;
        networkAccountId: string;
        serviceProviderGuid: string;
        serviceProviderName: string;
        static availableNetworkAccountIds: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class MobileBroadbandAccountEventArgs implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountEventArgs {
        networkAccountId: string;
    }

    export class MobileBroadbandAccountUpdatedEventArgs implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountUpdatedEventArgs {
        hasDeviceInformationChanged: boolean;
        hasNetworkChanged: boolean;
        networkAccountId: string;
    }

    export class MobileBroadbandAccountWatcher implements Windows.Networking.NetworkOperators.IMobileBroadbandAccountWatcher {
        constructor();
        add_AccountAdded(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountAdded(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AccountUpdated(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountUpdated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AccountRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AccountRemoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_EnumerationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_EnumerationCompleted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Stopped(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): Windows.Foundation.EventRegistrationToken;
        remove_Stopped(cookie: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        status: Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountadded", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountadded: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        removeEventListener(eventName: "accountremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>): void;
        onaccountremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountEventArgs>) => void;
        addEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        removeEventListener(eventName: "accountupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>): void;
        onaccountupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,Windows.Networking.NetworkOperators.MobileBroadbandAccountUpdatedEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.NetworkOperators.MobileBroadbandAccountWatcher,any>) => void;

    }

    enum MobileBroadbandAccountWatcherStatus {
        created,
        started,
        enumerationCompleted,
        stopped,
        aborted
    }

    export class MobileBroadbandDeviceInformation implements Windows.Networking.NetworkOperators.IMobileBroadbandDeviceInformation {
        cellularClass: Windows.Devices.Sms.CellularClass;
        currentRadioState: Windows.Networking.NetworkOperators.MobileBroadbandRadioState;
        customDataClass: string;
        dataClasses: Windows.Networking.NetworkOperators.DataClasses;
        deviceId: string;
        deviceType: Windows.Networking.NetworkOperators.MobileBroadbandDeviceType;
        firmwareInformation: string;
        manufacturer: string;
        mobileEquipmentId: string;
        model: string;
        networkDeviceStatus: Windows.Networking.NetworkOperators.NetworkDeviceStatus;
        simIccId: string;
        subscriberId: string;
        telephoneNumbers: Windows.Foundation.Collections.IVectorView<string>;
    }

    enum MobileBroadbandDeviceType {
        unknown,
        embedded,
        removable,
        remote
    }

    export class MobileBroadbandNetwork implements Windows.Networking.NetworkOperators.IMobileBroadbandNetwork {
        showConnectionUI(): void;
        accessPointName: string;
        activationNetworkError: number;
        networkAdapter: Windows.Networking.Connectivity.NetworkAdapter;
        networkRegistrationState: Windows.Networking.NetworkOperators.NetworkRegistrationState;
        packetAttachNetworkError: number;
        registeredDataClass: Windows.Networking.NetworkOperators.DataClasses;
        registeredProviderId: string;
        registeredProviderName: string;
        registrationNetworkError: number;
    }

    enum MobileBroadbandRadioState {
        off,
        on
    }

    enum NetworkDeviceStatus {
        deviceNotReady,
        deviceReady,
        simNotInserted,
        badSim,
        deviceHardwareFailure,
        accountNotActivated,
        deviceLocked,
        deviceBlocked
    }

    enum NetworkOperatorEventMessageType {
        gsm,
        cdma,
        ussd,
        dataPlanThresholdReached,
        dataPlanReset,
        dataPlanDeleted,
        profileConnected,
        profileDisconnected,
        registeredRoaming,
        registeredHome
    }

    export class NetworkOperatorNotificationEventDetails implements Windows.Networking.NetworkOperators.INetworkOperatorNotificationEventDetails {
        encodingType: number;
        message: string;
        networkAccountId: string;
        notificationType: Windows.Networking.NetworkOperators.NetworkOperatorEventMessageType;
        ruleId: string;
        smsMessage: Windows.Devices.Sms.ISmsMessage;
    }

    enum NetworkRegistrationState {
        none,
        deregistered,
        searching,
        home,
        roaming,
        partner,
        denied
    }

    enum ProfileMediaType {
        wlan,
        wwan
    }

    export class ProfileUsage {
        usageInMegabytes: number;
        lastSyncTime: Date;
    }

    export class ProvisionedProfile implements Windows.Networking.NetworkOperators.IProvisionedProfile {
        updateCost(value: Windows.Networking.Connectivity.NetworkCostType): void;
        updateUsage(value: Windows.Networking.NetworkOperators.ProfileUsage): void;
    }

    export class ProvisionFromXmlDocumentResults implements Windows.Networking.NetworkOperators.IProvisionFromXmlDocumentResults {
        allElementsProvisioned: boolean;
        provisionResultsXml: string;
    }

    export class ProvisioningAgent implements Windows.Networking.NetworkOperators.IProvisioningAgent {
        constructor();
        provisionFromXmlDocumentAsync(provisioningXmlDocument: string): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.ProvisionFromXmlDocumentResults>;
        getProvisionedProfile(mediaType: Windows.Networking.NetworkOperators.ProfileMediaType, profileName: string): Windows.Networking.NetworkOperators.ProvisionedProfile;
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.ProvisioningAgent;
    }

    export class UssdMessage implements Windows.Networking.NetworkOperators.IUssdMessage {
        constructor(messageText: string);
        getPayload(): any;
        setPayload(value: any): void;
        dataCodingScheme: number;
        payloadAsText: string;
    }

    export class UssdReply implements Windows.Networking.NetworkOperators.IUssdReply {
        message: Windows.Networking.NetworkOperators.UssdMessage;
        resultCode: Windows.Networking.NetworkOperators.UssdResultCode;
    }

    enum UssdResultCode {
        noActionRequired,
        actionRequired,
        terminated,
        otherLocalClient,
        operationNotSupported,
        networkTimeout
    }

    export class UssdSession implements Windows.Networking.NetworkOperators.IUssdSession {
        sendMessageAndGetReplyAsync(message: Windows.Networking.NetworkOperators.UssdMessage): Windows.Foundation.IAsyncOperation<Windows.Networking.NetworkOperators.UssdReply>;
        close(): void;
        static createFromNetworkAccountId(networkAccountId: string): Windows.Networking.NetworkOperators.UssdSession;
        static createFromNetworkInterfaceId(networkInterfaceId: string): Windows.Networking.NetworkOperators.UssdSession;
    }

}
declare module Windows.Networking.Proximity {

    export class ConnectionRequestedEventArgs implements Windows.Networking.Proximity.IConnectionRequestedEventArgs {
        peerInformation: Windows.Networking.Proximity.PeerInformation;
    }

    export interface DeviceArrivedEventHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface DeviceDepartedEventHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface IConnectionRequestedEventArgs {
        peerInformation: Windows.Networking.Proximity.PeerInformation;
    }

    export interface IPeerInformation {
        displayName: string;
    }

    export interface IProximityDevice {
        subscribeForMessage(messageType: string, messageReceivedHandler: Windows.Networking.Proximity.MessageReceivedHandler): number;
        publishMessage(messageType: string, message: string): number;
        publishMessage(messageType: string, message: string, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishUriMessage(message: Windows.Foundation.Uri): number;
        publishUriMessage(message: Windows.Foundation.Uri, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        stopSubscribingForMessage(subscriptionId: number): void;
        stopPublishingMessage(messageId: number): void;
        add_DeviceArrived(arrivedHandler: Windows.Networking.Proximity.DeviceArrivedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DeviceArrived(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_DeviceDeparted(departedHandler: Windows.Networking.Proximity.DeviceDepartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DeviceDeparted(cookie: Windows.Foundation.EventRegistrationToken): void;
        bitsPerSecond: number;
        deviceId: string;
        maxMessageBytes: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        removeEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        ondevicearrived: (ev: Windows.Networking.Proximity.DeviceArrivedEventHandler) => void;
        addEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        removeEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        ondevicedeparted: (ev: Windows.Networking.Proximity.DeviceDepartedEventHandler) => void;

    }

    export interface IProximityMessage {
        data: Windows.Storage.Streams.IBuffer;
        dataAsString: string;
        messageType: string;
        subscriptionId: number;
    }

    export interface ITriggeredConnectionStateChangedEventArgs {
        id: number;
        socket: Windows.Networking.Sockets.StreamSocket;
        state: Windows.Networking.Proximity.TriggeredConnectState;
    }

    export interface MessageReceivedHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    export interface MessageTransmittedHandler {
        target: Windows.Networking.Proximity.ProximityDevice;
        detail: any[];
        type: string;
    }

    enum PeerDiscoveryTypes {
        none,
        browse,
        triggered
    }

    export class PeerFinder {
        static start(): void;
        static start(peerMessage: string): void;
        static stop(): void;
        static add_TriggeredConnectionStateChanged(handler: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        static remove_TriggeredConnectionStateChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        static add_ConnectionRequested(handler: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        static remove_ConnectionRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        static findAllPeersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.Proximity.PeerInformation>>;
        static connectAsync(peerInformation: Windows.Networking.Proximity.PeerInformation): Windows.Foundation.IAsyncOperation<Windows.Networking.Sockets.StreamSocket>;
        static allowBluetooth: boolean;
        static allowInfrastructure: boolean;
        static allowWiFiDirect: boolean;
        static alternateIdentities: Windows.Foundation.Collections.IMap<string,string>;
        static displayName: string;
        static supportedDiscoveryTypes: Windows.Networking.Proximity.PeerDiscoveryTypes;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>): void;
        removeEventListener(eventName: "connectionrequested", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>): void;
        onconnectionrequested: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.ConnectionRequestedEventArgs>) => void;
        addEventListener(eventName: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>): void;
        removeEventListener(eventName: "triggeredconnectionstatechanged", listener: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>): void;
        ontriggeredconnectionstatechanged: (ev: Windows.Foundation.TypedEventHandler<any,Windows.Networking.Proximity.TriggeredConnectionStateChangedEventArgs>) => void;

    }

    export class PeerInformation implements Windows.Networking.Proximity.IPeerInformation {
        displayName: string;
    }

    export class ProximityDevice implements Windows.Networking.Proximity.IProximityDevice {
        subscribeForMessage(messageType: string, messageReceivedHandler: Windows.Networking.Proximity.MessageReceivedHandler): number;
        publishMessage(messageType: string, message: string): number;
        publishMessage(messageType: string, message: string, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer): number;
        publishBinaryMessage(messageType: string, message: Windows.Storage.Streams.IBuffer, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        publishUriMessage(message: Windows.Foundation.Uri): number;
        publishUriMessage(message: Windows.Foundation.Uri, messageTransmittedHandler: Windows.Networking.Proximity.MessageTransmittedHandler): number;
        stopSubscribingForMessage(subscriptionId: number): void;
        stopPublishingMessage(messageId: number): void;
        add_DeviceArrived(arrivedHandler: Windows.Networking.Proximity.DeviceArrivedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DeviceArrived(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_DeviceDeparted(departedHandler: Windows.Networking.Proximity.DeviceDepartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DeviceDeparted(cookie: Windows.Foundation.EventRegistrationToken): void;
        static getDeviceSelector(): string;
        static getDefault(): Windows.Networking.Proximity.ProximityDevice;
        static fromId(deviceInterfaceId: string): Windows.Networking.Proximity.ProximityDevice;
        bitsPerSecond: number;
        deviceId: string;
        maxMessageBytes: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        removeEventListener(eventName: "devicearrived", listener: Windows.Networking.Proximity.DeviceArrivedEventHandler): void;
        ondevicearrived: (ev: Windows.Networking.Proximity.DeviceArrivedEventHandler) => void;
        addEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        removeEventListener(eventName: "devicedeparted", listener: Windows.Networking.Proximity.DeviceDepartedEventHandler): void;
        ondevicedeparted: (ev: Windows.Networking.Proximity.DeviceDepartedEventHandler) => void;

    }

    export class ProximityMessage implements Windows.Networking.Proximity.IProximityMessage {
        data: Windows.Storage.Streams.IBuffer;
        dataAsString: string;
        messageType: string;
        subscriptionId: number;
    }

    export class TriggeredConnectionStateChangedEventArgs implements Windows.Networking.Proximity.ITriggeredConnectionStateChangedEventArgs {
        id: number;
        socket: Windows.Networking.Sockets.StreamSocket;
        state: Windows.Networking.Proximity.TriggeredConnectState;
    }

    enum TriggeredConnectState {
        peerFound,
        listening,
        connecting,
        completed,
        canceled,
        failed
    }

}
declare module Windows.Networking.PushNotifications {

    export interface IPushNotificationChannel {
        close(): void;
        add_PushNotificationReceived(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PushNotificationReceived(token: Windows.Foundation.EventRegistrationToken): void;
        expirationTime: Date;
        uri: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        removeEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        onpushnotificationreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>) => void;

    }

    export interface IPushNotificationReceivedEventArgs {
        badgeNotification: Windows.UI.Notifications.BadgeNotification;
        cancel: boolean;
        notificationType: Windows.Networking.PushNotifications.PushNotificationType;
        rawNotification: Windows.Networking.PushNotifications.RawNotification;
        tileNotification: Windows.UI.Notifications.TileNotification;
        toastNotification: Windows.UI.Notifications.ToastNotification;
    }

    export interface IRawNotification {
        content: string;
    }

    export class PushNotificationChannel implements Windows.Networking.PushNotifications.IPushNotificationChannel {
        close(): void;
        add_PushNotificationReceived(handler: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PushNotificationReceived(token: Windows.Foundation.EventRegistrationToken): void;
        expirationTime: Date;
        uri: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        removeEventListener(eventName: "pushnotificationreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>): void;
        onpushnotificationreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.PushNotifications.PushNotificationChannel,Windows.Networking.PushNotifications.PushNotificationReceivedEventArgs>) => void;

    }

    export class PushNotificationChannelManager {
        static createPushNotificationChannelForApplicationAsync(): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
        static createPushNotificationChannelForApplicationAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
        static createPushNotificationChannelForSecondaryTileAsync(tileId: string): Windows.Foundation.IAsyncOperation<Windows.Networking.PushNotifications.PushNotificationChannel>;
    }

    export class PushNotificationReceivedEventArgs implements Windows.Networking.PushNotifications.IPushNotificationReceivedEventArgs {
        badgeNotification: Windows.UI.Notifications.BadgeNotification;
        cancel: boolean;
        notificationType: Windows.Networking.PushNotifications.PushNotificationType;
        rawNotification: Windows.Networking.PushNotifications.RawNotification;
        tileNotification: Windows.UI.Notifications.TileNotification;
        toastNotification: Windows.UI.Notifications.ToastNotification;
    }

    enum PushNotificationType {
        toast,
        tile,
        badge,
        raw
    }

    export class RawNotification implements Windows.Networking.PushNotifications.IRawNotification {
        content: string;
    }

}
declare module Windows.Networking.Sockets {

    export class BandwidthStatistics {
        outboundBitsPerSecond: number;
        inboundBitsPerSecond: number;
        outboundBitsPerSecondInstability: number;
        inboundBitsPerSecondInstability: number;
        outboundBandwidthPeaked: boolean;
        inboundBandwidthPeaked: boolean;
    }

    export class ControlChannelTrigger implements Windows.Networking.Sockets.IControlChannelTrigger, Windows.Foundation.IClosable {
        constructor(channelId: string, serverKeepAliveIntervalInMinutes: number);
        constructor(channelId: string, serverKeepAliveIntervalInMinutes: number, resourceRequestType: Windows.Networking.Sockets.ControlChannelTriggerResourceType);
        usingTransport(transport: any): void;
        waitForPushEnabled(): Windows.Networking.Sockets.ControlChannelTriggerStatus;
        decreaseNetworkKeepAliveInterval(): void;
        flushTransport(): void;
        close(): void;
        controlChannelTriggerId: string;
        currentKeepAliveIntervalInMinutes: number;
        keepAliveTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        pushNotificationTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        serverKeepAliveIntervalInMinutes: number;
        transportObject: any;
    }

    enum ControlChannelTriggerResetReason {
        fastUserSwitched,
        lowPowerExit
    }

    enum ControlChannelTriggerResourceType {
        requestSoftwareSlot,
        requestHardwareSlot
    }

    enum ControlChannelTriggerStatus {
        hardwareSlotRequested,
        softwareSlotAllocated,
        hardwareSlotAllocated,
        policyError,
        systemError,
        transportDisconnected,
        serviceUnavailable
    }

    export class DatagramSocket implements Windows.Networking.Sockets.IDatagramSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        joinMulticastGroup(host: Windows.Networking.HostName): void;
        getOutputStreamAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        getOutputStreamAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        add_MessageReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        close(): void;
        static getEndpointPairsAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>>;
        static getEndpointPairsAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, sortOptions: Windows.Networking.HostNameSortOptions): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair>>;
        control: Windows.Networking.Sockets.DatagramSocketControl;
        information: Windows.Networking.Sockets.DatagramSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>) => void;

    }

    export class DatagramSocketControl implements Windows.Networking.Sockets.IDatagramSocketControl {
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class DatagramSocketInformation implements Windows.Networking.Sockets.IDatagramSocketInformation {
        localAddress: Windows.Networking.HostName;
        localPort: string;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export class DatagramSocketMessageReceivedEventArgs implements Windows.Networking.Sockets.IDatagramSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        localAddress: Windows.Networking.HostName;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IControlChannelTrigger extends Windows.Foundation.IClosable {
        usingTransport(transport: any): void;
        waitForPushEnabled(): Windows.Networking.Sockets.ControlChannelTriggerStatus;
        decreaseNetworkKeepAliveInterval(): void;
        flushTransport(): void;
        controlChannelTriggerId: string;
        currentKeepAliveIntervalInMinutes: number;
        keepAliveTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        pushNotificationTrigger: Windows.ApplicationModel.Background.IBackgroundTrigger;
        serverKeepAliveIntervalInMinutes: number;
        transportObject: any;
    }

    export interface IControlChannelTriggerEventDetails {
        controlChannelTrigger: Windows.Networking.Sockets.ControlChannelTrigger;
    }

    export interface IControlChannelTriggerResetEventDetails {
        hardwareSlotReset: boolean;
        resetReason: Windows.Networking.Sockets.ControlChannelTriggerResetReason;
        softwareSlotReset: boolean;
    }

    export interface IDatagramSocket extends Windows.Foundation.IClosable {
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        joinMulticastGroup(host: Windows.Networking.HostName): void;
        getOutputStreamAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        getOutputStreamAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IOutputStream>;
        add_MessageReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        control: Windows.Networking.Sockets.DatagramSocketControl;
        information: Windows.Networking.Sockets.DatagramSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.DatagramSocket,Windows.Networking.Sockets.DatagramSocketMessageReceivedEventArgs>) => void;

    }

    export interface IDatagramSocketControl {
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IDatagramSocketInformation {
        localAddress: Windows.Networking.HostName;
        localPort: string;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IDatagramSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        localAddress: Windows.Networking.HostName;
        remoteAddress: Windows.Networking.HostName;
        remotePort: string;
    }

    export interface IMessageWebSocket extends Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        add_MessageReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        control: Windows.Networking.Sockets.MessageWebSocketControl;
        information: Windows.Networking.Sockets.MessageWebSocketInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>) => void;

    }

    export interface IMessageWebSocketControl extends Windows.Networking.Sockets.IWebSocketControl {
        maxMessageSize: number;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export interface IMessageWebSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export interface IStreamSocket extends Windows.Foundation.IClosable {
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        upgradeToSslAsync(protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, validationHostName: Windows.Networking.HostName): Windows.Foundation.IAsyncAction;
        control: Windows.Networking.Sockets.StreamSocketControl;
        information: Windows.Networking.Sockets.StreamSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
    }

    export interface IStreamSocketControl {
        keepAlive: boolean;
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IStreamSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        localPort: string;
        protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
        remoteAddress: Windows.Networking.HostName;
        remoteHostName: Windows.Networking.HostName;
        remotePort: string;
        remoteServiceName: string;
        roundTripTimeStatistics: Windows.Networking.Sockets.RoundTripTimeStatistics;
        sessionKey: Windows.Storage.Streams.IBuffer;
    }

    export interface IStreamSocketListener extends Windows.Foundation.IClosable {
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        add_ConnectionReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ConnectionReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        control: Windows.Networking.Sockets.StreamSocketListenerControl;
        information: Windows.Networking.Sockets.StreamSocketListenerInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        removeEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        onconnectionreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>) => void;

    }

    export interface IStreamSocketListenerConnectionReceivedEventArgs {
        socket: Windows.Networking.Sockets.StreamSocket;
    }

    export interface IStreamSocketListenerControl {
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export interface IStreamSocketListenerInformation {
        localPort: string;
    }

    export interface IStreamWebSocket extends Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        control: Windows.Networking.Sockets.StreamWebSocketControl;
        information: Windows.Networking.Sockets.StreamWebSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
    }

    export interface IStreamWebSocketControl extends Windows.Networking.Sockets.IWebSocketControl {
        noDelay: boolean;
    }

    export interface IWebSocket extends Windows.Foundation.IClosable {
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        add_Closed(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        close(code: number, reason: string): void;
        close(): void;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export interface IWebSocketClosedEventArgs {
        code: number;
        reason: string;
    }

    export interface IWebSocketControl {
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export interface IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class MessageWebSocket implements Windows.Networking.Sockets.IMessageWebSocket, Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        constructor();
        add_MessageReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_MessageReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        add_Closed(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        close(code: number, reason: string): void;
        close(): void;
        control: Windows.Networking.Sockets.MessageWebSocketControl;
        information: Windows.Networking.Sockets.MessageWebSocketInformation;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        removeEventListener(eventName: "messagereceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>): void;
        onmessagereceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.MessageWebSocket,Windows.Networking.Sockets.MessageWebSocketMessageReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export class MessageWebSocketControl implements Windows.Networking.Sockets.IMessageWebSocketControl, Windows.Networking.Sockets.IWebSocketControl {
        maxMessageSize: number;
        messageType: Windows.Networking.Sockets.SocketMessageType;
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export class MessageWebSocketInformation implements Windows.Networking.Sockets.IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class MessageWebSocketMessageReceivedEventArgs implements Windows.Networking.Sockets.IMessageWebSocketMessageReceivedEventArgs {
        getDataReader(): Windows.Storage.Streams.DataReader;
        getDataStream(): Windows.Storage.Streams.IInputStream;
        messageType: Windows.Networking.Sockets.SocketMessageType;
    }

    export class RoundTripTimeStatistics {
        variance: number;
        max: number;
        min: number;
        sum: number;
    }

    export class SocketError {
        static getStatus(hresult: number): Windows.Networking.Sockets.SocketErrorStatus;
    }

    enum SocketErrorStatus {
        unknown,
        operationAborted,
        httpInvalidServerResponse,
        connectionTimedOut,
        addressFamilyNotSupported,
        socketTypeNotSupported,
        hostNotFound,
        noDataRecordOfRequestedType,
        nonAuthoritativeHostNotFound,
        classTypeNotFound,
        addressAlreadyInUse,
        cannotAssignRequestedAddress,
        connectionRefused,
        networkIsUnreachable,
        unreachableHost,
        networkIsDown,
        networkDroppedConnectionOnReset,
        softwareCausedConnectionAbort,
        connectionResetByPeer,
        hostIsDown,
        noAddressesFound,
        tooManyOpenFiles,
        messageTooLong,
        certificateExpired,
        certificateUntrustedRoot,
        certificateCommonNameIsIncorrect,
        certificateWrongUsage,
        certificateRevoked,
        certificateNoRevocationCheck,
        certificateRevocationServerOffline,
        certificateIsInvalid
    }

    enum SocketMessageType {
        binary,
        utf8
    }

    enum SocketProtectionLevel {
        plainSocket,
        ssl,
        sslAllowNullEncryption
    }

    enum SocketQualityOfService {
        normal,
        lowLatency
    }

    export class StreamSocket implements Windows.Networking.Sockets.IStreamSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(endpointPair: Windows.Networking.EndpointPair): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string): Windows.Foundation.IAsyncAction;
        connectAsync(endpointPair: Windows.Networking.EndpointPair, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        connectAsync(remoteHostName: Windows.Networking.HostName, remoteServiceName: string, protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel): Windows.Foundation.IAsyncAction;
        upgradeToSslAsync(protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel, validationHostName: Windows.Networking.HostName): Windows.Foundation.IAsyncAction;
        close(): void;
        control: Windows.Networking.Sockets.StreamSocketControl;
        information: Windows.Networking.Sockets.StreamSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
    }

    export class StreamSocketControl implements Windows.Networking.Sockets.IStreamSocketControl {
        keepAlive: boolean;
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        outboundUnicastHopLimit: number;
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class StreamSocketInformation implements Windows.Networking.Sockets.IStreamSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        localPort: string;
        protectionLevel: Windows.Networking.Sockets.SocketProtectionLevel;
        remoteAddress: Windows.Networking.HostName;
        remoteHostName: Windows.Networking.HostName;
        remotePort: string;
        remoteServiceName: string;
        roundTripTimeStatistics: Windows.Networking.Sockets.RoundTripTimeStatistics;
        sessionKey: Windows.Storage.Streams.IBuffer;
    }

    export class StreamSocketListener implements Windows.Networking.Sockets.IStreamSocketListener, Windows.Foundation.IClosable {
        constructor();
        bindServiceNameAsync(localServiceName: string): Windows.Foundation.IAsyncAction;
        bindEndpointAsync(localHostName: Windows.Networking.HostName, localServiceName: string): Windows.Foundation.IAsyncAction;
        add_ConnectionReceived(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ConnectionReceived(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        close(): void;
        control: Windows.Networking.Sockets.StreamSocketListenerControl;
        information: Windows.Networking.Sockets.StreamSocketListenerInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        removeEventListener(eventName: "connectionreceived", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>): void;
        onconnectionreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.StreamSocketListener,Windows.Networking.Sockets.StreamSocketListenerConnectionReceivedEventArgs>) => void;

    }

    export class StreamSocketListenerConnectionReceivedEventArgs implements Windows.Networking.Sockets.IStreamSocketListenerConnectionReceivedEventArgs {
        socket: Windows.Networking.Sockets.StreamSocket;
    }

    export class StreamSocketListenerControl implements Windows.Networking.Sockets.IStreamSocketListenerControl {
        qualityOfService: Windows.Networking.Sockets.SocketQualityOfService;
    }

    export class StreamSocketListenerInformation implements Windows.Networking.Sockets.IStreamSocketListenerInformation {
        localPort: string;
    }

    export class StreamWebSocket implements Windows.Networking.Sockets.IStreamWebSocket, Windows.Networking.Sockets.IWebSocket, Windows.Foundation.IClosable {
        constructor();
        connectAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncAction;
        setRequestHeader(headerName: string, headerValue: string): void;
        add_Closed(eventHandler: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        close(code: number, reason: string): void;
        close(): void;
        control: Windows.Networking.Sockets.StreamWebSocketControl;
        information: Windows.Networking.Sockets.StreamWebSocketInformation;
        inputStream: Windows.Storage.Streams.IInputStream;
        outputStream: Windows.Storage.Streams.IOutputStream;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Networking.Sockets.IWebSocket,Windows.Networking.Sockets.WebSocketClosedEventArgs>) => void;

    }

    export class StreamWebSocketControl implements Windows.Networking.Sockets.IStreamWebSocketControl, Windows.Networking.Sockets.IWebSocketControl {
        noDelay: boolean;
        outboundBufferSizeInBytes: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        supportedProtocols: Windows.Foundation.Collections.IVector<string>;
    }

    export class StreamWebSocketInformation implements Windows.Networking.Sockets.IWebSocketInformation {
        bandwidthStatistics: Windows.Networking.Sockets.BandwidthStatistics;
        localAddress: Windows.Networking.HostName;
        protocol: string;
    }

    export class WebSocketClosedEventArgs implements Windows.Networking.Sockets.IWebSocketClosedEventArgs {
        code: number;
        reason: string;
    }

    export class WebSocketError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    export class WebSocketKeepAlive implements Windows.ApplicationModel.Background.IBackgroundTask {
        constructor();
        run(taskInstance: Windows.ApplicationModel.Background.IBackgroundTaskInstance): void;
    }

}
declare module Windows.Security.Authentication.OnlineId {

    enum CredentialPromptType {
        promptIfNeeded,
        retypeCredentials,
        doNotPrompt
    }

    export interface IOnlineIdAuthenticator {
        authenticateUserAsync(request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        authenticateUserAsync(requests: Windows.Foundation.Collections.IIterable<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>, credentialPromptType: Windows.Security.Authentication.OnlineId.CredentialPromptType): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        signOutUserAsync(): Windows.Security.Authentication.OnlineId.SignOutUserOperation;
        applicationId: string;
        authenticatedSafeCustomerId: string;
        canSignOut: boolean;
    }

    export interface IOnlineIdServiceTicket {
        errorCode: number;
        request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
        value: string;
    }

    export interface IOnlineIdServiceTicketRequest {
        policy: string;
        service: string;
    }

    export interface IUserIdentity {
        firstName: string;
        id: string;
        isBetaAccount: boolean;
        isConfirmedPC: boolean;
        lastName: string;
        safeCustomerId: string;
        signInName: string;
        tickets: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>;
    }

    export class OnlineIdAuthenticator implements Windows.Security.Authentication.OnlineId.IOnlineIdAuthenticator {
        constructor();
        authenticateUserAsync(request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        authenticateUserAsync(requests: Windows.Foundation.Collections.IIterable<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest>, credentialPromptType: Windows.Security.Authentication.OnlineId.CredentialPromptType): Windows.Security.Authentication.OnlineId.UserAuthenticationOperation;
        signOutUserAsync(): Windows.Security.Authentication.OnlineId.SignOutUserOperation;
        applicationId: string;
        authenticatedSafeCustomerId: string;
        canSignOut: boolean;
    }

    export class OnlineIdServiceTicket implements Windows.Security.Authentication.OnlineId.IOnlineIdServiceTicket {
        errorCode: number;
        request: Windows.Security.Authentication.OnlineId.OnlineIdServiceTicketRequest;
        value: string;
    }

    export class OnlineIdServiceTicketRequest implements Windows.Security.Authentication.OnlineId.IOnlineIdServiceTicketRequest {
        constructor(service: string, policy: string);
        constructor(service: string);
        policy: string;
        service: string;
    }

    export class SignOutUserOperation implements Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncInfo {
        getResults(): void;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export class UserAuthenticationOperation implements Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.OnlineId.UserIdentity>, Windows.Foundation.IAsyncInfo {
        getResults(): Windows.Security.Authentication.OnlineId.UserIdentity;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<Windows.Security.Authentication.OnlineId.UserIdentity>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: Windows.Security.Authentication.OnlineId.UserIdentity) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class UserIdentity implements Windows.Security.Authentication.OnlineId.IUserIdentity {
        firstName: string;
        id: string;
        isBetaAccount: boolean;
        isConfirmedPC: boolean;
        lastName: string;
        safeCustomerId: string;
        signInName: string;
        tickets: Windows.Foundation.Collections.IVectorView<Windows.Security.Authentication.OnlineId.OnlineIdServiceTicket>;
    }

}
declare module Windows.Security.Authentication.Web {

    export interface IWebAuthenticationResult {
        responseData: string;
        responseErrorDetail: number;
        responseStatus: Windows.Security.Authentication.Web.WebAuthenticationStatus;
    }

    export class WebAuthenticationBroker {
        static authenticateAsync(options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri, callbackUri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
        static authenticateAsync(options: Windows.Security.Authentication.Web.WebAuthenticationOptions, requestUri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Security.Authentication.Web.WebAuthenticationResult>;
        static getCurrentApplicationCallbackUri(): Windows.Foundation.Uri;
    }

    enum WebAuthenticationOptions {
        none,
        silentMode,
        useTitle,
        useHttpPost,
        useCorporateNetwork
    }

    export class WebAuthenticationResult implements Windows.Security.Authentication.Web.IWebAuthenticationResult {
        responseData: string;
        responseErrorDetail: number;
        responseStatus: Windows.Security.Authentication.Web.WebAuthenticationStatus;
    }

    enum WebAuthenticationStatus {
        success,
        userCancel,
        errorHttp
    }

}
declare module Windows.Security.Credentials {

    export interface IPasswordCredential {
        retrievePassword(): void;
        password: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        resource: string;
        userName: string;
    }

    export interface IPasswordVault {
        add(credential: Windows.Security.Credentials.PasswordCredential): void;
        remove(credential: Windows.Security.Credentials.PasswordCredential): void;
        retrieve(resource: string, userName: string): Windows.Security.Credentials.PasswordCredential;
        findAllByResource(resource: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        findAllByUserName(userName: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        retrieveAll(): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
    }

    export class PasswordCredential implements Windows.Security.Credentials.IPasswordCredential {
        constructor(resource: string, userName: string, password: string);
        constructor();
        retrievePassword(): void;
        password: string;
        properties: Windows.Foundation.Collections.IPropertySet;
        resource: string;
        userName: string;
    }

    export class PasswordCredentialPropertyStore implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export class PasswordVault implements Windows.Security.Credentials.IPasswordVault {
        constructor();
        add(credential: Windows.Security.Credentials.PasswordCredential): void;
        remove(credential: Windows.Security.Credentials.PasswordCredential): void;
        retrieve(resource: string, userName: string): Windows.Security.Credentials.PasswordCredential;
        findAllByResource(resource: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        findAllByUserName(userName: string): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
        retrieveAll(): Windows.Foundation.Collections.IVectorView<Windows.Security.Credentials.PasswordCredential>;
    }

}
declare module Windows.Security.Credentials.UI {

    enum AuthenticationProtocol {
        basic,
        digest,
        ntlm,
        kerberos,
        negotiate,
        credSsp,
        custom
    }

    export class CredentialPicker {
        static pickAsync(options: Windows.Security.Credentials.UI.CredentialPickerOptions): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
        static pickAsync(targetName: string, message: string): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
        static pickAsync(targetName: string, message: string, caption: string): Windows.Foundation.IAsyncOperation<Windows.Security.Credentials.UI.CredentialPickerResults>;
    }

    export class CredentialPickerOptions implements Windows.Security.Credentials.UI.ICredentialPickerOptions {
        constructor();
        alwaysDisplayDialog: boolean;
        authenticationProtocol: Windows.Security.Credentials.UI.AuthenticationProtocol;
        callerSavesCredential: boolean;
        caption: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        customAuthenticationProtocol: string;
        errorCode: number;
        message: string;
        previousCredential: Windows.Storage.Streams.IBuffer;
        targetName: string;
    }

    export class CredentialPickerResults implements Windows.Security.Credentials.UI.ICredentialPickerResults {
        credential: Windows.Storage.Streams.IBuffer;
        credentialDomainName: string;
        credentialPassword: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        credentialSaved: boolean;
        credentialUserName: string;
        errorCode: number;
    }

    enum CredentialSaveOption {
        unselected,
        selected,
        hidden
    }

    export interface ICredentialPickerOptions {
        alwaysDisplayDialog: boolean;
        authenticationProtocol: Windows.Security.Credentials.UI.AuthenticationProtocol;
        callerSavesCredential: boolean;
        caption: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        customAuthenticationProtocol: string;
        errorCode: number;
        message: string;
        previousCredential: Windows.Storage.Streams.IBuffer;
        targetName: string;
    }

    export interface ICredentialPickerResults {
        credential: Windows.Storage.Streams.IBuffer;
        credentialDomainName: string;
        credentialPassword: string;
        credentialSaveOption: Windows.Security.Credentials.UI.CredentialSaveOption;
        credentialSaved: boolean;
        credentialUserName: string;
        errorCode: number;
    }

}
declare module Windows.Security.Cryptography {

    enum BinaryStringEncoding {
        utf8,
        utf16LE,
        utf16BE
    }

    export class CryptographicBuffer {
        static compare(object1: Windows.Storage.Streams.IBuffer, object2: Windows.Storage.Streams.IBuffer): boolean;
        static generateRandom(length: number): Windows.Storage.Streams.IBuffer;
        static generateRandomNumber(): number;
        static createFromByteArray(value: any): Windows.Storage.Streams.IBuffer;
        static copyToByteArray(buffer: Windows.Storage.Streams.IBuffer): CryptographicBuffer_copyToByteArray_OUT;
        static decodeFromHexString(value: string): Windows.Storage.Streams.IBuffer;
        static encodeToHexString(buffer: Windows.Storage.Streams.IBuffer): string;
        static decodeFromBase64String(value: string): Windows.Storage.Streams.IBuffer;
        static encodeToBase64String(buffer: Windows.Storage.Streams.IBuffer): string;
        static convertStringToBinary(value: string, encoding: Windows.Security.Cryptography.BinaryStringEncoding): Windows.Storage.Streams.IBuffer;
        static convertBinaryToString(encoding: Windows.Security.Cryptography.BinaryStringEncoding, buffer: Windows.Storage.Streams.IBuffer): string;
    }

    interface CryptographicBuffer_copyToByteArray_OUT {
        value: number[];
    }

}
declare module Windows.Security.Cryptography.Certificates {

    export class CertificateEnrollmentManager {
        static createRequestAsync(request: Windows.Security.Cryptography.Certificates.CertificateRequestProperties): Windows.Foundation.IAsyncOperation<string>;
        static installCertificateAsync(certificate: string, installOption: Windows.Security.Cryptography.Certificates.InstallOptions): Windows.Foundation.IAsyncAction;
        static importPfxDataAsync(pfxData: string, password: string, exportable: Windows.Security.Cryptography.Certificates.ExportOption, keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel, installOption: Windows.Security.Cryptography.Certificates.InstallOptions, friendlyName: string): Windows.Foundation.IAsyncAction;
    }

    export class CertificateRequestProperties implements Windows.Security.Cryptography.Certificates.ICertificateRequestProperties {
        constructor();
        exportable: Windows.Security.Cryptography.Certificates.ExportOption;
        friendlyName: string;
        hashAlgorithmName: string;
        keyAlgorithmName: string;
        keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
        keySize: number;
        keyStorageProviderName: string;
        keyUsages: Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
        subject: string;
    }

    enum EnrollKeyUsages {
        none,
        decryption,
        signing,
        keyAgreement,
        all
    }

    enum ExportOption {
        notExportable,
        exportable
    }

    export interface ICertificateRequestProperties {
        exportable: Windows.Security.Cryptography.Certificates.ExportOption;
        friendlyName: string;
        hashAlgorithmName: string;
        keyAlgorithmName: string;
        keyProtectionLevel: Windows.Security.Cryptography.Certificates.KeyProtectionLevel;
        keySize: number;
        keyStorageProviderName: string;
        keyUsages: Windows.Security.Cryptography.Certificates.EnrollKeyUsages;
        subject: string;
    }

    enum InstallOptions {
        none,
        deleteExpired
    }

    export class KeyAlgorithmNames {
        static dsa: string;
        static ecdh256: string;
        static ecdh384: string;
        static ecdh521: string;
        static ecdsa256: string;
        static ecdsa384: string;
        static ecdsa521: string;
        static rsa: string;
    }

    enum KeyProtectionLevel {
        noConsent,
        consentOnly,
        consentWithPassword
    }

    enum KeySize {
        invalid,
        rsa2048,
        rsa4096
    }

    export class KeyStorageProviderNames {
        static platformKeyStorageProvider: string;
        static smartcardKeyStorageProvider: string;
        static softwareKeyStorageProvider: string;
    }

}
declare module Windows.Security.Cryptography.Core {

    export class AsymmetricAlgorithmNames {
        static dsaSha1: string;
        static dsaSha256: string;
        static ecdsaP256Sha256: string;
        static ecdsaP384Sha384: string;
        static ecdsaP521Sha512: string;
        static rsaOaepSha1: string;
        static rsaOaepSha256: string;
        static rsaOaepSha384: string;
        static rsaOaepSha512: string;
        static rsaPkcs1: string;
        static rsaSignPkcs1Sha1: string;
        static rsaSignPkcs1Sha256: string;
        static rsaSignPkcs1Sha384: string;
        static rsaSignPkcs1Sha512: string;
        static rsaSignPssSha1: string;
        static rsaSignPssSha256: string;
        static rsaSignPssSha384: string;
        static rsaSignPssSha512: string;
    }

    export class AsymmetricKeyAlgorithmProvider implements Windows.Security.Cryptography.Core.IAsymmetricKeyAlgorithmProvider {
        createKeyPair(keySize: number): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.AsymmetricKeyAlgorithmProvider;
        algorithmName: string;
    }

    export class CryptographicEngine {
        static encrypt(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static decrypt(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, iv: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static encryptAndAuthenticate(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.EncryptedAndAuthenticatedData;
        static decryptAndAuthenticate(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, nonce: Windows.Storage.Streams.IBuffer, authenticationTag: Windows.Storage.Streams.IBuffer, authenticatedData: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static sign(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        static verifySignature(key: Windows.Security.Cryptography.Core.CryptographicKey, data: Windows.Storage.Streams.IBuffer, signature: Windows.Storage.Streams.IBuffer): boolean;
        static deriveKeyMaterial(key: Windows.Security.Cryptography.Core.CryptographicKey, parameters: Windows.Security.Cryptography.Core.KeyDerivationParameters, desiredKeySize: number): Windows.Storage.Streams.IBuffer;
    }

    export class CryptographicHash implements Windows.Security.Cryptography.Core.IHashComputation {
        append(data: Windows.Storage.Streams.IBuffer): void;
        getValueAndReset(): Windows.Storage.Streams.IBuffer;
    }

    export class CryptographicKey implements Windows.Security.Cryptography.Core.ICryptographicKey {
        export(): Windows.Storage.Streams.IBuffer;
        export(BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Storage.Streams.IBuffer;
        exportPublicKey(): Windows.Storage.Streams.IBuffer;
        exportPublicKey(BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Storage.Streams.IBuffer;
        keySize: number;
    }

    enum CryptographicPrivateKeyBlobType {
        pkcs8RawPrivateKeyInfo,
        pkcs1RsaPrivateKey,
        bCryptPrivateKey,
        capi1PrivateKey
    }

    enum CryptographicPublicKeyBlobType {
        x509SubjectPublicKeyInfo,
        pkcs1RsaPublicKey,
        bCryptPublicKey,
        capi1PublicKey
    }

    export class EncryptedAndAuthenticatedData implements Windows.Security.Cryptography.Core.IEncryptedAndAuthenticatedData {
        authenticationTag: Windows.Storage.Streams.IBuffer;
        encryptedData: Windows.Storage.Streams.IBuffer;
    }

    export class HashAlgorithmNames {
        static md5: string;
        static sha1: string;
        static sha256: string;
        static sha384: string;
        static sha512: string;
    }

    export class HashAlgorithmProvider implements Windows.Security.Cryptography.Core.IHashAlgorithmProvider {
        hashData(data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        createHash(): Windows.Security.Cryptography.Core.CryptographicHash;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.HashAlgorithmProvider;
        algorithmName: string;
        hashLength: number;
    }

    export interface IAsymmetricKeyAlgorithmProvider {
        createKeyPair(keySize: number): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importKeyPair(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        importPublicKey(keyBlob: Windows.Storage.Streams.IBuffer, BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
    }

    export interface ICryptographicKey {
        export(): Windows.Storage.Streams.IBuffer;
        export(BlobType: Windows.Security.Cryptography.Core.CryptographicPrivateKeyBlobType): Windows.Storage.Streams.IBuffer;
        exportPublicKey(): Windows.Storage.Streams.IBuffer;
        exportPublicKey(BlobType: Windows.Security.Cryptography.Core.CryptographicPublicKeyBlobType): Windows.Storage.Streams.IBuffer;
        keySize: number;
    }

    export interface IEncryptedAndAuthenticatedData {
        authenticationTag: Windows.Storage.Streams.IBuffer;
        encryptedData: Windows.Storage.Streams.IBuffer;
    }

    export interface IHashAlgorithmProvider {
        hashData(data: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.IBuffer;
        createHash(): Windows.Security.Cryptography.Core.CryptographicHash;
        algorithmName: string;
        hashLength: number;
    }

    export interface IHashComputation {
        append(data: Windows.Storage.Streams.IBuffer): void;
        getValueAndReset(): Windows.Storage.Streams.IBuffer;
    }

    export interface IKeyDerivationAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
    }

    export interface IKeyDerivationParameters {
        iterationCount: number;
        kdfGenericBinary: Windows.Storage.Streams.IBuffer;
    }

    export interface IMacAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
        macLength: number;
    }

    export interface ISymmetricKeyAlgorithmProvider {
        createSymmetricKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        algorithmName: string;
        blockLength: number;
    }

    export class KeyDerivationAlgorithmNames {
        static pbkdf2Md5: string;
        static pbkdf2Sha1: string;
        static pbkdf2Sha256: string;
        static pbkdf2Sha384: string;
        static pbkdf2Sha512: string;
        static sp800108CtrHmacMd5: string;
        static sp800108CtrHmacSha1: string;
        static sp800108CtrHmacSha256: string;
        static sp800108CtrHmacSha384: string;
        static sp800108CtrHmacSha512: string;
        static sp80056aConcatMd5: string;
        static sp80056aConcatSha1: string;
        static sp80056aConcatSha256: string;
        static sp80056aConcatSha384: string;
        static sp80056aConcatSha512: string;
    }

    export class KeyDerivationAlgorithmProvider implements Windows.Security.Cryptography.Core.IKeyDerivationAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.KeyDerivationAlgorithmProvider;
        algorithmName: string;
    }

    export class KeyDerivationParameters implements Windows.Security.Cryptography.Core.IKeyDerivationParameters {
        static buildForPbkdf2(pbkdf2Salt: Windows.Storage.Streams.IBuffer, iterationCount: number): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        static buildForSP800108(label: Windows.Storage.Streams.IBuffer, context: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        static buildForSP80056a(algorithmId: Windows.Storage.Streams.IBuffer, partyUInfo: Windows.Storage.Streams.IBuffer, partyVInfo: Windows.Storage.Streams.IBuffer, suppPubInfo: Windows.Storage.Streams.IBuffer, suppPrivInfo: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.KeyDerivationParameters;
        iterationCount: number;
        kdfGenericBinary: Windows.Storage.Streams.IBuffer;
    }

    export class MacAlgorithmNames {
        static aesCmac: string;
        static hmacMd5: string;
        static hmacSha1: string;
        static hmacSha256: string;
        static hmacSha384: string;
        static hmacSha512: string;
    }

    export class MacAlgorithmProvider implements Windows.Security.Cryptography.Core.IMacAlgorithmProvider {
        createKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.MacAlgorithmProvider;
        algorithmName: string;
        macLength: number;
    }

    export class SymmetricAlgorithmNames {
        static aesCbc: string;
        static aesCbcPkcs7: string;
        static aesCcm: string;
        static aesEcb: string;
        static aesEcbPkcs7: string;
        static aesGcm: string;
        static desCbc: string;
        static desCbcPkcs7: string;
        static desEcb: string;
        static desEcbPkcs7: string;
        static rc2Cbc: string;
        static rc2CbcPkcs7: string;
        static rc2Ecb: string;
        static rc2EcbPkcs7: string;
        static rc4: string;
        static tripleDesCbc: string;
        static tripleDesCbcPkcs7: string;
        static tripleDesEcb: string;
        static tripleDesEcbPkcs7: string;
    }

    export class SymmetricKeyAlgorithmProvider implements Windows.Security.Cryptography.Core.ISymmetricKeyAlgorithmProvider {
        createSymmetricKey(keyMaterial: Windows.Storage.Streams.IBuffer): Windows.Security.Cryptography.Core.CryptographicKey;
        static openAlgorithm(algorithm: string): Windows.Security.Cryptography.Core.SymmetricKeyAlgorithmProvider;
        algorithmName: string;
        blockLength: number;
    }

}
declare module Windows.Security.Cryptography.DataProtection {

    export class DataProtectionProvider implements Windows.Security.Cryptography.DataProtection.IDataProtectionProvider {
        constructor(protectionDescriptor: string);
        constructor();
        protectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        unprotectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        protectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
        unprotectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
    }

    export interface IDataProtectionProvider {
        protectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        unprotectAsync(data: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        protectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
        unprotectStreamAsync(src: Windows.Storage.Streams.IInputStream, dest: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncAction;
    }

}
declare module Windows.Security.ExchangeActiveSyncProvisioning {

    export class EasClientDeviceInformation implements Windows.Security.ExchangeActiveSyncProvisioning.IEasClientDeviceInformation {
        constructor();
        friendlyName: string;
        id: string;
        operatingSystem: string;
        systemManufacturer: string;
        systemProductName: string;
        systemSku: string;
    }

    export class EasClientSecurityPolicy implements Windows.Security.ExchangeActiveSyncProvisioning.IEasClientSecurityPolicy {
        constructor();
        checkCompliance(): Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
        applyAsync(): Windows.Foundation.IAsyncOperation<Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>;
        disallowConvenienceLogon: boolean;
        maxInactivityTimeLock: Windows.Foundation.TimeSpan;
        maxPasswordFailedAttempts: number;
        minPasswordComplexCharacters: number;
        minPasswordLength: number;
        passwordExpiration: Windows.Foundation.TimeSpan;
        passwordHistory: number;
        requireEncryption: boolean;
    }

    export class EasComplianceResults implements Windows.Security.ExchangeActiveSyncProvisioning.IEasComplianceResults {
        compliant: boolean;
        disallowConvenienceLogonResult: Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
        maxInactivityTimeLockResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
        maxPasswordFailedAttemptsResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
        minPasswordComplexCharactersResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
        minPasswordLengthResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
        passwordExpirationResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
        passwordHistoryResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
        requireEncryptionResult: Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult;
    }

    enum EasDisallowConvenienceLogonResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter
    }

    enum EasMaxInactivityTimeLockResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasMaxPasswordFailedAttemptsResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasMinPasswordComplexCharactersResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedPolicyNotEnforceable,
        invalidParameter,
        currentUserHasBlankPassword,
        adminsHaveBlankPassword,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword,
        connectedAdminsProviderPolicyIsWeak,
        connectedUserProviderPolicyIsWeak,
        changeConnectedAdminsPassword,
        changeConnectedUserPassword
    }

    enum EasMinPasswordLengthResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedPolicyNotEnforceable,
        invalidParameter,
        currentUserHasBlankPassword,
        adminsHaveBlankPassword,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword,
        connectedAdminsProviderPolicyIsWeak,
        connectedUserProviderPolicyIsWeak,
        changeConnectedAdminsPassword,
        changeConnectedUserPassword
    }

    enum EasPasswordExpirationResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        requestedExpirationIncompatible,
        invalidParameter,
        userCannotChangePassword,
        adminsCannotChangePassword,
        localControlledUsersCannotChangePassword
    }

    enum EasPasswordHistoryResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        requestedPolicyIsStricter,
        invalidParameter
    }

    enum EasRequireEncryptionResult {
        notEvaluated,
        compliant,
        canBeCompliant,
        notProvisionedOnAllVolumes,
        deFixedDataNotSupported,
        deHardwareNotCompliant,
        deWinReNotConfigured,
        deProtectionSuspended,
        deOsVolumeNotProtected,
        deProtectionNotYetEnabled,
        noFeatureLicense,
        osNotProtected
    }

    export interface IEasClientDeviceInformation {
        friendlyName: string;
        id: string;
        operatingSystem: string;
        systemManufacturer: string;
        systemProductName: string;
        systemSku: string;
    }

    export interface IEasClientSecurityPolicy {
        checkCompliance(): Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults;
        applyAsync(): Windows.Foundation.IAsyncOperation<Windows.Security.ExchangeActiveSyncProvisioning.EasComplianceResults>;
        disallowConvenienceLogon: boolean;
        maxInactivityTimeLock: Windows.Foundation.TimeSpan;
        maxPasswordFailedAttempts: number;
        minPasswordComplexCharacters: number;
        minPasswordLength: number;
        passwordExpiration: Windows.Foundation.TimeSpan;
        passwordHistory: number;
        requireEncryption: boolean;
    }

    export interface IEasComplianceResults {
        compliant: boolean;
        disallowConvenienceLogonResult: Windows.Security.ExchangeActiveSyncProvisioning.EasDisallowConvenienceLogonResult;
        maxInactivityTimeLockResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxInactivityTimeLockResult;
        maxPasswordFailedAttemptsResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMaxPasswordFailedAttemptsResult;
        minPasswordComplexCharactersResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordComplexCharactersResult;
        minPasswordLengthResult: Windows.Security.ExchangeActiveSyncProvisioning.EasMinPasswordLengthResult;
        passwordExpirationResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordExpirationResult;
        passwordHistoryResult: Windows.Security.ExchangeActiveSyncProvisioning.EasPasswordHistoryResult;
        requireEncryptionResult: Windows.Security.ExchangeActiveSyncProvisioning.EasRequireEncryptionResult;
    }

}
declare module Windows.Storage.AccessCache {

    enum AccessCacheOptions {
        none,
        disallowUserInput,
        fastLocationsOnly,
        useReadOnlyCachedCopy,
        suppressAccessTimeUpdate
    }

    export class AccessListEntry {
        token: string;
        metadata: string;
    }

    export class AccessListEntryView implements Windows.Foundation.Collections.IVectorView<Windows.Storage.AccessCache.AccessListEntry>, Windows.Foundation.Collections.IIterable<Windows.Storage.AccessCache.AccessListEntry> {
        getAt(index: number): Windows.Storage.AccessCache.AccessListEntry;
        indexOf(value: Windows.Storage.AccessCache.AccessListEntry): AccessListEntryView_indexOf_OUT;
        getMany(startIndex: number): AccessListEntryView_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.AccessCache.AccessListEntry>;
        size: number;
    }

    interface AccessListEntryView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface AccessListEntryView_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.AccessCache.AccessListEntry[];
    }

    export interface IItemRemovedEventArgs {
        removedEntry: Windows.Storage.AccessCache.AccessListEntry;
    }

    export interface IStorageItemAccessList {
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
    }

    export interface IStorageItemMostRecentlyUsedList extends Windows.Storage.AccessCache.IStorageItemAccessList {
        add_ItemRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ItemRemoved(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        removeEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        onitemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>) => void;

    }

    export class ItemRemovedEventArgs implements Windows.Storage.AccessCache.IItemRemovedEventArgs {
        removedEntry: Windows.Storage.AccessCache.AccessListEntry;
    }

    export class StorageApplicationPermissions {
        static futureAccessList: Windows.Storage.AccessCache.StorageItemAccessList;
        static mostRecentlyUsedList: Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList;
    }

    export class StorageItemAccessList implements Windows.Storage.AccessCache.IStorageItemAccessList {
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
    }

    export class StorageItemMostRecentlyUsedList implements Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList, Windows.Storage.AccessCache.IStorageItemAccessList {
        add_ItemRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ItemRemoved(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add(file: Windows.Storage.IStorageItem): string;
        add(file: Windows.Storage.IStorageItem, metadata: string): string;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem): void;
        addOrReplace(token: string, file: Windows.Storage.IStorageItem, metadata: string): void;
        getItemAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFileAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(token: string, options: Windows.Storage.AccessCache.AccessCacheOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        remove(token: string): void;
        containsItem(token: string): boolean;
        clear(): void;
        checkAccess(file: Windows.Storage.IStorageItem): boolean;
        entries: Windows.Storage.AccessCache.AccessListEntryView;
        maximumItemsAllowed: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        removeEventListener(eventName: "itemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>): void;
        onitemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>) => void;

    }

}
declare module Windows.Storage {

    export class ApplicationData implements Windows.Storage.IApplicationData {
        setVersionAsync(desiredVersion: number, handler: Windows.Storage.ApplicationDataSetVersionHandler): Windows.Foundation.IAsyncAction;
        clearAsync(): Windows.Foundation.IAsyncAction;
        clearAsync(locality: Windows.Storage.ApplicationDataLocality): Windows.Foundation.IAsyncAction;
        add_DataChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): Windows.Foundation.EventRegistrationToken;
        remove_DataChanged(token: Windows.Foundation.EventRegistrationToken): void;
        signalDataChanged(): void;
        localFolder: Windows.Storage.StorageFolder;
        localSettings: Windows.Storage.ApplicationDataContainer;
        roamingFolder: Windows.Storage.StorageFolder;
        roamingSettings: Windows.Storage.ApplicationDataContainer;
        roamingStorageQuota: number;
        temporaryFolder: Windows.Storage.StorageFolder;
        version: number;
        static current: Windows.Storage.ApplicationData;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        removeEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        ondatachanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>) => void;

    }

    export class ApplicationDataCompositeValue implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export class ApplicationDataContainer implements Windows.Storage.IApplicationDataContainer {
        createContainer(name: string, disposition: Windows.Storage.ApplicationDataCreateDisposition): Windows.Storage.ApplicationDataContainer;
        deleteContainer(name: string): void;
        containers: Windows.Foundation.Collections.IMapView<string,Windows.Storage.ApplicationDataContainer>;
        locality: Windows.Storage.ApplicationDataLocality;
        name: string;
        values: Windows.Foundation.Collections.IPropertySet;
    }

    export class ApplicationDataContainerSettings implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    enum ApplicationDataCreateDisposition {
        always,
        existing
    }

    enum ApplicationDataLocality {
        local,
        roaming,
        temporary
    }

    export interface ApplicationDataSetVersionHandler {
        target: Windows.Storage.SetVersionRequest;
        detail: any[];
        type: string;
    }

    export class CachedFileManager {
        static deferUpdates(file: Windows.Storage.IStorageFile): void;
        static completeUpdatesAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Storage.Provider.FileUpdateStatus>;
    }

    enum CreationCollisionOption {
        generateUniqueName,
        replaceExisting,
        failIfExists,
        openIfExists
    }

    export class DownloadsFolder {
        static createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        static createFileAsync(desiredName: string, option: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createFolderAsync(desiredName: string, option: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
    }

    enum FileAccessMode {
        read,
        readWrite
    }

    enum FileAttributes {
        normal,
        readOnly,
        directory,
        archive,
        temporary
    }

    export class FileIO {
        static readTextAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<string>;
        static readTextAsync(file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<string>;
        static writeTextAsync(file: Windows.Storage.IStorageFile, contents: string): Windows.Foundation.IAsyncAction;
        static writeTextAsync(file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendTextAsync(file: Windows.Storage.IStorageFile, contents: string): Windows.Foundation.IAsyncAction;
        static appendTextAsync(file: Windows.Storage.IStorageFile, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readLinesAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static readLinesAsync(file: Windows.Storage.IStorageFile, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static writeLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static writeLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(file: Windows.Storage.IStorageFile, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readBufferAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        static writeBufferAsync(file: Windows.Storage.IStorageFile, buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncAction;
        static writeBytesAsync(file: Windows.Storage.IStorageFile, buffer: any): Windows.Foundation.IAsyncAction;
    }

    export interface IApplicationData {
        setVersionAsync(desiredVersion: number, handler: Windows.Storage.ApplicationDataSetVersionHandler): Windows.Foundation.IAsyncAction;
        clearAsync(): Windows.Foundation.IAsyncAction;
        clearAsync(locality: Windows.Storage.ApplicationDataLocality): Windows.Foundation.IAsyncAction;
        add_DataChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): Windows.Foundation.EventRegistrationToken;
        remove_DataChanged(token: Windows.Foundation.EventRegistrationToken): void;
        signalDataChanged(): void;
        localFolder: Windows.Storage.StorageFolder;
        localSettings: Windows.Storage.ApplicationDataContainer;
        roamingFolder: Windows.Storage.StorageFolder;
        roamingSettings: Windows.Storage.ApplicationDataContainer;
        roamingStorageQuota: number;
        temporaryFolder: Windows.Storage.StorageFolder;
        version: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        removeEventListener(eventName: "datachanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>): void;
        ondatachanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.ApplicationData,any>) => void;

    }

    export interface IApplicationDataContainer {
        createContainer(name: string, disposition: Windows.Storage.ApplicationDataCreateDisposition): Windows.Storage.ApplicationDataContainer;
        deleteContainer(name: string): void;
        containers: Windows.Foundation.Collections.IMapView<string,Windows.Storage.ApplicationDataContainer>;
        locality: Windows.Storage.ApplicationDataLocality;
        name: string;
        values: Windows.Foundation.Collections.IPropertySet;
    }

    export interface ISetVersionDeferral {
        complete(): void;
    }

    export interface ISetVersionRequest {
        getDeferral(): Windows.Storage.SetVersionDeferral;
        currentVersion: number;
        desiredVersion: number;
    }

    export interface IStorageFile extends Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference {
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        contentType: string;
        fileType: string;
    }

    export interface IStorageFolder extends Windows.Storage.IStorageItem {
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
    }

    export interface IStorageItem {
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
    }

    export interface IStorageItemProperties {
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    export interface IStorageStreamTransaction extends Windows.Foundation.IClosable {
        commitAsync(): Windows.Foundation.IAsyncAction;
        stream: Windows.Storage.Streams.IRandomAccessStream;
    }

    export interface IStreamedFileDataRequest {
        failAndClose(failureMode: Windows.Storage.StreamedFileFailureMode): void;
    }

    export class KnownFolders {
        static documentsLibrary: Windows.Storage.StorageFolder;
        static homeGroup: Windows.Storage.StorageFolder;
        static mediaServerDevices: Windows.Storage.StorageFolder;
        static musicLibrary: Windows.Storage.StorageFolder;
        static picturesLibrary: Windows.Storage.StorageFolder;
        static removableDevices: Windows.Storage.StorageFolder;
        static videosLibrary: Windows.Storage.StorageFolder;
    }

    enum NameCollisionOption {
        generateUniqueName,
        replaceExisting,
        failIfExists
    }

    export class PathIO {
        static readTextAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<string>;
        static readTextAsync(absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<string>;
        static writeTextAsync(absolutePath: string, contents: string): Windows.Foundation.IAsyncAction;
        static writeTextAsync(absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendTextAsync(absolutePath: string, contents: string): Windows.Foundation.IAsyncAction;
        static appendTextAsync(absolutePath: string, contents: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readLinesAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static readLinesAsync(absolutePath: string, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVector<string>>;
        static writeLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static writeLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncAction;
        static appendLinesAsync(absolutePath: string, lines: Windows.Foundation.Collections.IIterable<string>, encoding: Windows.Storage.Streams.UnicodeEncoding): Windows.Foundation.IAsyncAction;
        static readBufferAsync(absolutePath: string): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IBuffer>;
        static writeBufferAsync(absolutePath: string, buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncAction;
        static writeBytesAsync(absolutePath: string, buffer: any): Windows.Foundation.IAsyncAction;
    }

    export class SetVersionDeferral implements Windows.Storage.ISetVersionDeferral {
        complete(): void;
    }

    export class SetVersionRequest implements Windows.Storage.ISetVersionRequest {
        getDeferral(): Windows.Storage.SetVersionDeferral;
        currentVersion: number;
        desiredVersion: number;
    }

    enum StorageDeleteOption {
        default,
        permanentDelete
    }

    export class StorageFile implements Windows.Storage.IStorageFile, Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference, Windows.Storage.IStorageItemProperties {
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        static getFileFromPathAsync(path: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static getFileFromApplicationUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createStreamedFileAsync(displayNameWithExtension: string, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static replaceWithStreamedFileAsync(fileToReplace: Windows.Storage.IStorageFile, dataRequested: Windows.Storage.StreamedFileDataRequestedHandler, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static createStreamedFileFromUriAsync(displayNameWithExtension: string, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        static replaceWithStreamedFileFromUriAsync(fileToReplace: Windows.Storage.IStorageFile, uri: Windows.Foundation.Uri, thumbnail: Windows.Storage.Streams.IRandomAccessStreamReference): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        contentType: string;
        fileType: string;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    export class StorageFolder implements Windows.Storage.IStorageFolder, Windows.Storage.IStorageItem, Windows.Storage.Search.IStorageFolderQueryOperations, Windows.Storage.IStorageItemProperties {
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        static getFolderFromPathAsync(path: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
    }

    enum StorageItemTypes {
        none,
        file,
        folder
    }

    export class StorageStreamTransaction implements Windows.Storage.IStorageStreamTransaction, Windows.Foundation.IClosable {
        commitAsync(): Windows.Foundation.IAsyncAction;
        close(): void;
        stream: Windows.Storage.Streams.IRandomAccessStream;
    }

    export class StreamedFileDataRequest implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable, Windows.Storage.IStreamedFileDataRequest {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
        failAndClose(failureMode: Windows.Storage.StreamedFileFailureMode): void;
    }

    export interface StreamedFileDataRequestedHandler {
        target: Windows.Storage.StreamedFileDataRequest;
        detail: any[];
        type: string;
    }

    enum StreamedFileFailureMode {
        failed,
        currentlyUnavailable,
        incomplete
    }

}
declare module Windows.Storage.BulkAccess {

    export class FileInformation implements Windows.Storage.BulkAccess.IStorageItemInformation, Windows.Storage.IStorageFile, Windows.Storage.IStorageItem, Windows.Storage.Streams.IRandomAccessStreamReference, Windows.Storage.Streams.IInputStreamReference, Windows.Storage.IStorageItemProperties {
        add_ThumbnailUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_ThumbnailUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_PropertiesUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_PropertiesUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        openAsync(accessMode: Windows.Storage.FileAccessMode): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStream>;
        openTransactedWriteAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageStreamTransaction>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        copyAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string): Windows.Foundation.IAsyncAction;
        moveAsync(destinationFolder: Windows.Storage.IStorageFolder, desiredNewName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        moveAndReplaceAsync(fileToReplace: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        contentType: string;
        fileType: string;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

    export class FileInformationFactory implements Windows.Storage.BulkAccess.IFileInformationFactory {
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions);
        constructor(queryResult: Windows.Storage.Search.IStorageQueryResultBase, mode: Windows.Storage.FileProperties.ThumbnailMode, requestedThumbnailSize: number, thumbnailOptions: Windows.Storage.FileProperties.ThumbnailOptions, delayLoad: boolean);
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getFilesAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFoldersAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getVirtualizedItemsVector(): any;
        getVirtualizedFilesVector(): any;
        getVirtualizedFoldersVector(): any;
    }

    export class FolderInformation implements Windows.Storage.BulkAccess.IStorageItemInformation, Windows.Storage.IStorageFolder, Windows.Storage.IStorageItem, Windows.Storage.IStorageItemProperties, Windows.Storage.Search.IStorageFolderQueryOperations {
        add_ThumbnailUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_ThumbnailUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_PropertiesUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_PropertiesUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        createFileAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFileAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        createFolderAsync(desiredName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        createFolderAsync(desiredName: string, options: Windows.Storage.CreationCollisionOption): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getFileAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        getFolderAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        getItemAsync(name: string): Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        renameAsync(desiredName: string): Windows.Foundation.IAsyncAction;
        renameAsync(desiredName: string, option: Windows.Storage.NameCollisionOption): Windows.Foundation.IAsyncAction;
        deleteAsync(): Windows.Foundation.IAsyncAction;
        deleteAsync(option: Windows.Storage.StorageDeleteOption): Windows.Foundation.IAsyncAction;
        getBasicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.BasicProperties>;
        isOfType(type: Windows.Storage.StorageItemTypes): boolean;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getThumbnailAsync(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.StorageItemThumbnail>;
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        attributes: Windows.Storage.FileAttributes;
        dateCreated: Date;
        name: string;
        path: string;
        displayName: string;
        displayType: string;
        folderRelativeId: string;
        properties: Windows.Storage.FileProperties.StorageItemContentProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

    export interface IFileInformationFactory {
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.IStorageItemInformation>>;
        getFilesAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FileInformation>>;
        getFoldersAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.BulkAccess.FolderInformation>>;
        getVirtualizedItemsVector(): any;
        getVirtualizedFilesVector(): any;
        getVirtualizedFoldersVector(): any;
    }

    export interface IStorageItemInformation {
        add_ThumbnailUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_ThumbnailUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_PropertiesUpdated(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): Windows.Foundation.EventRegistrationToken;
        remove_PropertiesUpdated(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        basicProperties: Windows.Storage.FileProperties.BasicProperties;
        documentProperties: Windows.Storage.FileProperties.DocumentProperties;
        imageProperties: Windows.Storage.FileProperties.ImageProperties;
        musicProperties: Windows.Storage.FileProperties.MusicProperties;
        thumbnail: Windows.Storage.FileProperties.StorageItemThumbnail;
        videoProperties: Windows.Storage.FileProperties.VideoProperties;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "propertiesupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onpropertiesupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;
        addEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        removeEventListener(eventName: "thumbnailupdated", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>): void;
        onthumbnailupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.BulkAccess.IStorageItemInformation,any>) => void;

    }

}
declare module Windows.Storage.Compression {

    enum CompressAlgorithm {
        invalidAlgorithm,
        nullAlgorithm,
        mszip,
        xpress,
        xpressHuff,
        lzms
    }

    export class Compressor implements Windows.Storage.Compression.ICompressor, Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        constructor(underlyingStream: Windows.Storage.Streams.IOutputStream);
        constructor(underlyingStream: Windows.Storage.Streams.IOutputStream, algorithm: Windows.Storage.Compression.CompressAlgorithm, blockSize: number);
        finishAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class Decompressor implements Windows.Storage.Compression.IDecompressor, Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        constructor(underlyingStream: Windows.Storage.Streams.IInputStream);
        detachStream(): Windows.Storage.Streams.IInputStream;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export interface ICompressor extends Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        finishAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachStream(): Windows.Storage.Streams.IOutputStream;
    }

    export interface IDecompressor extends Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        detachStream(): Windows.Storage.Streams.IInputStream;
    }

}
declare module Windows.Storage.FileProperties {

    export class BasicProperties implements Windows.Storage.FileProperties.IBasicProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        dateModified: Date;
        itemDate: Date;
        size: number;
    }

    export class DocumentProperties implements Windows.Storage.FileProperties.IDocumentProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        author: Windows.Foundation.Collections.IVector<string>;
        comment: string;
        keywords: Windows.Foundation.Collections.IVector<string>;
        title: string;
    }

    export interface IBasicProperties {
        dateModified: Date;
        itemDate: Date;
        size: number;
    }

    export interface IDocumentProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        author: Windows.Foundation.Collections.IVector<string>;
        comment: string;
        keywords: Windows.Foundation.Collections.IVector<string>;
        title: string;
    }

    export interface IImageProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        cameraManufacturer: string;
        cameraModel: string;
        dateTaken: Date;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.PhotoOrientation;
        peopleNames: Windows.Foundation.Collections.IVectorView<string>;
        rating: number;
        title: string;
        width: number;
    }

    export class ImageProperties implements Windows.Storage.FileProperties.IImageProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        cameraManufacturer: string;
        cameraModel: string;
        dateTaken: Date;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.PhotoOrientation;
        peopleNames: Windows.Foundation.Collections.IVectorView<string>;
        rating: number;
        title: string;
        width: number;
    }

    export interface IMusicProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        album: string;
        albumArtist: string;
        artist: string;
        bitrate: number;
        composers: Windows.Foundation.Collections.IVector<string>;
        conductors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        genre: Windows.Foundation.Collections.IVector<string>;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        trackNumber: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    export interface IStorageItemContentProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        getMusicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.MusicProperties>;
        getVideoPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.VideoProperties>;
        getImagePropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.ImageProperties>;
        getDocumentPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.DocumentProperties>;
    }

    export interface IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface IThumbnailProperties {
        originalHeight: number;
        originalWidth: number;
        returnedSmallerCachedSize: boolean;
        type: Windows.Storage.FileProperties.ThumbnailType;
    }

    export interface IVideoProperties extends Windows.Storage.FileProperties.IStorageItemExtraProperties {
        bitrate: number;
        directors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.VideoOrientation;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        width: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    export class MusicProperties implements Windows.Storage.FileProperties.IMusicProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        album: string;
        albumArtist: string;
        artist: string;
        bitrate: number;
        composers: Windows.Foundation.Collections.IVector<string>;
        conductors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        genre: Windows.Foundation.Collections.IVector<string>;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        trackNumber: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

    enum PhotoOrientation {
        unspecified,
        normal,
        flipHorizontal,
        rotate180,
        flipVertical,
        transpose,
        rotate270,
        transverse,
        rotate90
    }

    enum PropertyPrefetchOptions {
        none,
        musicProperties,
        videoProperties,
        imageProperties,
        documentProperties,
        basicProperties
    }

    export class StorageItemContentProperties implements Windows.Storage.FileProperties.IStorageItemContentProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        getMusicPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.MusicProperties>;
        getVideoPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.VideoProperties>;
        getImagePropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.ImageProperties>;
        getDocumentPropertiesAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.FileProperties.DocumentProperties>;
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
    }

    export class StorageItemThumbnail implements Windows.Storage.Streams.IRandomAccessStreamWithContentType, Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider, Windows.Storage.FileProperties.IThumbnailProperties {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
        contentType: string;
        originalHeight: number;
        originalWidth: number;
        returnedSmallerCachedSize: boolean;
        type: Windows.Storage.FileProperties.ThumbnailType;
    }

    enum ThumbnailMode {
        picturesView,
        videosView,
        musicView,
        documentsView,
        listView,
        singleItem
    }

    enum ThumbnailOptions {
        none,
        returnOnlyIfCached,
        resizeThumbnail,
        useCurrentScale
    }

    enum ThumbnailType {
        image,
        icon
    }

    enum VideoOrientation {
        normal,
        rotate90,
        rotate180,
        rotate270
    }

    export class VideoProperties implements Windows.Storage.FileProperties.IVideoProperties, Windows.Storage.FileProperties.IStorageItemExtraProperties {
        retrievePropertiesAsync(propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IMap<string,any>>;
        savePropertiesAsync(propertiesToSave: Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>>): Windows.Foundation.IAsyncAction;
        savePropertiesAsync(): Windows.Foundation.IAsyncAction;
        bitrate: number;
        directors: Windows.Foundation.Collections.IVector<string>;
        duration: Windows.Foundation.TimeSpan;
        height: number;
        keywords: Windows.Foundation.Collections.IVector<string>;
        latitude: Windows.Foundation.IReference<number>;
        longitude: Windows.Foundation.IReference<number>;
        orientation: Windows.Storage.FileProperties.VideoOrientation;
        producers: Windows.Foundation.Collections.IVector<string>;
        publisher: string;
        rating: number;
        subtitle: string;
        title: string;
        width: number;
        writers: Windows.Foundation.Collections.IVector<string>;
        year: number;
    }

}
declare module Windows.Storage.Pickers {

    export class FileExtensionVector implements Windows.Foundation.Collections.IVector<string>, Windows.Foundation.Collections.IIterable<string> {
        getAt(index: number): string;
        getView(): Windows.Foundation.Collections.IVectorView<string>;
        indexOf(value: string): FileExtensionVector_indexOf_OUT;
        setAt(index: number, value: string): void;
        insertAt(index: number, value: string): void;
        removeAt(index: number): void;
        append(value: string): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): FileExtensionVector_getMany_OUT;
        replaceAll(items: string[]): void;
        first(): Windows.Foundation.Collections.IIterator<string>;
        size: number;
    }

    interface FileExtensionVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface FileExtensionVector_getMany_OUT {
        __returnValue: number;
        items: string[];
    }

    export class FileOpenPicker implements Windows.Storage.Pickers.IFileOpenPicker {
        constructor();
        pickSingleFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        pickMultipleFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export class FilePickerFileTypesOrderedMap implements Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Foundation.Collections.IVector<string>>> {
        lookup(key: string): Windows.Foundation.Collections.IVector<string>;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,Windows.Foundation.Collections.IVector<string>>;
        insert(key: string, value: Windows.Foundation.Collections.IVector<string>): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,Windows.Foundation.Collections.IVector<string>>>;
        size: number;
    }

    export class FilePickerSelectedFilesArray implements Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>, Windows.Foundation.Collections.IIterable<Windows.Storage.StorageFile> {
        getAt(index: number): Windows.Storage.StorageFile;
        indexOf(value: Windows.Storage.StorageFile): FilePickerSelectedFilesArray_indexOf_OUT;
        getMany(startIndex: number): FilePickerSelectedFilesArray_getMany_OUT;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.StorageFile>;
        size: number;
    }

    interface FilePickerSelectedFilesArray_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface FilePickerSelectedFilesArray_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.StorageFile[];
    }

    export class FileSavePicker implements Windows.Storage.Pickers.IFileSavePicker {
        constructor();
        pickSaveFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        commitButtonText: string;
        defaultFileExtension: string;
        fileTypeChoices: Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>;
        settingsIdentifier: string;
        suggestedFileName: string;
        suggestedSaveFile: Windows.Storage.StorageFile;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
    }

    export class FolderPicker implements Windows.Storage.Pickers.IFolderPicker {
        constructor();
        pickSingleFolderAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export interface IFileOpenPicker {
        pickSingleFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        pickMultipleFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    export interface IFileSavePicker {
        pickSaveFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        commitButtonText: string;
        defaultFileExtension: string;
        fileTypeChoices: Windows.Foundation.Collections.IMap<string,Windows.Foundation.Collections.IVector<string>>;
        settingsIdentifier: string;
        suggestedFileName: string;
        suggestedSaveFile: Windows.Storage.StorageFile;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
    }

    export interface IFolderPicker {
        pickSingleFolderAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder>;
        commitButtonText: string;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        settingsIdentifier: string;
        suggestedStartLocation: Windows.Storage.Pickers.PickerLocationId;
        viewMode: Windows.Storage.Pickers.PickerViewMode;
    }

    enum PickerLocationId {
        documentsLibrary,
        computerFolder,
        desktop,
        downloads,
        homeGroup,
        musicLibrary,
        picturesLibrary,
        videosLibrary
    }

    enum PickerViewMode {
        list,
        thumbnail
    }

}
declare module Windows.Storage.Pickers.Provider {

    enum AddFileResult {
        added,
        alreadyAdded,
        notAllowed,
        unavailable
    }

    export class FileOpenPickerUI implements Windows.Storage.Pickers.Provider.IFileOpenPickerUI {
        addFile(id: string, file: Windows.Storage.IStorageFile): Windows.Storage.Pickers.Provider.AddFileResult;
        removeFile(id: string): void;
        containsFile(id: string): boolean;
        canAddFile(file: Windows.Storage.IStorageFile): boolean;
        add_FileRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_FileRemoved(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closing(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closing(token: Windows.Foundation.EventRegistrationToken): void;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.Storage.Pickers.Provider.FileSelectionMode;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        removeEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        onclosing: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>) => void;
        addEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        removeEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        onfileremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>) => void;

    }

    export class FileRemovedEventArgs implements Windows.Storage.Pickers.Provider.IFileRemovedEventArgs {
        id: string;
    }

    export class FileSavePickerUI implements Windows.Storage.Pickers.Provider.IFileSavePickerUI {
        trySetFileName(value: string): Windows.Storage.Pickers.Provider.SetFileNameResult;
        add_FileNameChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): Windows.Foundation.EventRegistrationToken;
        remove_FileNameChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_TargetFileRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TargetFileRequested(token: Windows.Foundation.EventRegistrationToken): void;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        fileName: string;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        removeEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        onfilenamechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>) => void;
        addEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        removeEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        ontargetfilerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>) => void;

    }

    enum FileSelectionMode {
        single,
        multiple
    }

    export interface IFileOpenPickerUI {
        addFile(id: string, file: Windows.Storage.IStorageFile): Windows.Storage.Pickers.Provider.AddFileResult;
        removeFile(id: string): void;
        containsFile(id: string): boolean;
        canAddFile(file: Windows.Storage.IStorageFile): boolean;
        add_FileRemoved(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_FileRemoved(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closing(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closing(token: Windows.Foundation.EventRegistrationToken): void;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        selectionMode: Windows.Storage.Pickers.Provider.FileSelectionMode;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        removeEventListener(eventName: "closing", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>): void;
        onclosing: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.PickerClosingEventArgs>) => void;
        addEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        removeEventListener(eventName: "fileremoved", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>): void;
        onfileremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileOpenPickerUI,Windows.Storage.Pickers.Provider.FileRemovedEventArgs>) => void;

    }

    export interface IFileRemovedEventArgs {
        id: string;
    }

    export interface IFileSavePickerUI {
        trySetFileName(value: string): Windows.Storage.Pickers.Provider.SetFileNameResult;
        add_FileNameChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): Windows.Foundation.EventRegistrationToken;
        remove_FileNameChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_TargetFileRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TargetFileRequested(token: Windows.Foundation.EventRegistrationToken): void;
        allowedFileTypes: Windows.Foundation.Collections.IVectorView<string>;
        fileName: string;
        settingsIdentifier: string;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        removeEventListener(eventName: "filenamechanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>): void;
        onfilenamechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,any>) => void;
        addEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        removeEventListener(eventName: "targetfilerequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>): void;
        ontargetfilerequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Pickers.Provider.FileSavePickerUI,Windows.Storage.Pickers.Provider.TargetFileRequestedEventArgs>) => void;

    }

    export interface IPickerClosingDeferral {
        complete(): void;
    }

    export interface IPickerClosingEventArgs {
        closingOperation: Windows.Storage.Pickers.Provider.PickerClosingOperation;
        isCanceled: boolean;
    }

    export interface IPickerClosingOperation {
        getDeferral(): Windows.Storage.Pickers.Provider.PickerClosingDeferral;
        deadline: Date;
    }

    export interface ITargetFileRequest {
        getDeferral(): Windows.Storage.Pickers.Provider.TargetFileRequestDeferral;
        targetFile: Windows.Storage.IStorageFile;
    }

    export interface ITargetFileRequestDeferral {
        complete(): void;
    }

    export interface ITargetFileRequestedEventArgs {
        request: Windows.Storage.Pickers.Provider.TargetFileRequest;
    }

    export class PickerClosingDeferral implements Windows.Storage.Pickers.Provider.IPickerClosingDeferral {
        complete(): void;
    }

    export class PickerClosingEventArgs implements Windows.Storage.Pickers.Provider.IPickerClosingEventArgs {
        closingOperation: Windows.Storage.Pickers.Provider.PickerClosingOperation;
        isCanceled: boolean;
    }

    export class PickerClosingOperation implements Windows.Storage.Pickers.Provider.IPickerClosingOperation {
        getDeferral(): Windows.Storage.Pickers.Provider.PickerClosingDeferral;
        deadline: Date;
    }

    enum SetFileNameResult {
        succeeded,
        notAllowed,
        unavailable
    }

    export class TargetFileRequest implements Windows.Storage.Pickers.Provider.ITargetFileRequest {
        getDeferral(): Windows.Storage.Pickers.Provider.TargetFileRequestDeferral;
        targetFile: Windows.Storage.IStorageFile;
    }

    export class TargetFileRequestDeferral implements Windows.Storage.Pickers.Provider.ITargetFileRequestDeferral {
        complete(): void;
    }

    export class TargetFileRequestedEventArgs implements Windows.Storage.Pickers.Provider.ITargetFileRequestedEventArgs {
        request: Windows.Storage.Pickers.Provider.TargetFileRequest;
    }

}
declare module Windows.Storage.Provider {

    enum CachedFileOptions {
        none,
        requireUpdateOnAccess,
        useCachedFileWhenOffline,
        denyAccessWhenOffline
    }

    enum CachedFileTarget {
        local,
        remote
    }

    export class CachedFileUpdater {
        static setUpdateInformation(file: Windows.Storage.IStorageFile, contentId: string, readMode: Windows.Storage.Provider.ReadActivationMode, writeMode: Windows.Storage.Provider.WriteActivationMode, options: Windows.Storage.Provider.CachedFileOptions): void;
    }

    export class CachedFileUpdaterUI implements Windows.Storage.Provider.ICachedFileUpdaterUI {
        add_FileUpdateRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_FileUpdateRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_UIRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): Windows.Foundation.EventRegistrationToken;
        remove_UIRequested(token: Windows.Foundation.EventRegistrationToken): void;
        title: string;
        uIStatus: Windows.Storage.Provider.UIStatus;
        updateTarget: Windows.Storage.Provider.CachedFileTarget;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        removeEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        onfileupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>) => void;
        addEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        removeEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        onuirequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>) => void;

    }

    export class FileUpdateRequest implements Windows.Storage.Provider.IFileUpdateRequest {
        getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
        updateLocalFile(value: Windows.Storage.IStorageFile): void;
        contentId: string;
        file: Windows.Storage.StorageFile;
        status: Windows.Storage.Provider.FileUpdateStatus;
    }

    export class FileUpdateRequestDeferral implements Windows.Storage.Provider.IFileUpdateRequestDeferral {
        complete(): void;
    }

    export class FileUpdateRequestedEventArgs implements Windows.Storage.Provider.IFileUpdateRequestedEventArgs {
        request: Windows.Storage.Provider.FileUpdateRequest;
    }

    enum FileUpdateStatus {
        incomplete,
        complete,
        userInputNeeded,
        currentlyUnavailable,
        failed,
        completeAndRenamed
    }

    export interface ICachedFileUpdaterUI {
        add_FileUpdateRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_FileUpdateRequested(token: Windows.Foundation.EventRegistrationToken): void;
        add_UIRequested(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): Windows.Foundation.EventRegistrationToken;
        remove_UIRequested(token: Windows.Foundation.EventRegistrationToken): void;
        title: string;
        uIStatus: Windows.Storage.Provider.UIStatus;
        updateTarget: Windows.Storage.Provider.CachedFileTarget;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        removeEventListener(eventName: "fileupdaterequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>): void;
        onfileupdaterequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,Windows.Storage.Provider.FileUpdateRequestedEventArgs>) => void;
        addEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        removeEventListener(eventName: "uirequested", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>): void;
        onuirequested: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Provider.CachedFileUpdaterUI,any>) => void;

    }

    export interface IFileUpdateRequest {
        getDeferral(): Windows.Storage.Provider.FileUpdateRequestDeferral;
        updateLocalFile(value: Windows.Storage.IStorageFile): void;
        contentId: string;
        file: Windows.Storage.StorageFile;
        status: Windows.Storage.Provider.FileUpdateStatus;
    }

    export interface IFileUpdateRequestDeferral {
        complete(): void;
    }

    export interface IFileUpdateRequestedEventArgs {
        request: Windows.Storage.Provider.FileUpdateRequest;
    }

    enum ReadActivationMode {
        notNeeded,
        beforeAccess
    }

    enum UIStatus {
        unavailable,
        hidden,
        visible,
        complete
    }

    enum WriteActivationMode {
        readOnly,
        notNeeded,
        afterWrite
    }

}
declare module Windows.Storage.Search {

    enum CommonFileQuery {
        defaultQuery,
        orderByName,
        orderByTitle,
        orderByMusicProperties,
        orderBySearchRank,
        orderByDate
    }

    enum CommonFolderQuery {
        defaultQuery,
        groupByYear,
        groupByMonth,
        groupByArtist,
        groupByAlbum,
        groupByAlbumArtist,
        groupByComposer,
        groupByGenre,
        groupByPublishedYear,
        groupByRating,
        groupByTag,
        groupByAuthor,
        groupByType
    }

    enum DateStackOption {
        none,
        year,
        month
    }

    enum FolderDepth {
        shallow,
        deep
    }

    enum IndexedState {
        unknown,
        notIndexed,
        partiallyIndexed,
        fullyIndexed
    }

    enum IndexerOption {
        useIndexerWhenAvailable,
        onlyUseIndexer,
        doNotUseIndexer
    }

    export interface IQueryOptions {
        saveToString(): string;
        loadFromString(value: string): void;
        setThumbnailPrefetch(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): void;
        setPropertyPrefetch(options: Windows.Storage.FileProperties.PropertyPrefetchOptions, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): void;
        applicationSearchFilter: string;
        dateStackOption: Windows.Storage.Search.DateStackOption;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        folderDepth: Windows.Storage.Search.FolderDepth;
        groupPropertyName: string;
        indexerOption: Windows.Storage.Search.IndexerOption;
        language: string;
        sortOrder: Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>;
        userSearchFilter: string;
    }

    export interface IStorageFileQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getFilesAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
    }

    export interface IStorageFolderQueryOperations {
        getIndexedStateAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Search.IndexedState>;
        createFileQuery(): Windows.Storage.Search.StorageFileQueryResult;
        createFileQuery(query: Windows.Storage.Search.CommonFileQuery): Windows.Storage.Search.StorageFileQueryResult;
        createFileQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFileQueryResult;
        createFolderQuery(): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQuery(query: Windows.Storage.Search.CommonFolderQuery): Windows.Storage.Search.StorageFolderQueryResult;
        createFolderQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageFolderQueryResult;
        createItemQuery(): Windows.Storage.Search.StorageItemQueryResult;
        createItemQueryWithOptions(queryOptions: Windows.Storage.Search.QueryOptions): Windows.Storage.Search.StorageItemQueryResult;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(query: Windows.Storage.Search.CommonFileQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery, startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(query: Windows.Storage.Search.CommonFolderQuery): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemsAsync(startIndex: number, maxItemsToRetrieve: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        areQueryOptionsSupported(queryOptions: Windows.Storage.Search.QueryOptions): boolean;
        isCommonFolderQuerySupported(query: Windows.Storage.Search.CommonFolderQuery): boolean;
        isCommonFileQuerySupported(query: Windows.Storage.Search.CommonFileQuery): boolean;
    }

    export interface IStorageFolderQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getFoldersAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
    }

    export interface IStorageItemQueryResult extends Windows.Storage.Search.IStorageQueryResultBase {
        getItemsAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
    }

    export interface IStorageQueryResultBase {
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        add_ContentsChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_ContentsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_OptionsChanged(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_OptionsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class QueryOptions implements Windows.Storage.Search.IQueryOptions {
        constructor(query: Windows.Storage.Search.CommonFileQuery, fileTypeFilter: Windows.Foundation.Collections.IIterable<string>);
        constructor(query: Windows.Storage.Search.CommonFolderQuery);
        constructor();
        saveToString(): string;
        loadFromString(value: string): void;
        setThumbnailPrefetch(mode: Windows.Storage.FileProperties.ThumbnailMode, requestedSize: number, options: Windows.Storage.FileProperties.ThumbnailOptions): void;
        setPropertyPrefetch(options: Windows.Storage.FileProperties.PropertyPrefetchOptions, propertiesToRetrieve: Windows.Foundation.Collections.IIterable<string>): void;
        applicationSearchFilter: string;
        dateStackOption: Windows.Storage.Search.DateStackOption;
        fileTypeFilter: Windows.Foundation.Collections.IVector<string>;
        folderDepth: Windows.Storage.Search.FolderDepth;
        groupPropertyName: string;
        indexerOption: Windows.Storage.Search.IndexerOption;
        language: string;
        sortOrder: Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>;
        userSearchFilter: string;
    }

    export class SortEntry {
        propertyName: string;
        ascendingOrder: boolean;
    }

    export class SortEntryVector implements Windows.Foundation.Collections.IVector<Windows.Storage.Search.SortEntry>, Windows.Foundation.Collections.IIterable<Windows.Storage.Search.SortEntry> {
        getAt(index: number): Windows.Storage.Search.SortEntry;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.Storage.Search.SortEntry>;
        indexOf(value: Windows.Storage.Search.SortEntry): SortEntryVector_indexOf_OUT;
        setAt(index: number, value: Windows.Storage.Search.SortEntry): void;
        insertAt(index: number, value: Windows.Storage.Search.SortEntry): void;
        removeAt(index: number): void;
        append(value: Windows.Storage.Search.SortEntry): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): SortEntryVector_getMany_OUT;
        replaceAll(items: Windows.Storage.Search.SortEntry[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Storage.Search.SortEntry>;
        size: number;
    }

    interface SortEntryVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface SortEntryVector_getMany_OUT {
        __returnValue: number;
        items: Windows.Storage.Search.SortEntry[];
    }

    export class StorageFileQueryResult implements Windows.Storage.Search.IStorageFileQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getFilesAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getFilesAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFile>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        add_ContentsChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_ContentsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_OptionsChanged(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_OptionsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class StorageFolderQueryResult implements Windows.Storage.Search.IStorageFolderQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getFoldersAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getFoldersAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.StorageFolder>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        add_ContentsChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_ContentsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_OptionsChanged(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_OptionsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

    export class StorageItemQueryResult implements Windows.Storage.Search.IStorageItemQueryResult, Windows.Storage.Search.IStorageQueryResultBase {
        getItemsAsync(startIndex: number, maxNumberOfItems: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>>;
        getItemCountAsync(): Windows.Foundation.IAsyncOperation<number>;
        add_ContentsChanged(handler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_ContentsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        add_OptionsChanged(changedHandler: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): Windows.Foundation.EventRegistrationToken;
        remove_OptionsChanged(eventCookie: Windows.Foundation.EventRegistrationToken): void;
        findStartIndexAsync(value: any): Windows.Foundation.IAsyncOperation<number>;
        getCurrentQueryOptions(): Windows.Storage.Search.QueryOptions;
        applyNewQueryOptions(newQueryOptions: Windows.Storage.Search.QueryOptions): void;
        folder: Windows.Storage.StorageFolder;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "contentschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        oncontentschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;
        addEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        removeEventListener(eventName: "optionschanged", listener: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>): void;
        onoptionschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.Storage.Search.IStorageQueryResultBase,any>) => void;

    }

}
declare module Windows.Storage.Streams {

    export class Buffer implements Windows.Storage.Streams.IBuffer {
        constructor(capacity: number);
        capacity: number;
        length: number;
    }

    enum ByteOrder {
        littleEndian,
        bigEndian
    }

    export class DataReader implements Windows.Storage.Streams.IDataReader, Windows.Foundation.IClosable {
        constructor(inputStream: Windows.Storage.Streams.IInputStream);
        readByte(): number;
        readBytes(): DataReader_readBytes_OUT;
        readBuffer(length: number): Windows.Storage.Streams.IBuffer;
        readBoolean(): boolean;
        readGuid(): string;
        readInt16(): number;
        readInt32(): number;
        readInt64(): number;
        readUInt16(): number;
        readUInt32(): number;
        readUInt64(): number;
        readSingle(): number;
        readDouble(): number;
        readString(codeUnitCount: number): string;
        readDateTime(): Date;
        readTimeSpan(): Windows.Foundation.TimeSpan;
        loadAsync(count: number): Windows.Storage.Streams.DataReaderLoadOperation;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IInputStream;
        close(): void;
        static fromBuffer(buffer: Windows.Storage.Streams.IBuffer): Windows.Storage.Streams.DataReader;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        inputStreamOptions: Windows.Storage.Streams.InputStreamOptions;
        unconsumedBufferLength: number;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
    }

    interface DataReader_readBytes_OUT {
        value: any;
    }

    export class DataReaderLoadOperation implements Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.IAsyncInfo {
        getResults(): number;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: number) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class DataWriter implements Windows.Storage.Streams.IDataWriter, Windows.Foundation.IClosable {
        constructor(outputStream: Windows.Storage.Streams.IOutputStream);
        constructor();
        writeByte(value: number): void;
        writeBytes(value: any): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer, start: number, count: number): void;
        writeBoolean(value: boolean): void;
        writeGuid(value: string): void;
        writeInt16(value: number): void;
        writeInt32(value: number): void;
        writeInt64(value: number): void;
        writeUInt16(value: number): void;
        writeUInt32(value: number): void;
        writeUInt64(value: number): void;
        writeSingle(value: number): void;
        writeDouble(value: number): void;
        writeDateTime(value: Date): void;
        writeTimeSpan(value: Windows.Foundation.TimeSpan): void;
        writeString(value: string): number;
        measureString(value: string): number;
        storeAsync(): Windows.Storage.Streams.DataWriterStoreOperation;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        close(): void;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
        unstoredBufferLength: number;
    }

    export class DataWriterStoreOperation implements Windows.Foundation.IAsyncOperation<number>, Windows.Foundation.IAsyncInfo {
        getResults(): number;
        cancel(): void;
        close(): void;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<number>;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;

        // Promise Extension
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: number) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: number) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export class FileInputStream implements Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export class FileOutputStream implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class FileRandomAccessStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export interface IBuffer {
        capacity: number;
        length: number;
    }

    export interface IBufferFactory {
        create(capacity: number): Windows.Storage.Streams.Buffer;
    }

    export interface IContentTypeProvider {
        contentType: string;
    }

    export interface IDataReader {
        readByte(): number;
        readBytes(): IDataReader_readBytes_OUT;
        readBuffer(length: number): Windows.Storage.Streams.IBuffer;
        readBoolean(): boolean;
        readGuid(): string;
        readInt16(): number;
        readInt32(): number;
        readInt64(): number;
        readUInt16(): number;
        readUInt32(): number;
        readUInt64(): number;
        readSingle(): number;
        readDouble(): number;
        readString(codeUnitCount: number): string;
        readDateTime(): Date;
        readTimeSpan(): Windows.Foundation.TimeSpan;
        loadAsync(count: number): Windows.Storage.Streams.DataReaderLoadOperation;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IInputStream;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        inputStreamOptions: Windows.Storage.Streams.InputStreamOptions;
        unconsumedBufferLength: number;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
    }

    interface IDataReader_readBytes_OUT {
        value: any;
    }

    export interface IDataWriter {
        writeByte(value: number): void;
        writeBytes(value: any): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer): void;
        writeBuffer(buffer: Windows.Storage.Streams.IBuffer, start: number, count: number): void;
        writeBoolean(value: boolean): void;
        writeGuid(value: string): void;
        writeInt16(value: number): void;
        writeInt32(value: number): void;
        writeInt64(value: number): void;
        writeUInt16(value: number): void;
        writeUInt32(value: number): void;
        writeUInt64(value: number): void;
        writeSingle(value: number): void;
        writeDouble(value: number): void;
        writeDateTime(value: Date): void;
        writeTimeSpan(value: Windows.Foundation.TimeSpan): void;
        writeString(value: string): number;
        measureString(value: string): number;
        storeAsync(): Windows.Storage.Streams.DataWriterStoreOperation;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        detachBuffer(): Windows.Storage.Streams.IBuffer;
        detachStream(): Windows.Storage.Streams.IOutputStream;
        byteOrder: Windows.Storage.Streams.ByteOrder;
        unicodeEncoding: Windows.Storage.Streams.UnicodeEncoding;
        unstoredBufferLength: number;
    }

    export interface IInputStream extends Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
    }

    export interface IInputStreamReference {
        openSequentialReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IInputStream>;
    }

    export class InMemoryRandomAccessStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        constructor();
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    enum InputStreamOptions {
        none,
        partial,
        readAhead
    }

    export class InputStreamOverStream implements Windows.Storage.Streams.IInputStream, Windows.Foundation.IClosable {
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        close(): void;
    }

    export interface IOutputStream extends Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export interface IRandomAccessStream extends Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export interface IRandomAccessStreamReference {
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
    }

    export interface IRandomAccessStreamWithContentType extends Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream, Windows.Storage.Streams.IContentTypeProvider {
    }

    export class OutputStreamOverStream implements Windows.Storage.Streams.IOutputStream, Windows.Foundation.IClosable {
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        close(): void;
    }

    export class RandomAccessStream {
        static copyAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        static copyAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream, bytesToCopy: number): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        static copyAndCloseAsync(source: Windows.Storage.Streams.IInputStream, destination: Windows.Storage.Streams.IOutputStream): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
    }

    export class RandomAccessStreamOverStream implements Windows.Storage.Streams.IRandomAccessStream, Windows.Foundation.IClosable, Windows.Storage.Streams.IInputStream, Windows.Storage.Streams.IOutputStream {
        getInputStreamAt(position: number): Windows.Storage.Streams.IInputStream;
        getOutputStreamAt(position: number): Windows.Storage.Streams.IOutputStream;
        seek(position: number): void;
        cloneStream(): Windows.Storage.Streams.IRandomAccessStream;
        close(): void;
        readAsync(buffer: Windows.Storage.Streams.IBuffer, count: number, options: Windows.Storage.Streams.InputStreamOptions): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IBuffer,number>;
        writeAsync(buffer: Windows.Storage.Streams.IBuffer): Windows.Foundation.IAsyncOperationWithProgress<number,number>;
        flushAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        canRead: boolean;
        canWrite: boolean;
        position: number;
        size: number;
    }

    export class RandomAccessStreamReference implements Windows.Storage.Streams.IRandomAccessStreamReference {
        openReadAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamWithContentType>;
        static createFromFile(file: Windows.Storage.IStorageFile): Windows.Storage.Streams.RandomAccessStreamReference;
        static createFromUri(uri: Windows.Foundation.Uri): Windows.Storage.Streams.RandomAccessStreamReference;
        static createFromStream(stream: Windows.Storage.Streams.IRandomAccessStream): Windows.Storage.Streams.RandomAccessStreamReference;
    }

    enum UnicodeEncoding {
        utf8,
        utf16LE,
        utf16BE
    }

}
declare module Windows.System.Display {

    export class DisplayRequest implements Windows.System.Display.IDisplayRequest {
        constructor();
        requestActive(): void;
        requestRelease(): void;
    }

    export interface IDisplayRequest {
        requestActive(): void;
        requestRelease(): void;
    }

}
declare module Windows.System {

    export interface ILauncherOptions {
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export interface ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    export class Launcher {
        static launchFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        static launchFileAsync(file: Windows.Storage.IStorageFile, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export class LauncherOptions implements Windows.System.ILauncherOptions {
        constructor();
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export class LauncherUIOptions implements Windows.System.ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    enum ProcessorArchitecture {
        x86,
        arm,
        x64,
        neutral,
        unknown
    }

    enum VirtualKey {
        none,
        leftButton,
        rightButton,
        cancel,
        middleButton,
        xButton1,
        xButton2,
        back,
        tab,
        clear,
        enter,
        shift,
        control,
        menu,
        pause,
        capitalLock,
        kana,
        hangul,
        junja,
        final,
        hanja,
        kanji,
        escape,
        convert,
        nonConvert,
        accept,
        modeChange,
        space,
        pageUp,
        pageDown,
        end,
        home,
        left,
        up,
        right,
        down,
        select,
        print,
        execute,
        snapshot,
        insert,
        delete,
        help,
        number0,
        number1,
        number2,
        number3,
        number4,
        number5,
        number6,
        number7,
        number8,
        number9,
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z,
        leftWindows,
        rightWindows,
        application,
        sleep,
        numberPad0,
        numberPad1,
        numberPad2,
        numberPad3,
        numberPad4,
        numberPad5,
        numberPad6,
        numberPad7,
        numberPad8,
        numberPad9,
        multiply,
        add,
        separator,
        subtract,
        decimal,
        divide,
        f1,
        f2,
        f3,
        f4,
        f5,
        f6,
        f7,
        f8,
        f9,
        f10,
        f11,
        f12,
        f13,
        f14,
        f15,
        f16,
        f17,
        f18,
        f19,
        f20,
        f21,
        f22,
        f23,
        f24,
        numberKeyLock,
        scroll,
        leftShift,
        rightShift,
        leftControl,
        rightControl,
        leftMenu,
        rightMenu
    }

    enum VirtualKeyModifiers {
        none,
        control,
        menu,
        shift,
        windows
    }

}
declare module Windows.System.Profile {

    export class HardwareIdentification {
        static getPackageSpecificToken(nonce: Windows.Storage.Streams.IBuffer): Windows.System.Profile.HardwareToken;
    }

    export class HardwareToken implements Windows.System.Profile.IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

    export interface IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

}
declare module Windows.System.RemoteDesktop {

    export class InteractiveSession {
        static isRemote: boolean;
    }

}
declare module Windows.System.Threading.Core {

    export interface IPreallocatedWorkItem {
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface ISignalNotifier {
        enable(): void;
        terminate(): void;
    }

    export class PreallocatedWorkItem implements Windows.System.Threading.Core.IPreallocatedWorkItem {
        constructor(handler: Windows.System.Threading.WorkItemHandler);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions);
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface SignalHandler {
        target: Windows.System.Threading.Core.SignalNotifier;
        detail: any[];
        type: string;
    }

    export class SignalNotifier implements Windows.System.Threading.Core.ISignalNotifier {
        enable(): void;
        terminate(): void;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
    }

}
declare module Windows.System.Threading {

    export interface IThreadPoolTimer {
        cancel(): void;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export class ThreadPool {
        static runAsync(handler: Windows.System.Threading.WorkItemHandler): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions): Windows.Foundation.IAsyncAction;
    }

    export class ThreadPoolTimer implements Windows.System.Threading.IThreadPoolTimer {
        cancel(): void;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export interface TimerDestroyedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface TimerElapsedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface WorkItemHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    enum WorkItemOptions {
        none,
        timeSliced
    }

    enum WorkItemPriority {
        low,
        normal,
        high
    }

}
declare module Windows.System.UserProfile {

    enum AccountPictureKind {
        smallImage,
        largeImage,
        video
    }

    export class GlobalizationPreferences {
        static calendars: Windows.Foundation.Collections.IVectorView<string>;
        static clocks: Windows.Foundation.Collections.IVectorView<string>;
        static currencies: Windows.Foundation.Collections.IVectorView<string>;
        static homeGeographicRegion: string;
        static languages: Windows.Foundation.Collections.IVectorView<string>;
        static weekStartsOn: Windows.Globalization.DayOfWeek;
    }

    export class LockScreen {
        static getImageStream(): Windows.Storage.Streams.IRandomAccessStream;
        static setImageFileAsync(value: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static setImageStreamAsync(value: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        static originalImageFile: Windows.Foundation.Uri;
    }

    enum SetAccountPictureResult {
        success,
        changeDisabled,
        largeOrDynamicError,
        videoFrameSizeError,
        fileSizeError,
        failure
    }

    export class UserInformation {
        static getAccountPicture(kind: Windows.System.UserProfile.AccountPictureKind): Windows.Storage.IStorageFile;
        static setAccountPictureAsync(image: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesAsync(smallImage: Windows.Storage.IStorageFile, largeImage: Windows.Storage.IStorageFile, video: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPictureFromStreamAsync(image: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesFromStreamsAsync(smallImage: Windows.Storage.Streams.IRandomAccessStream, largeImage: Windows.Storage.Streams.IRandomAccessStream, video: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static add_AccountPictureChanged(changeHandler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_AccountPictureChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDisplayNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getFirstNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getLastNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getPrincipalNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getSessionInitiationProtocolUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        static getDomainNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static accountPictureChangeEnabled: boolean;
        static nameAccessAllowed: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        onaccountpicturechanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

}
declare module Windows.UI.ApplicationSettings {

    export interface ISettingsPane {
        add_CommandsRequested(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CommandsRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        removeEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        oncommandsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>) => void;

    }

    export interface ISettingsPaneCommandsRequest {
        applicationCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>;
    }

    export interface ISettingsPaneCommandsRequestedEventArgs {
        request: Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest;
    }

    export class SettingsCommand implements Windows.UI.Popups.IUICommand {
        constructor(settingsCommandId: any, label: string, handler: Windows.UI.Popups.UICommandInvokedHandler);
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    enum SettingsEdgeLocation {
        right,
        left
    }

    export class SettingsPane implements Windows.UI.ApplicationSettings.ISettingsPane {
        add_CommandsRequested(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CommandsRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.UI.ApplicationSettings.SettingsPane;
        static show(): void;
        static edge: Windows.UI.ApplicationSettings.SettingsEdgeLocation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        removeEventListener(eventName: "commandsrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>): void;
        oncommandsrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ApplicationSettings.SettingsPane,Windows.UI.ApplicationSettings.SettingsPaneCommandsRequestedEventArgs>) => void;

    }

    export class SettingsPaneCommandsRequest implements Windows.UI.ApplicationSettings.ISettingsPaneCommandsRequest {
        applicationCommands: Windows.Foundation.Collections.IVector<Windows.UI.ApplicationSettings.SettingsCommand>;
    }

    export class SettingsPaneCommandsRequestedEventArgs implements Windows.UI.ApplicationSettings.ISettingsPaneCommandsRequestedEventArgs {
        request: Windows.UI.ApplicationSettings.SettingsPaneCommandsRequest;
    }

}
declare module Windows.UI {

    export class Color {
        a: number;
        r: number;
        g: number;
        b: number;
    }

    export class ColorHelper implements Windows.UI.IColorHelper {
        static fromArgb(a: number, r: number, g: number, b: number): Windows.UI.Color;
    }

    export class Colors implements Windows.UI.IColors {
        static aliceBlue: Windows.UI.Color;
        static antiqueWhite: Windows.UI.Color;
        static aqua: Windows.UI.Color;
        static aquamarine: Windows.UI.Color;
        static azure: Windows.UI.Color;
        static beige: Windows.UI.Color;
        static bisque: Windows.UI.Color;
        static black: Windows.UI.Color;
        static blanchedAlmond: Windows.UI.Color;
        static blue: Windows.UI.Color;
        static blueViolet: Windows.UI.Color;
        static brown: Windows.UI.Color;
        static burlyWood: Windows.UI.Color;
        static cadetBlue: Windows.UI.Color;
        static chartreuse: Windows.UI.Color;
        static chocolate: Windows.UI.Color;
        static coral: Windows.UI.Color;
        static cornflowerBlue: Windows.UI.Color;
        static cornsilk: Windows.UI.Color;
        static crimson: Windows.UI.Color;
        static cyan: Windows.UI.Color;
        static darkBlue: Windows.UI.Color;
        static darkCyan: Windows.UI.Color;
        static darkGoldenrod: Windows.UI.Color;
        static darkGray: Windows.UI.Color;
        static darkGreen: Windows.UI.Color;
        static darkKhaki: Windows.UI.Color;
        static darkMagenta: Windows.UI.Color;
        static darkOliveGreen: Windows.UI.Color;
        static darkOrange: Windows.UI.Color;
        static darkOrchid: Windows.UI.Color;
        static darkRed: Windows.UI.Color;
        static darkSalmon: Windows.UI.Color;
        static darkSeaGreen: Windows.UI.Color;
        static darkSlateBlue: Windows.UI.Color;
        static darkSlateGray: Windows.UI.Color;
        static darkTurquoise: Windows.UI.Color;
        static darkViolet: Windows.UI.Color;
        static deepPink: Windows.UI.Color;
        static deepSkyBlue: Windows.UI.Color;
        static dimGray: Windows.UI.Color;
        static dodgerBlue: Windows.UI.Color;
        static firebrick: Windows.UI.Color;
        static floralWhite: Windows.UI.Color;
        static forestGreen: Windows.UI.Color;
        static fuchsia: Windows.UI.Color;
        static gainsboro: Windows.UI.Color;
        static ghostWhite: Windows.UI.Color;
        static gold: Windows.UI.Color;
        static goldenrod: Windows.UI.Color;
        static gray: Windows.UI.Color;
        static green: Windows.UI.Color;
        static greenYellow: Windows.UI.Color;
        static honeydew: Windows.UI.Color;
        static hotPink: Windows.UI.Color;
        static indianRed: Windows.UI.Color;
        static indigo: Windows.UI.Color;
        static ivory: Windows.UI.Color;
        static khaki: Windows.UI.Color;
        static lavender: Windows.UI.Color;
        static lavenderBlush: Windows.UI.Color;
        static lawnGreen: Windows.UI.Color;
        static lemonChiffon: Windows.UI.Color;
        static lightBlue: Windows.UI.Color;
        static lightCoral: Windows.UI.Color;
        static lightCyan: Windows.UI.Color;
        static lightGoldenrodYellow: Windows.UI.Color;
        static lightGray: Windows.UI.Color;
        static lightGreen: Windows.UI.Color;
        static lightPink: Windows.UI.Color;
        static lightSalmon: Windows.UI.Color;
        static lightSeaGreen: Windows.UI.Color;
        static lightSkyBlue: Windows.UI.Color;
        static lightSlateGray: Windows.UI.Color;
        static lightSteelBlue: Windows.UI.Color;
        static lightYellow: Windows.UI.Color;
        static lime: Windows.UI.Color;
        static limeGreen: Windows.UI.Color;
        static linen: Windows.UI.Color;
        static magenta: Windows.UI.Color;
        static maroon: Windows.UI.Color;
        static mediumAquamarine: Windows.UI.Color;
        static mediumBlue: Windows.UI.Color;
        static mediumOrchid: Windows.UI.Color;
        static mediumPurple: Windows.UI.Color;
        static mediumSeaGreen: Windows.UI.Color;
        static mediumSlateBlue: Windows.UI.Color;
        static mediumSpringGreen: Windows.UI.Color;
        static mediumTurquoise: Windows.UI.Color;
        static mediumVioletRed: Windows.UI.Color;
        static midnightBlue: Windows.UI.Color;
        static mintCream: Windows.UI.Color;
        static mistyRose: Windows.UI.Color;
        static moccasin: Windows.UI.Color;
        static navajoWhite: Windows.UI.Color;
        static navy: Windows.UI.Color;
        static oldLace: Windows.UI.Color;
        static olive: Windows.UI.Color;
        static oliveDrab: Windows.UI.Color;
        static orange: Windows.UI.Color;
        static orangeRed: Windows.UI.Color;
        static orchid: Windows.UI.Color;
        static paleGoldenrod: Windows.UI.Color;
        static paleGreen: Windows.UI.Color;
        static paleTurquoise: Windows.UI.Color;
        static paleVioletRed: Windows.UI.Color;
        static papayaWhip: Windows.UI.Color;
        static peachPuff: Windows.UI.Color;
        static peru: Windows.UI.Color;
        static pink: Windows.UI.Color;
        static plum: Windows.UI.Color;
        static powderBlue: Windows.UI.Color;
        static purple: Windows.UI.Color;
        static red: Windows.UI.Color;
        static rosyBrown: Windows.UI.Color;
        static royalBlue: Windows.UI.Color;
        static saddleBrown: Windows.UI.Color;
        static salmon: Windows.UI.Color;
        static sandyBrown: Windows.UI.Color;
        static seaGreen: Windows.UI.Color;
        static seaShell: Windows.UI.Color;
        static sienna: Windows.UI.Color;
        static silver: Windows.UI.Color;
        static skyBlue: Windows.UI.Color;
        static slateBlue: Windows.UI.Color;
        static slateGray: Windows.UI.Color;
        static snow: Windows.UI.Color;
        static springGreen: Windows.UI.Color;
        static steelBlue: Windows.UI.Color;
        static tan: Windows.UI.Color;
        static teal: Windows.UI.Color;
        static thistle: Windows.UI.Color;
        static tomato: Windows.UI.Color;
        static transparent: Windows.UI.Color;
        static turquoise: Windows.UI.Color;
        static violet: Windows.UI.Color;
        static wheat: Windows.UI.Color;
        static white: Windows.UI.Color;
        static whiteSmoke: Windows.UI.Color;
        static yellow: Windows.UI.Color;
        static yellowGreen: Windows.UI.Color;
    }

    export interface IColorHelper {
    }

    export interface IColors {
    }

}
declare module Windows.UI.Core {

    export class AcceleratorKeyEventArgs implements Windows.UI.Core.IAcceleratorKeyEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        eventType: Windows.UI.Core.CoreAcceleratorKeyEventType;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
        handled: boolean;
    }

    export class AutomationProviderRequestedEventArgs implements Windows.UI.Core.IAutomationProviderRequestedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        automationProvider: any;
        handled: boolean;
    }

    export class CharacterReceivedEventArgs implements Windows.UI.Core.ICharacterReceivedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        keyCode: number;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        handled: boolean;
    }

    enum CoreAcceleratorKeyEventType {
        keyDown,
        keyUp,
        character,
        deadCharacter,
        systemKeyDown,
        systemKeyUp,
        systemCharacter,
        systemDeadCharacter,
        unicodeCharacter
    }

    export class CoreAcceleratorKeys implements Windows.UI.Core.ICoreAcceleratorKeys {
        add_AcceleratorKeyActivated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AcceleratorKeyActivated(cookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    export class CoreCursor implements Windows.UI.Core.ICoreCursor {
        constructor(type: Windows.UI.Core.CoreCursorType, id: number);
        id: number;
        type: Windows.UI.Core.CoreCursorType;
    }

    enum CoreCursorType {
        arrow,
        cross,
        custom,
        hand,
        help,
        iBeam,
        sizeAll,
        sizeNortheastSouthwest,
        sizeNorthSouth,
        sizeNorthwestSoutheast,
        sizeWestEast,
        universalNo,
        upArrow,
        wait
    }

    export class CoreDispatcher implements Windows.UI.Core.ICoreDispatcher, Windows.UI.Core.ICoreAcceleratorKeys {
        processEvents(options: Windows.UI.Core.CoreProcessEventsOption): void;
        runAsync(priority: Windows.UI.Core.CoreDispatcherPriority, agileCallback: Windows.UI.Core.DispatchedHandler): Windows.Foundation.IAsyncAction;
        runIdleAsync(agileCallback: Windows.UI.Core.IdleDispatchedHandler): Windows.Foundation.IAsyncAction;
        add_AcceleratorKeyActivated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AcceleratorKeyActivated(cookie: Windows.Foundation.EventRegistrationToken): void;
        hasThreadAccess: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    enum CoreDispatcherPriority {
        low,
        normal,
        high
    }

    export class CorePhysicalKeyStatus {
        repeatCount: number;
        scanCode: number;
        isExtendedKey: boolean;
        isMenuKeyDown: boolean;
        wasKeyDown: boolean;
        isKeyReleased: boolean;
    }

    enum CoreProcessEventsOption {
        processOneAndAllPending,
        processOneIfPresent,
        processUntilQuit,
        processAllIfPresent
    }

    export class CoreProximityEvaluation {
        score: number;
        adjustedPoint: Windows.Foundation.Point;
    }

    enum CoreProximityEvaluationScore {
        closest,
        farthest
    }

    enum CoreVirtualKeyStates {
        none,
        down,
        locked
    }

    export class CoreWindow implements Windows.UI.Core.ICoreWindow {
        activate(): void;
        close(): void;
        getAsyncKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        getKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        releasePointerCapture(): void;
        setPointerCapture(): void;
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AutomationProviderRequested(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AutomationProviderRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_CharacterReceived(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CharacterReceived(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_InputEnabled(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_InputEnabled(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_KeyDown(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_KeyDown(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_KeyUp(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_KeyUp(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCaptureLost(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerCaptureLost(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerEntered(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerEntered(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerExited(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerExited(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerMoved(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerMoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerPressed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerReleased(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerReleased(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_TouchHitTesting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TouchHitTesting(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerWheelChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerWheelChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_VisibilityChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentThread(): Windows.UI.Core.CoreWindow;
        automationHostProvider: any;
        bounds: Windows.Foundation.Rect;
        customProperties: Windows.Foundation.Collections.IPropertySet;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        flowDirection: Windows.UI.Core.CoreWindowFlowDirection;
        isInputEnabled: boolean;
        pointerCursor: Windows.UI.Core.CoreCursor;
        pointerPosition: Windows.Foundation.Point;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>) => void;
        addEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        removeEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        onautomationproviderrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>) => void;
        addEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        removeEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        oncharacterreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>) => void;
        addEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        removeEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        oninputenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>) => void;
        addEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeydown: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeyup: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointercapturelost: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerentered: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerexited: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointermoved: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerpressed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerreleased: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerwheelchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        onsizechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>) => void;
        addEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        removeEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        ontouchhittesting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>) => void;

    }

    enum CoreWindowActivationState {
        codeActivated,
        deactivated,
        pointerActivated
    }

    export class CoreWindowDialog implements Windows.UI.Core.ICoreWindowDialog {
        constructor(title: string);
        constructor();
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(cookie: Windows.Foundation.EventRegistrationToken): void;
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export class CoreWindowEventArgs implements Windows.UI.Core.ICoreWindowEventArgs {
        handled: boolean;
    }

    enum CoreWindowFlowDirection {
        leftToRight,
        rightToLeft
    }

    export class CoreWindowFlyout implements Windows.UI.Core.ICoreWindowFlyout {
        constructor(position: Windows.Foundation.Point);
        constructor(position: Windows.Foundation.Point, title: string);
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(cookie: Windows.Foundation.EventRegistrationToken): void;
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export class CoreWindowPopupShowingEventArgs implements Windows.UI.Core.ICoreWindowPopupShowingEventArgs {
        setDesiredSize(value: Windows.Foundation.Size): void;
    }

    export class CoreWindowResizeManager implements Windows.UI.Core.ICoreWindowResizeManager {
        notifyLayoutCompleted(): void;
        static getForCurrentView(): Windows.UI.Core.CoreWindowResizeManager;
    }

    export interface DispatchedHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IAcceleratorKeyEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        eventType: Windows.UI.Core.CoreAcceleratorKeyEventType;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
    }

    export interface IAutomationProviderRequestedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        automationProvider: any;
    }

    export interface ICharacterReceivedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        keyCode: number;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
    }

    export interface ICoreAcceleratorKeys {
        add_AcceleratorKeyActivated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AcceleratorKeyActivated(cookie: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        removeEventListener(eventName: "acceleratorkeyactivated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>): void;
        onacceleratorkeyactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreDispatcher,Windows.UI.Core.AcceleratorKeyEventArgs>) => void;

    }

    export interface ICoreCursor {
        id: number;
        type: Windows.UI.Core.CoreCursorType;
    }

    export interface ICoreDispatcher extends Windows.UI.Core.ICoreAcceleratorKeys {
        processEvents(options: Windows.UI.Core.CoreProcessEventsOption): void;
        runAsync(priority: Windows.UI.Core.CoreDispatcherPriority, agileCallback: Windows.UI.Core.DispatchedHandler): Windows.Foundation.IAsyncAction;
        runIdleAsync(agileCallback: Windows.UI.Core.IdleDispatchedHandler): Windows.Foundation.IAsyncAction;
        hasThreadAccess: boolean;
    }

    export interface ICoreWindow {
        activate(): void;
        close(): void;
        getAsyncKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        getKeyState(virtualKey: Windows.System.VirtualKey): Windows.UI.Core.CoreVirtualKeyStates;
        releasePointerCapture(): void;
        setPointerCapture(): void;
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_AutomationProviderRequested(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_AutomationProviderRequested(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_CharacterReceived(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CharacterReceived(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_InputEnabled(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_InputEnabled(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_KeyDown(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_KeyDown(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_KeyUp(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_KeyUp(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCaptureLost(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerCaptureLost(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerEntered(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerEntered(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerExited(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerExited(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerMoved(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerMoved(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerPressed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerPressed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerReleased(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerReleased(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_TouchHitTesting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_TouchHitTesting(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_PointerWheelChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_PointerWheelChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_VisibilityChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        automationHostProvider: any;
        bounds: Windows.Foundation.Rect;
        customProperties: Windows.Foundation.Collections.IPropertySet;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        flowDirection: Windows.UI.Core.CoreWindowFlowDirection;
        isInputEnabled: boolean;
        pointerCursor: Windows.UI.Core.CoreCursor;
        pointerPosition: Windows.Foundation.Point;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowActivatedEventArgs>) => void;
        addEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        removeEventListener(eventName: "automationproviderrequested", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>): void;
        onautomationproviderrequested: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.AutomationProviderRequestedEventArgs>) => void;
        addEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        removeEventListener(eventName: "characterreceived", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>): void;
        oncharacterreceived: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CharacterReceivedEventArgs>) => void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowEventArgs>) => void;
        addEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        removeEventListener(eventName: "inputenabled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>): void;
        oninputenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.InputEnabledEventArgs>) => void;
        addEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keydown", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeydown: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        removeEventListener(eventName: "keyup", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>): void;
        onkeyup: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.KeyEventArgs>) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointercapturelost: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerentered: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerexited: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointermoved: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerpressed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerreleased: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>): void;
        onpointerwheelchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.PointerEventArgs>) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>): void;
        onsizechanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.WindowSizeChangedEventArgs>) => void;
        addEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        removeEventListener(eventName: "touchhittesting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>): void;
        ontouchhittesting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.TouchHitTestingEventArgs>) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>): void;
        onvisibilitychanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.VisibilityChangedEventArgs>) => void;

    }

    export interface ICoreWindowDialog {
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(cookie: Windows.Foundation.EventRegistrationToken): void;
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export interface ICoreWindowEventArgs {
        handled: boolean;
    }

    export interface ICoreWindowFlyout {
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(cookie: Windows.Foundation.EventRegistrationToken): void;
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        backButtonCommand: Windows.UI.Popups.UICommandInvokedHandler;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        defaultCommandIndex: number;
        isInteractionDelayed: number;
        maxSize: Windows.Foundation.Size;
        minSize: Windows.Foundation.Size;
        title: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Core.CoreWindow,Windows.UI.Core.CoreWindowPopupShowingEventArgs>) => void;

    }

    export interface ICoreWindowPopupShowingEventArgs {
        setDesiredSize(value: Windows.Foundation.Size): void;
    }

    export interface ICoreWindowResizeManager {
        notifyLayoutCompleted(): void;
    }

    export interface IdleDispatchedHandler {
        target: Windows.UI.Core.IdleDispatchedHandlerArgs;
        detail: any[];
        type: string;
    }

    export class IdleDispatchedHandlerArgs implements Windows.UI.Core.IIdleDispatchedHandlerArgs {
        isDispatcherIdle: boolean;
    }

    export interface IIdleDispatchedHandlerArgs {
        isDispatcherIdle: boolean;
    }

    export interface IInitializeWithCoreWindow {
        initialize(window: Windows.UI.Core.CoreWindow): void;
    }

    export interface IInputEnabledEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        inputEnabled: boolean;
    }

    export interface IKeyEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
    }

    export class InputEnabledEventArgs implements Windows.UI.Core.IInputEnabledEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        inputEnabled: boolean;
        handled: boolean;
    }

    export interface IPointerEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        getIntermediatePoints(): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        currentPoint: Windows.UI.Input.PointerPoint;
        keyModifiers: Windows.System.VirtualKeyModifiers;
    }

    export interface ITouchHitTestingEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        evaluateProximity(controlBoundingBox: Windows.Foundation.Rect): Windows.UI.Core.CoreProximityEvaluation;
        evaluateProximity(controlVertices: Windows.Foundation.Point[]): Windows.UI.Core.CoreProximityEvaluation;
        boundingBox: Windows.Foundation.Rect;
        point: Windows.Foundation.Point;
        proximityEvaluation: Windows.UI.Core.CoreProximityEvaluation;
    }

    export interface IVisibilityChangedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        visible: boolean;
    }

    export interface IWindowActivatedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        windowActivationState: Windows.UI.Core.CoreWindowActivationState;
    }

    export interface IWindowSizeChangedEventArgs extends Windows.UI.Core.ICoreWindowEventArgs {
        size: Windows.Foundation.Size;
    }

    export class KeyEventArgs implements Windows.UI.Core.IKeyEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
        virtualKey: Windows.System.VirtualKey;
        handled: boolean;
    }

    export class PointerEventArgs implements Windows.UI.Core.IPointerEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        getIntermediatePoints(): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        currentPoint: Windows.UI.Input.PointerPoint;
        keyModifiers: Windows.System.VirtualKeyModifiers;
        handled: boolean;
    }

    export class TouchHitTestingEventArgs implements Windows.UI.Core.ITouchHitTestingEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        evaluateProximity(controlBoundingBox: Windows.Foundation.Rect): Windows.UI.Core.CoreProximityEvaluation;
        evaluateProximity(controlVertices: Windows.Foundation.Point[]): Windows.UI.Core.CoreProximityEvaluation;
        boundingBox: Windows.Foundation.Rect;
        point: Windows.Foundation.Point;
        proximityEvaluation: Windows.UI.Core.CoreProximityEvaluation;
        handled: boolean;
    }

    export class VisibilityChangedEventArgs implements Windows.UI.Core.IVisibilityChangedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        visible: boolean;
        handled: boolean;
    }

    export class WindowActivatedEventArgs implements Windows.UI.Core.IWindowActivatedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        windowActivationState: Windows.UI.Core.CoreWindowActivationState;
        handled: boolean;
    }

    export class WindowSizeChangedEventArgs implements Windows.UI.Core.IWindowSizeChangedEventArgs, Windows.UI.Core.ICoreWindowEventArgs {
        size: Windows.Foundation.Size;
        handled: boolean;
    }

}
declare module Windows.UI.Core.AnimationMetrics {

    export class AnimationDescription implements Windows.UI.Core.AnimationMetrics.IAnimationDescription {
        constructor(effect: Windows.UI.Core.AnimationMetrics.AnimationEffect, target: Windows.UI.Core.AnimationMetrics.AnimationEffectTarget);
        animations: Windows.Foundation.Collections.IVectorView<Windows.UI.Core.AnimationMetrics.IPropertyAnimation>;
        delayLimit: Windows.Foundation.TimeSpan;
        staggerDelay: Windows.Foundation.TimeSpan;
        staggerDelayFactor: number;
        zOrder: number;
    }

    enum AnimationEffect {
        expand,
        collapse,
        reposition,
        fadeIn,
        fadeOut,
        addToList,
        deleteFromList,
        addToGrid,
        deleteFromGrid,
        addToSearchGrid,
        deleteFromSearchGrid,
        addToSearchList,
        deleteFromSearchList,
        showEdgeUI,
        showPanel,
        hideEdgeUI,
        hidePanel,
        showPopup,
        hidePopup,
        pointerDown,
        pointerUp,
        dragSourceStart,
        dragSourceEnd,
        transitionContent,
        reveal,
        hide,
        dragBetweenEnter,
        dragBetweenLeave,
        swipeSelect,
        swipeDeselect,
        swipeReveal,
        enterPage,
        transitionPage,
        crossFade,
        peek,
        updateBadge
    }

    enum AnimationEffectTarget {
        primary,
        added,
        affected,
        background,
        content,
        deleted,
        deselected,
        dragSource,
        hidden,
        incoming,
        outgoing,
        outline,
        remaining,
        revealed,
        rowIn,
        rowOut,
        selected,
        selection,
        shown,
        tapped
    }

    export interface IAnimationDescription {
        animations: Windows.Foundation.Collections.IVectorView<Windows.UI.Core.AnimationMetrics.IPropertyAnimation>;
        delayLimit: Windows.Foundation.TimeSpan;
        staggerDelay: Windows.Foundation.TimeSpan;
        staggerDelayFactor: number;
        zOrder: number;
    }

    export interface IOpacityAnimation extends Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalOpacity: number;
        initialOpacity: Windows.Foundation.IReference<number>;
    }

    export interface IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export interface IScaleAnimation extends Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalScaleX: number;
        finalScaleY: number;
        initialScaleX: Windows.Foundation.IReference<number>;
        initialScaleY: Windows.Foundation.IReference<number>;
        normalizedOrigin: Windows.Foundation.Point;
    }

    export class OpacityAnimation implements Windows.UI.Core.AnimationMetrics.IOpacityAnimation, Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalOpacity: number;
        initialOpacity: Windows.Foundation.IReference<number>;
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export class PropertyAnimation implements Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    enum PropertyAnimationType {
        scale,
        translation,
        opacity
    }

    export class ScaleAnimation implements Windows.UI.Core.AnimationMetrics.IScaleAnimation, Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        finalScaleX: number;
        finalScaleY: number;
        initialScaleX: Windows.Foundation.IReference<number>;
        initialScaleY: Windows.Foundation.IReference<number>;
        normalizedOrigin: Windows.Foundation.Point;
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

    export class TranslationAnimation implements Windows.UI.Core.AnimationMetrics.IPropertyAnimation {
        control1: Windows.Foundation.Point;
        control2: Windows.Foundation.Point;
        delay: Windows.Foundation.TimeSpan;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Core.AnimationMetrics.PropertyAnimationType;
    }

}
declare module Windows.UI.Input {

    export class CrossSlideThresholds {
        selectionStart: number;
        speedBumpStart: number;
        speedBumpEnd: number;
        rearrangeStart: number;
    }

    export class CrossSlidingEventArgs implements Windows.UI.Input.ICrossSlidingEventArgs {
        crossSlidingState: Windows.UI.Input.CrossSlidingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum CrossSlidingState {
        started,
        dragging,
        selecting,
        selectSpeedBumping,
        speedBumping,
        rearranging,
        completed
    }

    export class DraggingEventArgs implements Windows.UI.Input.IDraggingEventArgs {
        draggingState: Windows.UI.Input.DraggingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum DraggingState {
        started,
        continuing,
        completed
    }

    export class EdgeGesture implements Windows.UI.Input.IEdgeGesture {
        add_Starting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Starting(token: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(token: Windows.Foundation.EventRegistrationToken): void;
        add_Canceled(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Canceled(token: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.UI.Input.EdgeGesture;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncanceled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        onstarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;

    }

    export class EdgeGestureEventArgs implements Windows.UI.Input.IEdgeGestureEventArgs {
        kind: Windows.UI.Input.EdgeGestureKind;
    }

    enum EdgeGestureKind {
        touch,
        keyboard,
        mouse
    }

    export class GestureRecognizer implements Windows.UI.Input.IGestureRecognizer {
        constructor();
        canBeDoubleTap(value: Windows.UI.Input.PointerPoint): boolean;
        processDownEvent(value: Windows.UI.Input.PointerPoint): void;
        processMoveEvents(value: Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>): void;
        processUpEvent(value: Windows.UI.Input.PointerPoint): void;
        processMouseWheelEvent(value: Windows.UI.Input.PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean): void;
        processInertia(): void;
        completeGesture(): void;
        add_Tapped(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Tapped(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_RightTapped(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_RightTapped(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Holding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Holding(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Dragging(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Dragging(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarted(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationUpdated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationUpdated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationInertiaStarting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationInertiaStarting(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationCompleted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_CrossSliding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CrossSliding(cookie: Windows.Foundation.EventRegistrationToken): void;
        autoProcessInertia: boolean;
        crossSlideExact: boolean;
        crossSlideHorizontally: boolean;
        crossSlideThresholds: Windows.UI.Input.CrossSlideThresholds;
        gestureSettings: Windows.UI.Input.GestureSettings;
        inertiaExpansion: number;
        inertiaExpansionDeceleration: number;
        inertiaRotationAngle: number;
        inertiaRotationDeceleration: number;
        inertiaTranslationDeceleration: number;
        inertiaTranslationDisplacement: number;
        isActive: boolean;
        isInertial: boolean;
        manipulationExact: boolean;
        mouseWheelParameters: Windows.UI.Input.MouseWheelParameters;
        pivotCenter: Windows.Foundation.Point;
        pivotRadius: number;
        showGestureFeedback: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        removeEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        oncrosssliding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>) => void;
        addEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        removeEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        ondragging: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>) => void;
        addEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        removeEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        onholding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        onmanipulationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        onmanipulationinertiastarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        onmanipulationstarted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>) => void;
        addEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        removeEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        onmanipulationupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>) => void;
        addEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        removeEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        onrighttapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>) => void;
        addEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        removeEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        ontapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>) => void;

    }

    enum GestureSettings {
        none,
        tap,
        doubleTap,
        hold,
        holdWithMouse,
        rightTap,
        drag,
        manipulationTranslateX,
        manipulationTranslateY,
        manipulationTranslateRailsX,
        manipulationTranslateRailsY,
        manipulationRotate,
        manipulationScale,
        manipulationTranslateInertia,
        manipulationRotateInertia,
        manipulationScaleInertia,
        crossSlide
    }

    export class HoldingEventArgs implements Windows.UI.Input.IHoldingEventArgs {
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    enum HoldingState {
        started,
        completed,
        canceled
    }

    export interface ICrossSlidingEventArgs {
        crossSlidingState: Windows.UI.Input.CrossSlidingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IDraggingEventArgs {
        draggingState: Windows.UI.Input.DraggingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IEdgeGesture {
        add_Starting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Starting(token: Windows.Foundation.EventRegistrationToken): void;
        add_Completed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(token: Windows.Foundation.EventRegistrationToken): void;
        add_Canceled(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Canceled(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "canceled", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncanceled: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        oncompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;
        addEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        removeEventListener(eventName: "starting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>): void;
        onstarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.EdgeGesture,Windows.UI.Input.EdgeGestureEventArgs>) => void;

    }

    export interface IEdgeGestureEventArgs {
        kind: Windows.UI.Input.EdgeGestureKind;
    }

    export interface IGestureRecognizer {
        canBeDoubleTap(value: Windows.UI.Input.PointerPoint): boolean;
        processDownEvent(value: Windows.UI.Input.PointerPoint): void;
        processMoveEvents(value: Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>): void;
        processUpEvent(value: Windows.UI.Input.PointerPoint): void;
        processMouseWheelEvent(value: Windows.UI.Input.PointerPoint, isShiftKeyDown: boolean, isControlKeyDown: boolean): void;
        processInertia(): void;
        completeGesture(): void;
        add_Tapped(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Tapped(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_RightTapped(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_RightTapped(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Holding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Holding(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Dragging(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Dragging(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarted(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationUpdated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationUpdated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationInertiaStarting(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationInertiaStarting(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationCompleted(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationCompleted(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_CrossSliding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_CrossSliding(cookie: Windows.Foundation.EventRegistrationToken): void;
        autoProcessInertia: boolean;
        crossSlideExact: boolean;
        crossSlideHorizontally: boolean;
        crossSlideThresholds: Windows.UI.Input.CrossSlideThresholds;
        gestureSettings: Windows.UI.Input.GestureSettings;
        inertiaExpansion: number;
        inertiaExpansionDeceleration: number;
        inertiaRotationAngle: number;
        inertiaRotationDeceleration: number;
        inertiaTranslationDeceleration: number;
        inertiaTranslationDisplacement: number;
        isActive: boolean;
        isInertial: boolean;
        manipulationExact: boolean;
        mouseWheelParameters: Windows.UI.Input.MouseWheelParameters;
        pivotCenter: Windows.Foundation.Point;
        pivotRadius: number;
        showGestureFeedback: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        removeEventListener(eventName: "crosssliding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>): void;
        oncrosssliding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.CrossSlidingEventArgs>) => void;
        addEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        removeEventListener(eventName: "dragging", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>): void;
        ondragging: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.DraggingEventArgs>) => void;
        addEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        removeEventListener(eventName: "holding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>): void;
        onholding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.HoldingEventArgs>) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>): void;
        onmanipulationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationCompletedEventArgs>) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>): void;
        onmanipulationinertiastarting: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationInertiaStartingEventArgs>) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>): void;
        onmanipulationstarted: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationStartedEventArgs>) => void;
        addEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        removeEventListener(eventName: "manipulationupdated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>): void;
        onmanipulationupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.ManipulationUpdatedEventArgs>) => void;
        addEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        removeEventListener(eventName: "righttapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>): void;
        onrighttapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.RightTappedEventArgs>) => void;
        addEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        removeEventListener(eventName: "tapped", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>): void;
        ontapped: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Input.GestureRecognizer,Windows.UI.Input.TappedEventArgs>) => void;

    }

    export interface IHoldingEventArgs {
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IManipulationCompletedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationInertiaStartingEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationStartedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IManipulationUpdatedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IMouseWheelParameters {
        charTranslation: Windows.Foundation.Point;
        deltaRotationAngle: number;
        deltaScale: number;
        pageTranslation: Windows.Foundation.Point;
    }

    export interface IPointerPoint {
        frameId: number;
        isInContact: boolean;
        pointerDevice: Windows.Devices.Input.PointerDevice;
        pointerId: number;
        position: Windows.Foundation.Point;
        properties: Windows.UI.Input.PointerPointProperties;
        rawPosition: Windows.Foundation.Point;
        timestamp: number;
    }

    export interface IPointerPointProperties {
        hasUsage(usagePage: number, usageId: number): boolean;
        getUsageValue(usagePage: number, usageId: number): number;
        contactRect: Windows.Foundation.Rect;
        contactRectRaw: Windows.Foundation.Rect;
        isBarrelButtonPressed: boolean;
        isCanceled: boolean;
        isEraser: boolean;
        isHorizontalMouseWheel: boolean;
        isInRange: boolean;
        isInverted: boolean;
        isLeftButtonPressed: boolean;
        isMiddleButtonPressed: boolean;
        isPrimary: boolean;
        isRightButtonPressed: boolean;
        isXButton1Pressed: boolean;
        isXButton2Pressed: boolean;
        mouseWheelDelta: number;
        orientation: number;
        pointerUpdateKind: Windows.UI.Input.PointerUpdateKind;
        pressure: number;
        touchConfidence: boolean;
        twist: number;
        xTilt: number;
        yTilt: number;
    }

    export interface IPointerPointTransform {
        tryTransform(inPoint: Windows.Foundation.Point): IPointerPointTransform_tryTransform_OUT;
        transformBounds(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        inverse: Windows.UI.Input.IPointerPointTransform;
    }

    interface IPointerPointTransform_tryTransform_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    export interface IPointerVisualizationSettings {
        isBarrelButtonFeedbackEnabled: boolean;
        isContactFeedbackEnabled: boolean;
    }

    export interface IRightTappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface ITappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        tapCount: number;
    }

    export class ManipulationCompletedEventArgs implements Windows.UI.Input.IManipulationCompletedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationDelta {
        translation: Windows.Foundation.Point;
        scale: number;
        rotation: number;
        expansion: number;
    }

    export class ManipulationInertiaStartingEventArgs implements Windows.UI.Input.IManipulationInertiaStartingEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationStartedEventArgs implements Windows.UI.Input.IManipulationStartedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export class ManipulationUpdatedEventArgs implements Windows.UI.Input.IManipulationUpdatedEventArgs {
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export class ManipulationVelocities {
        linear: Windows.Foundation.Point;
        angular: number;
        expansion: number;
    }

    export class MouseWheelParameters implements Windows.UI.Input.IMouseWheelParameters {
        charTranslation: Windows.Foundation.Point;
        deltaRotationAngle: number;
        deltaScale: number;
        pageTranslation: Windows.Foundation.Point;
    }

    export class PointerPoint implements Windows.UI.Input.IPointerPoint {
        static getCurrentPoint(pointerId: number): Windows.UI.Input.PointerPoint;
        static getIntermediatePoints(pointerId: number): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        static getCurrentPoint(pointerId: number, transform: Windows.UI.Input.IPointerPointTransform): Windows.UI.Input.PointerPoint;
        static getIntermediatePoints(pointerId: number, transform: Windows.UI.Input.IPointerPointTransform): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        frameId: number;
        isInContact: boolean;
        pointerDevice: Windows.Devices.Input.PointerDevice;
        pointerId: number;
        position: Windows.Foundation.Point;
        properties: Windows.UI.Input.PointerPointProperties;
        rawPosition: Windows.Foundation.Point;
        timestamp: number;
    }

    export class PointerPointProperties implements Windows.UI.Input.IPointerPointProperties {
        hasUsage(usagePage: number, usageId: number): boolean;
        getUsageValue(usagePage: number, usageId: number): number;
        contactRect: Windows.Foundation.Rect;
        contactRectRaw: Windows.Foundation.Rect;
        isBarrelButtonPressed: boolean;
        isCanceled: boolean;
        isEraser: boolean;
        isHorizontalMouseWheel: boolean;
        isInRange: boolean;
        isInverted: boolean;
        isLeftButtonPressed: boolean;
        isMiddleButtonPressed: boolean;
        isPrimary: boolean;
        isRightButtonPressed: boolean;
        isXButton1Pressed: boolean;
        isXButton2Pressed: boolean;
        mouseWheelDelta: number;
        orientation: number;
        pointerUpdateKind: Windows.UI.Input.PointerUpdateKind;
        pressure: number;
        touchConfidence: boolean;
        twist: number;
        xTilt: number;
        yTilt: number;
    }

    enum PointerUpdateKind {
        other,
        leftButtonPressed,
        leftButtonReleased,
        rightButtonPressed,
        rightButtonReleased,
        middleButtonPressed,
        middleButtonReleased,
        xButton1Pressed,
        xButton1Released,
        xButton2Pressed,
        xButton2Released
    }

    export class PointerVisualizationSettings implements Windows.UI.Input.IPointerVisualizationSettings {
        static getForCurrentView(): Windows.UI.Input.PointerVisualizationSettings;
        isBarrelButtonFeedbackEnabled: boolean;
        isContactFeedbackEnabled: boolean;
    }

    export class RightTappedEventArgs implements Windows.UI.Input.IRightTappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export class TappedEventArgs implements Windows.UI.Input.ITappedEventArgs {
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        tapCount: number;
    }

}
declare module Windows.UI.Notifications {

    export class BadgeNotification implements Windows.UI.Notifications.IBadgeNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
    }

    enum BadgeTemplateType {
        badgeGlyph,
        badgeNumber
    }

    export class BadgeUpdateManager {
        static createBadgeUpdaterForApplication(): Windows.UI.Notifications.BadgeUpdater;
        static createBadgeUpdaterForApplication(applicationId: string): Windows.UI.Notifications.BadgeUpdater;
        static createBadgeUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.BadgeUpdater;
        static getTemplateContent(type: Windows.UI.Notifications.BadgeTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class BadgeUpdater implements Windows.UI.Notifications.IBadgeUpdater {
        update(notification: Windows.UI.Notifications.BadgeNotification): void;
        clear(): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
    }

    export interface IBadgeNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
    }

    export interface IBadgeUpdater {
        update(notification: Windows.UI.Notifications.BadgeNotification): void;
        clear(): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(badgeContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
    }

    export interface IScheduledTileNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        expirationTime: Windows.Foundation.IReference<Date>;
        id: string;
        tag: string;
    }

    export interface IScheduledToastNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        id: string;
        maximumSnoozeCount: number;
        snoozeInterval: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
    }

    export interface ITileNotification {
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        tag: string;
    }

    export interface ITileUpdater {
        update(notification: Windows.UI.Notifications.TileNotification): void;
        clear(): void;
        enableNotificationQueue(enable: boolean): void;
        addToSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        removeFromSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        getScheduledTileNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledTileNotification>;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    export interface IToastDismissedEventArgs {
        reason: Windows.UI.Notifications.ToastDismissalReason;
    }

    export interface IToastFailedEventArgs {
        errorCode: Windows.Foundation.HResult;
    }

    export interface IToastNotification {
        add_Dismissed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Dismissed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Failed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Failed(token: Windows.Foundation.EventRegistrationToken): void;
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>) => void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>) => void;
        addEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        removeEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        onfailed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>) => void;

    }

    export interface IToastNotifier {
        show(notification: Windows.UI.Notifications.ToastNotification): void;
        hide(notification: Windows.UI.Notifications.ToastNotification): void;
        addToSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        removeFromSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        getScheduledToastNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledToastNotification>;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum NotificationSetting {
        enabled,
        disabledForApplication,
        disabledForUser,
        disabledByGroupPolicy,
        disabledByManifest
    }

    enum PeriodicUpdateRecurrence {
        halfHour,
        hour,
        sixHours,
        twelveHours,
        daily
    }

    export class ScheduledTileNotification implements Windows.UI.Notifications.IScheduledTileNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date);
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        expirationTime: Windows.Foundation.IReference<Date>;
        id: string;
        tag: string;
    }

    export class ScheduledToastNotification implements Windows.UI.Notifications.IScheduledToastNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date);
        constructor(content: Windows.Data.Xml.Dom.XmlDocument, deliveryTime: Date, snoozeInterval: Windows.Foundation.TimeSpan, maximumSnoozeCount: number);
        content: Windows.Data.Xml.Dom.XmlDocument;
        deliveryTime: Date;
        id: string;
        maximumSnoozeCount: number;
        snoozeInterval: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
    }

    export class TileNotification implements Windows.UI.Notifications.ITileNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        tag: string;
    }

    enum TileTemplateType {
        tileSquareImage,
        tileSquareBlock,
        tileSquareText01,
        tileSquareText02,
        tileSquareText03,
        tileSquareText04,
        tileSquarePeekImageAndText01,
        tileSquarePeekImageAndText02,
        tileSquarePeekImageAndText03,
        tileSquarePeekImageAndText04,
        tileWideImage,
        tileWideImageCollection,
        tileWideImageAndText01,
        tileWideImageAndText02,
        tileWideBlockAndText01,
        tileWideBlockAndText02,
        tileWidePeekImageCollection01,
        tileWidePeekImageCollection02,
        tileWidePeekImageCollection03,
        tileWidePeekImageCollection04,
        tileWidePeekImageCollection05,
        tileWidePeekImageCollection06,
        tileWidePeekImageAndText01,
        tileWidePeekImageAndText02,
        tileWidePeekImage01,
        tileWidePeekImage02,
        tileWidePeekImage03,
        tileWidePeekImage04,
        tileWidePeekImage05,
        tileWidePeekImage06,
        tileWideSmallImageAndText01,
        tileWideSmallImageAndText02,
        tileWideSmallImageAndText03,
        tileWideSmallImageAndText04,
        tileWideSmallImageAndText05,
        tileWideText01,
        tileWideText02,
        tileWideText03,
        tileWideText04,
        tileWideText05,
        tileWideText06,
        tileWideText07,
        tileWideText08,
        tileWideText09,
        tileWideText10,
        tileWideText11
    }

    export class TileUpdateManager {
        static createTileUpdaterForApplication(): Windows.UI.Notifications.TileUpdater;
        static createTileUpdaterForApplication(applicationId: string): Windows.UI.Notifications.TileUpdater;
        static createTileUpdaterForSecondaryTile(tileId: string): Windows.UI.Notifications.TileUpdater;
        static getTemplateContent(type: Windows.UI.Notifications.TileTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class TileUpdater implements Windows.UI.Notifications.ITileUpdater {
        update(notification: Windows.UI.Notifications.TileNotification): void;
        clear(): void;
        enableNotificationQueue(enable: boolean): void;
        addToSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        removeFromSchedule(scheduledTile: Windows.UI.Notifications.ScheduledTileNotification): void;
        getScheduledTileNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledTileNotification>;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdate(tileContent: Windows.Foundation.Uri, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        stopPeriodicUpdate(): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        startPeriodicUpdateBatch(tileContents: Windows.Foundation.Collections.IIterable<Windows.Foundation.Uri>, startTime: Date, requestedInterval: Windows.UI.Notifications.PeriodicUpdateRecurrence): void;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum ToastDismissalReason {
        userCanceled,
        applicationHidden,
        timedOut
    }

    export class ToastDismissedEventArgs implements Windows.UI.Notifications.IToastDismissedEventArgs {
        reason: Windows.UI.Notifications.ToastDismissalReason;
    }

    export class ToastFailedEventArgs implements Windows.UI.Notifications.IToastFailedEventArgs {
        errorCode: Windows.Foundation.HResult;
    }

    export class ToastNotification implements Windows.UI.Notifications.IToastNotification {
        constructor(content: Windows.Data.Xml.Dom.XmlDocument);
        add_Dismissed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Dismissed(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Activated(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): Windows.Foundation.EventRegistrationToken;
        remove_Activated(cookie: Windows.Foundation.EventRegistrationToken): void;
        add_Failed(handler: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Failed(token: Windows.Foundation.EventRegistrationToken): void;
        content: Windows.Data.Xml.Dom.XmlDocument;
        expirationTime: Windows.Foundation.IReference<Date>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        removeEventListener(eventName: "activated", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>): void;
        onactivated: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,any>) => void;
        addEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        removeEventListener(eventName: "dismissed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>): void;
        ondismissed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastDismissedEventArgs>) => void;
        addEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        removeEventListener(eventName: "failed", listener: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>): void;
        onfailed: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.Notifications.ToastNotification,Windows.UI.Notifications.ToastFailedEventArgs>) => void;

    }

    export class ToastNotificationManager {
        static createToastNotifier(): Windows.UI.Notifications.ToastNotifier;
        static createToastNotifier(applicationId: string): Windows.UI.Notifications.ToastNotifier;
        static getTemplateContent(type: Windows.UI.Notifications.ToastTemplateType): Windows.Data.Xml.Dom.XmlDocument;
    }

    export class ToastNotifier implements Windows.UI.Notifications.IToastNotifier {
        show(notification: Windows.UI.Notifications.ToastNotification): void;
        hide(notification: Windows.UI.Notifications.ToastNotification): void;
        addToSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        removeFromSchedule(scheduledToast: Windows.UI.Notifications.ScheduledToastNotification): void;
        getScheduledToastNotifications(): Windows.Foundation.Collections.IVectorView<Windows.UI.Notifications.ScheduledToastNotification>;
        setting: Windows.UI.Notifications.NotificationSetting;
    }

    enum ToastTemplateType {
        toastImageAndText01,
        toastImageAndText02,
        toastImageAndText03,
        toastImageAndText04,
        toastText01,
        toastText02,
        toastText03,
        toastText04
    }

}
declare module Windows.UI.Popups {

    export interface IMessageDialog {
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        content: string;
        defaultCommandIndex: number;
        options: Windows.UI.Popups.MessageDialogOptions;
        title: string;
    }

    export interface IPopupMenu {
        showAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
    }

    export interface IUICommand {
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    export class MessageDialog implements Windows.UI.Popups.IMessageDialog {
        constructor(content: string);
        constructor(content: string, title: string);
        showAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        cancelCommandIndex: number;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
        content: string;
        defaultCommandIndex: number;
        options: Windows.UI.Popups.MessageDialogOptions;
        title: string;
    }

    enum MessageDialogOptions {
        none,
        acceptUserInputAfterDelay
    }

    enum Placement {
        default,
        above,
        below,
        left,
        right
    }

    export class PopupMenu implements Windows.UI.Popups.IPopupMenu {
        constructor();
        showAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        showForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<Windows.UI.Popups.IUICommand>;
        commands: Windows.Foundation.Collections.IVector<Windows.UI.Popups.IUICommand>;
    }

    export class UICommand implements Windows.UI.Popups.IUICommand {
        constructor(label: string);
        constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler);
        constructor(label: string, action: Windows.UI.Popups.UICommandInvokedHandler, commandId: any);
        constructor();
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

    export interface UICommandInvokedHandler {
        target: Windows.UI.Popups.IUICommand;
        detail: any[];
        type: string;
    }

    export class UICommandSeparator implements Windows.UI.Popups.IUICommand {
        constructor();
        id: any;
        invoked: Windows.UI.Popups.UICommandInvokedHandler;
        label: string;
    }

}
declare module Windows.UI.StartScreen {

    enum ForegroundText {
        dark,
        light
    }

    export interface ISecondaryTile {
        requestCreateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        updateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        arguments: string;
        backgroundColor: Windows.UI.Color;
        displayName: string;
        foregroundText: Windows.UI.StartScreen.ForegroundText;
        lockScreenBadgeLogo: Windows.Foundation.Uri;
        lockScreenDisplayBadgeAndTileText: boolean;
        logo: Windows.Foundation.Uri;
        shortName: string;
        smallLogo: Windows.Foundation.Uri;
        tileId: string;
        tileOptions: Windows.UI.StartScreen.TileOptions;
        wideLogo: Windows.Foundation.Uri;
    }

    export class SecondaryTile implements Windows.UI.StartScreen.ISecondaryTile {
        constructor(tileId: string, shortName: string, displayName: string, arguments: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri);
        constructor(tileId: string, shortName: string, displayName: string, arguments: string, tileOptions: Windows.UI.StartScreen.TileOptions, logoReference: Windows.Foundation.Uri, wideLogoReference: Windows.Foundation.Uri);
        constructor(tileId: string);
        constructor();
        requestCreateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestCreateForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteAsync(invocationPoint: Windows.Foundation.Point): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect): Windows.Foundation.IAsyncOperation<boolean>;
        requestDeleteForSelectionAsync(selection: Windows.Foundation.Rect, preferredPlacement: Windows.UI.Popups.Placement): Windows.Foundation.IAsyncOperation<boolean>;
        updateAsync(): Windows.Foundation.IAsyncOperation<boolean>;
        static exists(tileId: string): boolean;
        static findAllAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        static findAllAsync(applicationId: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        static findAllForPackageAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.UI.StartScreen.SecondaryTile>>;
        arguments: string;
        backgroundColor: Windows.UI.Color;
        displayName: string;
        foregroundText: Windows.UI.StartScreen.ForegroundText;
        lockScreenBadgeLogo: Windows.Foundation.Uri;
        lockScreenDisplayBadgeAndTileText: boolean;
        logo: Windows.Foundation.Uri;
        shortName: string;
        smallLogo: Windows.Foundation.Uri;
        tileId: string;
        tileOptions: Windows.UI.StartScreen.TileOptions;
        wideLogo: Windows.Foundation.Uri;
    }

    enum TileOptions {
        none,
        showNameOnLogo,
        showNameOnWideLogo,
        copyOnDeployment
    }

}
declare module Windows.UI.Text {

    enum CaretType {
        normal,
        null
    }

    enum FindOptions {
        none,
        word,
        case
    }

    enum FontStretch {
        undefined,
        ultraCondensed,
        extraCondensed,
        condensed,
        semiCondensed,
        normal,
        semiExpanded,
        expanded,
        extraExpanded,
        ultraExpanded
    }

    enum FontStyle {
        normal,
        oblique,
        italic
    }

    export class FontWeight {
        weight: number;
    }

    export class FontWeights implements Windows.UI.Text.IFontWeights {
        static black: Windows.UI.Text.FontWeight;
        static bold: Windows.UI.Text.FontWeight;
        static extraBlack: Windows.UI.Text.FontWeight;
        static extraBold: Windows.UI.Text.FontWeight;
        static extraLight: Windows.UI.Text.FontWeight;
        static light: Windows.UI.Text.FontWeight;
        static medium: Windows.UI.Text.FontWeight;
        static normal: Windows.UI.Text.FontWeight;
        static semiBold: Windows.UI.Text.FontWeight;
        static semiLight: Windows.UI.Text.FontWeight;
        static thin: Windows.UI.Text.FontWeight;
    }

    enum FormatEffect {
        off,
        on,
        toggle,
        undefined
    }

    enum HorizontalCharacterAlignment {
        left,
        right,
        center
    }

    export interface IFontWeights {
    }

    export interface ITextCharacterFormat {
        setClone(value: Windows.UI.Text.ITextCharacterFormat): void;
        getClone(): Windows.UI.Text.ITextCharacterFormat;
        isEqual(format: Windows.UI.Text.ITextCharacterFormat): boolean;
        allCaps: Windows.UI.Text.FormatEffect;
        backgroundColor: Windows.UI.Color;
        bold: Windows.UI.Text.FormatEffect;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        foregroundColor: Windows.UI.Color;
        hidden: Windows.UI.Text.FormatEffect;
        italic: Windows.UI.Text.FormatEffect;
        kerning: number;
        languageTag: string;
        linkType: Windows.UI.Text.LinkType;
        name: string;
        outline: Windows.UI.Text.FormatEffect;
        position: number;
        protectedText: Windows.UI.Text.FormatEffect;
        size: number;
        smallCaps: Windows.UI.Text.FormatEffect;
        spacing: number;
        strikethrough: Windows.UI.Text.FormatEffect;
        subscript: Windows.UI.Text.FormatEffect;
        superscript: Windows.UI.Text.FormatEffect;
        textScript: Windows.UI.Text.TextScript;
        underline: Windows.UI.Text.UnderlineType;
        weight: number;
    }

    export interface ITextDocument {
        canCopy(): boolean;
        canPaste(): boolean;
        canRedo(): boolean;
        canUndo(): boolean;
        applyDisplayUpdates(): number;
        batchDisplayUpdates(): number;
        beginUndoGroup(): void;
        endUndoGroup(): void;
        getDefaultCharacterFormat(): Windows.UI.Text.ITextCharacterFormat;
        getDefaultParagraphFormat(): Windows.UI.Text.ITextParagraphFormat;
        getRange(startPosition: number, endPosition: number): Windows.UI.Text.ITextRange;
        getRangeFromPoint(point: Windows.Foundation.Point, options: Windows.UI.Text.PointOptions): Windows.UI.Text.ITextRange;
        getText(options: Windows.UI.Text.TextGetOptions): ITextDocument_getText_OUT;
        loadFromStream(options: Windows.UI.Text.TextSetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        redo(): void;
        saveToStream(options: Windows.UI.Text.TextGetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        setDefaultCharacterFormat(value: Windows.UI.Text.ITextCharacterFormat): void;
        setDefaultParagraphFormat(value: Windows.UI.Text.ITextParagraphFormat): void;
        setText(options: Windows.UI.Text.TextSetOptions, value: string): void;
        undo(): void;
        caretType: Windows.UI.Text.CaretType;
        defaultTabStop: number;
        selection: Windows.UI.Text.ITextSelection;
        undoLimit: number;
    }

    interface ITextDocument_getText_OUT {
        value: string;
    }

    export interface ITextParagraphFormat {
        addTab(position: number, align: Windows.UI.Text.TabAlignment, leader: Windows.UI.Text.TabLeader): void;
        clearAllTabs(): void;
        deleteTab(position: number): void;
        getClone(): Windows.UI.Text.ITextParagraphFormat;
        getTab(index: number): ITextParagraphFormat_getTab_OUT;
        isEqual(format: Windows.UI.Text.ITextParagraphFormat): boolean;
        setClone(format: Windows.UI.Text.ITextParagraphFormat): void;
        setIndents(start: number, left: number, right: number): void;
        setLineSpacing(rule: Windows.UI.Text.LineSpacingRule, spacing: number): void;
        alignment: Windows.UI.Text.ParagraphAlignment;
        firstLineIndent: number;
        keepTogether: Windows.UI.Text.FormatEffect;
        keepWithNext: Windows.UI.Text.FormatEffect;
        leftIndent: number;
        lineSpacing: number;
        lineSpacingRule: Windows.UI.Text.LineSpacingRule;
        listAlignment: Windows.UI.Text.MarkerAlignment;
        listLevelIndex: number;
        listStart: number;
        listStyle: Windows.UI.Text.MarkerStyle;
        listTab: number;
        listType: Windows.UI.Text.MarkerType;
        noLineNumber: Windows.UI.Text.FormatEffect;
        pageBreakBefore: Windows.UI.Text.FormatEffect;
        rightIndent: number;
        rightToLeft: Windows.UI.Text.FormatEffect;
        spaceAfter: number;
        spaceBefore: number;
        style: Windows.UI.Text.ParagraphStyle;
        tabCount: number;
        widowControl: Windows.UI.Text.FormatEffect;
    }

    interface ITextParagraphFormat_getTab_OUT {
        position: number;
        align: Windows.UI.Text.TabAlignment;
        leader: Windows.UI.Text.TabLeader;
    }

    export interface ITextRange {
        canPaste(format: number): boolean;
        changeCase(value: Windows.UI.Text.LetterCase): void;
        collapse(value: boolean): void;
        copy(): void;
        cut(): void;
        delete(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        endOf(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        expand(unit: Windows.UI.Text.TextRangeUnit): number;
        findText(value: string, scanLength: number, options: Windows.UI.Text.FindOptions): number;
        getCharacterUtf32(offset: number): ITextRange_getCharacterUtf32_OUT;
        getClone(): Windows.UI.Text.ITextRange;
        getIndex(unit: Windows.UI.Text.TextRangeUnit): number;
        getPoint(horizontalAlign: Windows.UI.Text.HorizontalCharacterAlignment, verticalAlign: Windows.UI.Text.VerticalCharacterAlignment, options: Windows.UI.Text.PointOptions): ITextRange_getPoint_OUT;
        getRect(options: Windows.UI.Text.PointOptions): ITextRange_getRect_OUT;
        getText(options: Windows.UI.Text.TextGetOptions): ITextRange_getText_OUT;
        getTextViaStream(options: Windows.UI.Text.TextGetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        inRange(range: Windows.UI.Text.ITextRange): boolean;
        insertImage(width: number, height: number, ascent: number, verticalAlign: Windows.UI.Text.VerticalCharacterAlignment, alternateText: string, value: Windows.Storage.Streams.IRandomAccessStream): void;
        inStory(range: Windows.UI.Text.ITextRange): boolean;
        isEqual(range: Windows.UI.Text.ITextRange): boolean;
        move(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        moveEnd(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        moveStart(unit: Windows.UI.Text.TextRangeUnit, count: number): number;
        paste(format: number): void;
        scrollIntoView(value: Windows.UI.Text.PointOptions): void;
        matchSelection(): void;
        setIndex(unit: Windows.UI.Text.TextRangeUnit, index: number, extend: boolean): void;
        setPoint(point: Windows.Foundation.Point, options: Windows.UI.Text.PointOptions, extend: boolean): void;
        setRange(startPosition: number, endPosition: number): void;
        setText(options: Windows.UI.Text.TextSetOptions, value: string): void;
        setTextViaStream(options: Windows.UI.Text.TextSetOptions, value: Windows.Storage.Streams.IRandomAccessStream): void;
        startOf(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        character: number;
        characterFormat: Windows.UI.Text.ITextCharacterFormat;
        endPosition: number;
        formattedText: Windows.UI.Text.ITextRange;
        gravity: Windows.UI.Text.RangeGravity;
        length: number;
        link: string;
        paragraphFormat: Windows.UI.Text.ITextParagraphFormat;
        startPosition: number;
        storyLength: number;
        text: string;
    }

    interface ITextRange_getCharacterUtf32_OUT {
        value: number;
    }

    interface ITextRange_getPoint_OUT {
        point: Windows.Foundation.Point;
    }

    interface ITextRange_getRect_OUT {
        rect: Windows.Foundation.Rect;
        hit: number;
    }

    interface ITextRange_getText_OUT {
        value: string;
    }

    export interface ITextSelection extends Windows.UI.Text.ITextRange {
        endKey(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        homeKey(unit: Windows.UI.Text.TextRangeUnit, extend: boolean): number;
        moveDown(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveLeft(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveRight(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        moveUp(unit: Windows.UI.Text.TextRangeUnit, count: number, extend: boolean): number;
        typeText(value: string): void;
        options: Windows.UI.Text.SelectionOptions;
        type: Windows.UI.Text.SelectionType;
    }

    enum LetterCase {
        lower,
        upper
    }

    enum LineSpacingRule {
        undefined,
        single,
        oneAndHalf,
        double,
        atLeast,
        exactly,
        multiple,
        percent
    }

    enum LinkType {
        undefined,
        notALink,
        clientLink,
        friendlyLinkName,
        friendlyLinkAddress,
        autoLink,
        autoLinkEmail,
        autoLinkPhone,
        autoLinkPath
    }

    enum MarkerAlignment {
        undefined,
        left,
        center,
        right
    }

    enum MarkerStyle {
        undefined,
        parenthesis,
        parentheses,
        period,
        plain,
        minus,
        noNumber
    }

    enum MarkerType {
        undefined,
        none,
        bullet,
        arabic,
        lowercaseEnglishLetter,
        uppercaseEnglishLetter,
        lowercaseRoman,
        uppercaseRoman,
        unicodeSequence,
        circledNumber,
        blackCircleWingding,
        whiteCircleWingding,
        arabicWide,
        simplifiedChinese,
        traditionalChinese,
        japanSimplifiedChinese,
        japanKorea,
        arabicDictionary,
        arabicAbjad,
        hebrew,
        thaiAlphabetic,
        thaiNumeric,
        devanagariVowel,
        devanagariConsonant,
        devanagariNumeric
    }

    enum ParagraphAlignment {
        undefined,
        left,
        center,
        right,
        justify
    }

    enum ParagraphStyle {
        undefined,
        none,
        normal,
        heading1,
        heading2,
        heading3,
        heading4,
        heading5,
        heading6,
        heading7,
        heading8,
        heading9
    }

    enum PointOptions {
        none,
        includeInset,
        start,
        clientCoordinates,
        allowOffClient,
        transform,
        noHorizontalScroll,
        noVerticalScroll
    }

    enum RangeGravity {
        uIBehavior,
        backward,
        forward,
        inward,
        outward
    }

    enum SelectionOptions {
        startActive,
        atEndOfLine,
        overtype,
        active,
        replace
    }

    enum SelectionType {
        none,
        insertionPoint,
        normal,
        inlineShape,
        shape
    }

    enum TabAlignment {
        left,
        center,
        right,
        decimal,
        bar
    }

    enum TabLeader {
        spaces,
        dots,
        dashes,
        lines,
        thickLines,
        equals
    }

    export class TextConstants {
        static autoColor: Windows.UI.Color;
        static maxUnitCount: number;
        static minUnitCount: number;
        static undefinedColor: Windows.UI.Color;
        static undefinedFloatValue: number;
        static undefinedFontStretch: Windows.UI.Text.FontStretch;
        static undefinedFontStyle: Windows.UI.Text.FontStyle;
        static undefinedInt32Value: number;
    }

    enum TextGetOptions {
        none,
        adjustCrlf,
        useCrlf,
        useObjectText,
        allowFinalEop,
        noHidden,
        includeNumbering,
        formatRtf
    }

    enum TextRangeUnit {
        character,
        word,
        sentence,
        paragraph,
        line,
        story,
        screen,
        section,
        window,
        characterFormat,
        paragraphFormat,
        object,
        hardParagraph,
        cluster,
        bold,
        italic,
        underline,
        strikethrough,
        protectedText,
        link,
        smallCaps,
        allCaps,
        hidden,
        outline,
        shadow,
        imprint,
        disabled,
        revised,
        subscript,
        superscript,
        fontBound,
        linkProtected
    }

    enum TextScript {
        undefined,
        ansi,
        eastEurope,
        cyrillic,
        greek,
        turkish,
        hebrew,
        arabic,
        baltic,
        vietnamese,
        default,
        symbol,
        thai,
        shiftJis,
        gb2312,
        hangul,
        big5,
        pc437,
        oem,
        mac,
        armenian,
        syriac,
        thaana,
        devanagari,
        bengali,
        gurmukhi,
        gujarati,
        oriya,
        tamil,
        telugu,
        kannada,
        malayalam,
        sinhala,
        lao,
        tibetan,
        myanmar,
        georgian,
        jamo,
        ethiopic,
        cherokee,
        aboriginal,
        ogham,
        runic,
        khmer,
        mongolian,
        braille,
        yi,
        limbu,
        taiLe,
        newTaiLue,
        sylotiNagri,
        kharoshthi,
        kayahli,
        unicodeSymbol,
        emoji,
        glagolitic,
        lisu,
        vai,
        nKo,
        osmanya,
        phagsPa,
        gothic,
        deseret,
        tifinagh
    }

    enum TextSetOptions {
        none,
        unicodeBidi,
        unlink,
        unhide,
        checkTextLimit,
        formatRtf,
        applyRtfDocumentDefaults
    }

    enum UnderlineType {
        undefined,
        none,
        single,
        words,
        double,
        dotted,
        dash,
        dashDot,
        dashDotDot,
        wave,
        thick,
        thin,
        doubleWave,
        heavyWave,
        longDash,
        thickDash,
        thickDashDot,
        thickDashDotDot,
        thickDotted,
        thickLongDash
    }

    enum VerticalCharacterAlignment {
        top,
        baseline,
        bottom
    }

}
declare module Windows.UI.ViewManagement {

    export class AccessibilitySettings implements Windows.UI.ViewManagement.IAccessibilitySettings {
        constructor();
        add_HighContrastChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): Windows.Foundation.EventRegistrationToken;
        remove_HighContrastChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        highContrast: boolean;
        highContrastScheme: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        removeEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        onhighcontrastchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>) => void;

    }

    export class ApplicationView {
        static tryUnsnap(): boolean;
        static value: Windows.UI.ViewManagement.ApplicationViewState;
    }

    enum ApplicationViewState {
        fullScreenLandscape,
        filled,
        snapped,
        fullScreenPortrait
    }

    enum HandPreference {
        leftHanded,
        rightHanded
    }

    export interface IAccessibilitySettings {
        add_HighContrastChanged(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): Windows.Foundation.EventRegistrationToken;
        remove_HighContrastChanged(cookie: Windows.Foundation.EventRegistrationToken): void;
        highContrast: boolean;
        highContrastScheme: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        removeEventListener(eventName: "highcontrastchanged", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>): void;
        onhighcontrastchanged: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.AccessibilitySettings,any>) => void;

    }

    export interface IInputPane {
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(token: Windows.Foundation.EventRegistrationToken): void;
        add_Hiding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Hiding(token: Windows.Foundation.EventRegistrationToken): void;
        occludedRect: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onhiding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;

    }

    export interface IInputPaneVisibilityEventArgs {
        ensuredFocusedElementInView: boolean;
        occludedRect: Windows.Foundation.Rect;
    }

    export class InputPane implements Windows.UI.ViewManagement.IInputPane {
        add_Showing(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Showing(token: Windows.Foundation.EventRegistrationToken): void;
        add_Hiding(handler: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_Hiding(token: Windows.Foundation.EventRegistrationToken): void;
        static getForCurrentView(): Windows.UI.ViewManagement.InputPane;
        occludedRect: Windows.Foundation.Rect;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "hiding", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onhiding: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;
        addEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        removeEventListener(eventName: "showing", listener: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>): void;
        onshowing: (ev: Windows.Foundation.TypedEventHandler<Windows.UI.ViewManagement.InputPane,Windows.UI.ViewManagement.InputPaneVisibilityEventArgs>) => void;

    }

    export class InputPaneVisibilityEventArgs implements Windows.UI.ViewManagement.IInputPaneVisibilityEventArgs {
        ensuredFocusedElementInView: boolean;
        occludedRect: Windows.Foundation.Rect;
    }

    export interface IUISettings {
        uIElementColor(desiredElement: Windows.UI.ViewManagement.UIElementType): Windows.UI.Color;
        animationsEnabled: boolean;
        caretBlinkRate: number;
        caretBrowsingEnabled: boolean;
        caretWidth: number;
        cursorSize: Windows.Foundation.Size;
        doubleClickTime: number;
        handPreference: Windows.UI.ViewManagement.HandPreference;
        messageDuration: number;
        mouseHoverTime: number;
        scrollBarArrowSize: Windows.Foundation.Size;
        scrollBarSize: Windows.Foundation.Size;
        scrollBarThumbBoxSize: Windows.Foundation.Size;
    }

    enum UIElementType {
        activeCaption,
        background,
        buttonFace,
        buttonText,
        captionText,
        grayText,
        highlight,
        highlightText,
        hotlight,
        inactiveCaption,
        inactiveCaptionText,
        window,
        windowText
    }

    export class UISettings implements Windows.UI.ViewManagement.IUISettings {
        constructor();
        uIElementColor(desiredElement: Windows.UI.ViewManagement.UIElementType): Windows.UI.Color;
        animationsEnabled: boolean;
        caretBlinkRate: number;
        caretBrowsingEnabled: boolean;
        caretWidth: number;
        cursorSize: Windows.Foundation.Size;
        doubleClickTime: number;
        handPreference: Windows.UI.ViewManagement.HandPreference;
        messageDuration: number;
        mouseHoverTime: number;
        scrollBarArrowSize: Windows.Foundation.Size;
        scrollBarSize: Windows.Foundation.Size;
        scrollBarThumbBoxSize: Windows.Foundation.Size;
    }

}
declare module Windows.UI.WebUI {

    export class ActivatedDeferral implements Windows.UI.WebUI.IActivatedDeferral {
        complete(): void;
    }

    export interface ActivatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ActivatedOperation implements Windows.UI.WebUI.IActivatedOperation {
        getDeferral(): Windows.UI.WebUI.ActivatedDeferral;
    }

    export interface IActivatedDeferral {
        complete(): void;
    }

    export interface IActivatedEventArgsDeferral {
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export interface IActivatedOperation {
        getDeferral(): Windows.UI.WebUI.ActivatedDeferral;
    }

    export interface IWebUIBackgroundTaskInstance {
        succeeded: boolean;
    }

    export interface IWebUINavigatedDeferral {
        complete(): void;
    }

    export interface IWebUINavigatedEventArgs {
        navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation;
    }

    export interface IWebUINavigatedOperation {
        getDeferral(): Windows.UI.WebUI.WebUINavigatedDeferral;
    }

    export interface NavigatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface ResumingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class SuspendingDeferral implements Windows.ApplicationModel.ISuspendingDeferral {
        complete(): void;
    }

    export class SuspendingEventArgs implements Windows.ApplicationModel.ISuspendingEventArgs {
        suspendingOperation: Windows.ApplicationModel.SuspendingOperation;
    }

    export interface SuspendingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class SuspendingOperation implements Windows.ApplicationModel.ISuspendingOperation {
        getDeferral(): Windows.ApplicationModel.SuspendingDeferral;
        deadline: Date;
    }

    export class WebUIApplication {
        static add_Activated(handler: Windows.UI.WebUI.ActivatedEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_Activated(token: Windows.Foundation.EventRegistrationToken): void;
        static add_Suspending(handler: Windows.UI.WebUI.SuspendingEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_Suspending(token: Windows.Foundation.EventRegistrationToken): void;
        static add_Resuming(handler: Windows.UI.WebUI.ResumingEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_Resuming(token: Windows.Foundation.EventRegistrationToken): void;
        static add_Navigated(handler: Windows.UI.WebUI.NavigatedEventHandler): Windows.Foundation.EventRegistrationToken;
        static remove_Navigated(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
        removeEventListener(eventName: "activated", listener: Windows.UI.WebUI.ActivatedEventHandler): void;
        onactivated: (ev: Windows.UI.WebUI.ActivatedEventHandler) => void;
        addEventListener(eventName: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
        removeEventListener(eventName: "navigated", listener: Windows.UI.WebUI.NavigatedEventHandler): void;
        onnavigated: (ev: Windows.UI.WebUI.NavigatedEventHandler) => void;
        addEventListener(eventName: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
        removeEventListener(eventName: "resuming", listener: Windows.UI.WebUI.ResumingEventHandler): void;
        onresuming: (ev: Windows.UI.WebUI.ResumingEventHandler) => void;
        addEventListener(eventName: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
        removeEventListener(eventName: "suspending", listener: Windows.UI.WebUI.SuspendingEventHandler): void;
        onsuspending: (ev: Windows.UI.WebUI.SuspendingEventHandler) => void;

    }

    export class WebUIBackgroundTaskInstance {
        static current: Windows.UI.WebUI.IWebUIBackgroundTaskInstance;
    }

    export class WebUIBackgroundTaskInstanceRuntimeClass implements Windows.UI.WebUI.IWebUIBackgroundTaskInstance, Windows.ApplicationModel.Background.IBackgroundTaskInstance {
        add_Canceled(cancelHandler: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Canceled(cookie: Windows.Foundation.EventRegistrationToken): void;
        getDeferral(): Windows.ApplicationModel.Background.BackgroundTaskDeferral;
        succeeded: boolean;
        instanceId: string;
        progress: number;
        suspendedCount: number;
        task: Windows.ApplicationModel.Background.BackgroundTaskRegistration;
        triggerDetails: any;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        removeEventListener(eventName: "canceled", listener: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler): void;
        oncanceled: (ev: Windows.ApplicationModel.Background.BackgroundTaskCanceledEventHandler) => void;

    }

    export class WebUICachedFileUpdaterActivatedEventArgs implements Windows.ApplicationModel.Activation.ICachedFileUpdaterActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        cachedFileUpdaterUI: Windows.Storage.Provider.CachedFileUpdaterUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUICameraSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.ICameraSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        videoDeviceController: any;
        videoDeviceExtension: any;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIContactPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IContactPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        contactPickerUI: Windows.ApplicationModel.Contacts.Provider.ContactPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIDeviceActivatedEventArgs implements Windows.ApplicationModel.Activation.IDeviceActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        deviceInformationId: string;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        files: Windows.Foundation.Collections.IVectorView<Windows.Storage.IStorageItem>;
        verb: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileOpenPickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileOpenPickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        fileOpenPickerUI: Windows.Storage.Pickers.Provider.FileOpenPickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIFileSavePickerActivatedEventArgs implements Windows.ApplicationModel.Activation.IFileSavePickerActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        fileSavePickerUI: Windows.Storage.Pickers.Provider.FileSavePickerUI;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUILaunchActivatedEventArgs implements Windows.ApplicationModel.Activation.ILaunchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        arguments: string;
        tileId: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUINavigatedDeferral implements Windows.UI.WebUI.IWebUINavigatedDeferral {
        complete(): void;
    }

    export class WebUINavigatedEventArgs implements Windows.UI.WebUI.IWebUINavigatedEventArgs {
        navigatedOperation: Windows.UI.WebUI.WebUINavigatedOperation;
    }

    export class WebUINavigatedOperation implements Windows.UI.WebUI.IWebUINavigatedOperation {
        getDeferral(): Windows.UI.WebUI.WebUINavigatedDeferral;
    }

    export class WebUIPrintTaskSettingsActivatedEventArgs implements Windows.ApplicationModel.Activation.IPrintTaskSettingsActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        configuration: Windows.Devices.Printers.Extensions.PrintTaskConfiguration;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIProtocolActivatedEventArgs implements Windows.ApplicationModel.Activation.IProtocolActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        uri: Windows.Foundation.Uri;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUISearchActivatedEventArgs implements Windows.ApplicationModel.Activation.ISearchActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        language: string;
        queryText: string;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

    export class WebUIShareTargetActivatedEventArgs implements Windows.ApplicationModel.Activation.IShareTargetActivatedEventArgs, Windows.ApplicationModel.Activation.IActivatedEventArgs, Windows.UI.WebUI.IActivatedEventArgsDeferral {
        shareOperation: Windows.ApplicationModel.DataTransfer.ShareTarget.ShareOperation;
        kind: Windows.ApplicationModel.Activation.ActivationKind;
        previousExecutionState: Windows.ApplicationModel.Activation.ApplicationExecutionState;
        splashScreen: Windows.ApplicationModel.Activation.SplashScreen;
        activatedOperation: Windows.UI.WebUI.ActivatedOperation;
    }

}
declare module Windows.UI.Xaml {

    export class Application implements Windows.UI.Xaml.IApplication, Windows.UI.Xaml.IApplicationOverrides {
        constructor();
        add_UnhandledException(value: Windows.UI.Xaml.UnhandledExceptionEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_UnhandledException(token: Windows.Foundation.EventRegistrationToken): void;
        add_Suspending(value: Windows.UI.Xaml.SuspendingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Suspending(token: Windows.Foundation.EventRegistrationToken): void;
        add_Resuming(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Resuming(token: Windows.Foundation.EventRegistrationToken): void;
        exit(): void;
        onActivated(args: Windows.ApplicationModel.Activation.IActivatedEventArgs): void;
        onLaunched(args: Windows.ApplicationModel.Activation.LaunchActivatedEventArgs): void;
        onFileActivated(args: Windows.ApplicationModel.Activation.FileActivatedEventArgs): void;
        onSearchActivated(args: Windows.ApplicationModel.Activation.SearchActivatedEventArgs): void;
        onShareTargetActivated(args: Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs): void;
        onFileOpenPickerActivated(args: Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs): void;
        onFileSavePickerActivated(args: Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs): void;
        onCachedFileUpdaterActivated(args: Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs): void;
        onWindowCreated(args: Windows.UI.Xaml.WindowCreatedEventArgs): void;
        static start(callback: Windows.UI.Xaml.ApplicationInitializationCallback): void;
        static loadComponent(component: any, resourceLocator: Windows.Foundation.Uri): void;
        static loadComponent(component: any, resourceLocator: Windows.Foundation.Uri, componentResourceLocation: Windows.UI.Xaml.Controls.Primitives.ComponentResourceLocation): void;
        debugSettings: Windows.UI.Xaml.DebugSettings;
        requestedTheme: Windows.UI.Xaml.ApplicationTheme;
        resources: Windows.UI.Xaml.ResourceDictionary;
        static current: Windows.UI.Xaml.Application;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        onresuming: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "suspending", listener: Windows.UI.Xaml.SuspendingEventHandler): void;
        removeEventListener(eventName: "suspending", listener: Windows.UI.Xaml.SuspendingEventHandler): void;
        onsuspending: (ev: Windows.UI.Xaml.SuspendingEventHandler) => void;
        addEventListener(eventName: "unhandledexception", listener: Windows.UI.Xaml.UnhandledExceptionEventHandler): void;
        removeEventListener(eventName: "unhandledexception", listener: Windows.UI.Xaml.UnhandledExceptionEventHandler): void;
        onunhandledexception: (ev: Windows.UI.Xaml.UnhandledExceptionEventHandler) => void;

    }

    export interface ApplicationInitializationCallback {
        target: Windows.UI.Xaml.ApplicationInitializationCallbackParams;
        detail: any[];
        type: string;
    }

    export class ApplicationInitializationCallbackParams implements Windows.UI.Xaml.IApplicationInitializationCallbackParams {
    }

    enum ApplicationTheme {
        light,
        dark
    }

    export class BindingFailedEventArgs implements Windows.UI.Xaml.IBindingFailedEventArgs {
        message: string;
    }

    export interface BindingFailedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class CornerRadius {
        topLeft: number;
        topRight: number;
        bottomRight: number;
        bottomLeft: number;
    }

    export class CornerRadiusHelper implements Windows.UI.Xaml.ICornerRadiusHelper {
        static fromRadii(topLeft: number, topRight: number, bottomRight: number, bottomLeft: number): Windows.UI.Xaml.CornerRadius;
        static fromUniformRadius(uniformRadius: number): Windows.UI.Xaml.CornerRadius;
    }

    export interface CreateDefaultValueCallback {
        target: any;
        detail: any[];
        type: string;
    }

    export class DataTemplate implements Windows.UI.Xaml.IDataTemplate {
        constructor();
        loadContent(): Windows.UI.Xaml.DependencyObject;
    }

    export class DataTemplateKey implements Windows.UI.Xaml.IDataTemplateKey {
        constructor();
        constructor(dataType: any);
        dataType: any;
    }

    export class DebugSettings implements Windows.UI.Xaml.IDebugSettings {
        add_BindingFailed(value: Windows.UI.Xaml.BindingFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_BindingFailed(token: Windows.Foundation.EventRegistrationToken): void;
        enableFrameRateCounter: boolean;
        isBindingTracingEnabled: boolean;
        isOverdrawHeatMapEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "bindingfailed", listener: Windows.UI.Xaml.BindingFailedEventHandler): void;
        removeEventListener(eventName: "bindingfailed", listener: Windows.UI.Xaml.BindingFailedEventHandler): void;
        onbindingfailed: (ev: Windows.UI.Xaml.BindingFailedEventHandler) => void;

    }

    export class DependencyObject implements Windows.UI.Xaml.IDependencyObject {
        constructor();
        getValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        setValue(dp: Windows.UI.Xaml.DependencyProperty, value: any): void;
        clearValue(dp: Windows.UI.Xaml.DependencyProperty): void;
        readLocalValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        getAnimationBaseValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        dispatcher: Windows.UI.Core.CoreDispatcher;
    }

    export class DependencyProperty implements Windows.UI.Xaml.IDependencyProperty {
        getMetadata(forType: Windows.UI.Xaml.Interop.TypeName): Windows.UI.Xaml.PropertyMetadata;
        static register(name: string, propertyType: Windows.UI.Xaml.Interop.TypeName, ownerType: Windows.UI.Xaml.Interop.TypeName, typeMetadata: Windows.UI.Xaml.PropertyMetadata): Windows.UI.Xaml.DependencyProperty;
        static registerAttached(name: string, propertyType: Windows.UI.Xaml.Interop.TypeName, ownerType: Windows.UI.Xaml.Interop.TypeName, defaultMetadata: Windows.UI.Xaml.PropertyMetadata): Windows.UI.Xaml.DependencyProperty;
        static unsetValue: any;
    }

    export class DependencyPropertyChangedEventArgs implements Windows.UI.Xaml.IDependencyPropertyChangedEventArgs {
        newValue: any;
        oldValue: any;
        property: Windows.UI.Xaml.DependencyProperty;
    }

    export interface DependencyPropertyChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class DispatcherTimer implements Windows.UI.Xaml.IDispatcherTimer {
        constructor();
        add_Tick(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Tick(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        interval: Windows.Foundation.TimeSpan;
        isEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "tick", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "tick", listener: Windows.Foundation.EventHandler<any>): void;
        ontick: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class DragEventArgs implements Windows.UI.Xaml.IDragEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        handled: boolean;
    }

    export interface DragEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class Duration {
        timeSpan: Windows.Foundation.TimeSpan;
        type: Windows.UI.Xaml.DurationType;
    }

    export class DurationHelper implements Windows.UI.Xaml.IDurationHelper {
        static compare(duration1: Windows.UI.Xaml.Duration, duration2: Windows.UI.Xaml.Duration): number;
        static fromTimeSpan(timeSpan: Windows.Foundation.TimeSpan): Windows.UI.Xaml.Duration;
        static getHasTimeSpan(target: Windows.UI.Xaml.Duration): boolean;
        static add(target: Windows.UI.Xaml.Duration, duration: Windows.UI.Xaml.Duration): Windows.UI.Xaml.Duration;
        static equals(target: Windows.UI.Xaml.Duration, value: Windows.UI.Xaml.Duration): boolean;
        static subtract(target: Windows.UI.Xaml.Duration, duration: Windows.UI.Xaml.Duration): Windows.UI.Xaml.Duration;
        static automatic: Windows.UI.Xaml.Duration;
        static forever: Windows.UI.Xaml.Duration;
    }

    enum DurationType {
        automatic,
        timeSpan,
        forever
    }

    export class EventTrigger implements Windows.UI.Xaml.IEventTrigger {
        constructor();
        actions: Windows.UI.Xaml.TriggerActionCollection;
        routedEvent: Windows.UI.Xaml.RoutedEvent;
    }

    export class ExceptionRoutedEventArgs implements Windows.UI.Xaml.IExceptionRoutedEventArgs {
        errorMessage: string;
    }

    export interface ExceptionRoutedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum FlowDirection {
        leftToRight,
        rightToLeft
    }

    enum FocusState {
        unfocused,
        pointer,
        keyboard,
        programmatic
    }

    enum FontCapitals {
        normal,
        allSmallCaps,
        smallCaps,
        allPetiteCaps,
        petiteCaps,
        unicase,
        titling
    }

    enum FontEastAsianLanguage {
        normal,
        hojoKanji,
        jis04,
        jis78,
        jis83,
        jis90,
        nlcKanji,
        simplified,
        traditional,
        traditionalNames
    }

    enum FontEastAsianWidths {
        normal,
        full,
        half,
        proportional,
        quarter,
        third
    }

    enum FontFraction {
        normal,
        stacked,
        slashed
    }

    enum FontNumeralAlignment {
        normal,
        proportional,
        tabular
    }

    enum FontNumeralStyle {
        normal,
        lining,
        oldStyle
    }

    enum FontVariants {
        normal,
        superscript,
        subscript,
        ordinal,
        inferior,
        ruby
    }

    export class FrameworkElement implements Windows.UI.Xaml.IFrameworkElement, Windows.UI.Xaml.IFrameworkElementOverrides {
        constructor();
        add_Loaded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Loaded(token: Windows.Foundation.EventRegistrationToken): void;
        add_Unloaded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Unloaded(token: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(value: Windows.UI.Xaml.SizeChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_LayoutUpdated(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_LayoutUpdated(token: Windows.Foundation.EventRegistrationToken): void;
        findName(name: string): any;
        setBinding(dp: Windows.UI.Xaml.DependencyProperty, binding: Windows.UI.Xaml.Data.BindingBase): void;
        measureOverride(availableSize: Windows.Foundation.Size): Windows.Foundation.Size;
        arrangeOverride(finalSize: Windows.Foundation.Size): Windows.Foundation.Size;
        onApplyTemplate(): void;
        actualHeight: number;
        actualWidth: number;
        baseUri: Windows.Foundation.Uri;
        dataContext: any;
        flowDirection: Windows.UI.Xaml.FlowDirection;
        height: number;
        horizontalAlignment: Windows.UI.Xaml.HorizontalAlignment;
        language: string;
        margin: Windows.UI.Xaml.Thickness;
        maxHeight: number;
        maxWidth: number;
        minHeight: number;
        minWidth: number;
        name: string;
        parent: Windows.UI.Xaml.DependencyObject;
        resources: Windows.UI.Xaml.ResourceDictionary;
        style: Windows.UI.Xaml.Style;
        tag: any;
        triggers: Windows.UI.Xaml.TriggerCollection;
        verticalAlignment: Windows.UI.Xaml.VerticalAlignment;
        width: number;
        static actualHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static actualWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static dataContextProperty: Windows.UI.Xaml.DependencyProperty;
        static flowDirectionProperty: Windows.UI.Xaml.DependencyProperty;
        static heightProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static languageProperty: Windows.UI.Xaml.DependencyProperty;
        static marginProperty: Windows.UI.Xaml.DependencyProperty;
        static maxHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static maxWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static minHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static minWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static nameProperty: Windows.UI.Xaml.DependencyProperty;
        static styleProperty: Windows.UI.Xaml.DependencyProperty;
        static tagProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static widthProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "layoutupdated", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "layoutupdated", listener: Windows.Foundation.EventHandler<any>): void;
        onlayoutupdated: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "loaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "loaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onloaded: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.SizeChangedEventHandler): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.SizeChangedEventHandler): void;
        onsizechanged: (ev: Windows.UI.Xaml.SizeChangedEventHandler) => void;
        addEventListener(eventName: "unloaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "unloaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onunloaded: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class FrameworkTemplate implements Windows.UI.Xaml.IFrameworkTemplate {
        constructor();
    }

    export class FrameworkView implements Windows.UI.Xaml.IFrameworkView, Windows.ApplicationModel.Core.IFrameworkView {
        constructor();
        initialize(applicationView: Windows.ApplicationModel.Core.CoreApplicationView): void;
        setWindow(window: Windows.UI.Core.CoreWindow): void;
        load(entryPoint: string): void;
        run(): void;
        uninitialize(): void;
    }

    export class FrameworkViewSource implements Windows.UI.Xaml.IFrameworkViewSource, Windows.ApplicationModel.Core.IFrameworkViewSource {
        constructor();
        createView(): Windows.ApplicationModel.Core.IFrameworkView;
    }

    export class GridLength {
        value: number;
        gridUnitType: Windows.UI.Xaml.GridUnitType;
    }

    export class GridLengthHelper implements Windows.UI.Xaml.IGridLengthHelper {
        static fromPixels(pixels: number): Windows.UI.Xaml.GridLength;
        static fromValueAndType(value: number, type: Windows.UI.Xaml.GridUnitType): Windows.UI.Xaml.GridLength;
        static getIsAbsolute(target: Windows.UI.Xaml.GridLength): boolean;
        static getIsAuto(target: Windows.UI.Xaml.GridLength): boolean;
        static getIsStar(target: Windows.UI.Xaml.GridLength): boolean;
        static equals(target: Windows.UI.Xaml.GridLength, value: Windows.UI.Xaml.GridLength): boolean;
        static auto: Windows.UI.Xaml.GridLength;
    }

    enum GridUnitType {
        auto,
        pixel,
        star
    }

    enum HorizontalAlignment {
        left,
        center,
        right,
        stretch
    }

    export interface IApplication {
        add_UnhandledException(value: Windows.UI.Xaml.UnhandledExceptionEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_UnhandledException(token: Windows.Foundation.EventRegistrationToken): void;
        add_Suspending(value: Windows.UI.Xaml.SuspendingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Suspending(token: Windows.Foundation.EventRegistrationToken): void;
        add_Resuming(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Resuming(token: Windows.Foundation.EventRegistrationToken): void;
        exit(): void;
        debugSettings: Windows.UI.Xaml.DebugSettings;
        requestedTheme: Windows.UI.Xaml.ApplicationTheme;
        resources: Windows.UI.Xaml.ResourceDictionary;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "resuming", listener: Windows.Foundation.EventHandler<any>): void;
        onresuming: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "suspending", listener: Windows.UI.Xaml.SuspendingEventHandler): void;
        removeEventListener(eventName: "suspending", listener: Windows.UI.Xaml.SuspendingEventHandler): void;
        onsuspending: (ev: Windows.UI.Xaml.SuspendingEventHandler) => void;
        addEventListener(eventName: "unhandledexception", listener: Windows.UI.Xaml.UnhandledExceptionEventHandler): void;
        removeEventListener(eventName: "unhandledexception", listener: Windows.UI.Xaml.UnhandledExceptionEventHandler): void;
        onunhandledexception: (ev: Windows.UI.Xaml.UnhandledExceptionEventHandler) => void;

    }

    export interface IApplicationInitializationCallbackParams {
    }

    export interface IApplicationOverrides {
        onActivated(args: Windows.ApplicationModel.Activation.IActivatedEventArgs): void;
        onLaunched(args: Windows.ApplicationModel.Activation.LaunchActivatedEventArgs): void;
        onFileActivated(args: Windows.ApplicationModel.Activation.FileActivatedEventArgs): void;
        onSearchActivated(args: Windows.ApplicationModel.Activation.SearchActivatedEventArgs): void;
        onShareTargetActivated(args: Windows.ApplicationModel.Activation.ShareTargetActivatedEventArgs): void;
        onFileOpenPickerActivated(args: Windows.ApplicationModel.Activation.FileOpenPickerActivatedEventArgs): void;
        onFileSavePickerActivated(args: Windows.ApplicationModel.Activation.FileSavePickerActivatedEventArgs): void;
        onCachedFileUpdaterActivated(args: Windows.ApplicationModel.Activation.CachedFileUpdaterActivatedEventArgs): void;
        onWindowCreated(args: Windows.UI.Xaml.WindowCreatedEventArgs): void;
    }

    export interface IBindingFailedEventArgs {
        message: string;
    }

    export interface ICornerRadiusHelper {
    }

    export interface IDataTemplate {
        loadContent(): Windows.UI.Xaml.DependencyObject;
    }

    export interface IDataTemplateKey {
        dataType: any;
    }

    export interface IDebugSettings {
        add_BindingFailed(value: Windows.UI.Xaml.BindingFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_BindingFailed(token: Windows.Foundation.EventRegistrationToken): void;
        enableFrameRateCounter: boolean;
        isBindingTracingEnabled: boolean;
        isOverdrawHeatMapEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "bindingfailed", listener: Windows.UI.Xaml.BindingFailedEventHandler): void;
        removeEventListener(eventName: "bindingfailed", listener: Windows.UI.Xaml.BindingFailedEventHandler): void;
        onbindingfailed: (ev: Windows.UI.Xaml.BindingFailedEventHandler) => void;

    }

    export interface IDependencyObject {
        getValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        setValue(dp: Windows.UI.Xaml.DependencyProperty, value: any): void;
        clearValue(dp: Windows.UI.Xaml.DependencyProperty): void;
        readLocalValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        getAnimationBaseValue(dp: Windows.UI.Xaml.DependencyProperty): any;
        dispatcher: Windows.UI.Core.CoreDispatcher;
    }

    export interface IDependencyProperty {
        getMetadata(forType: Windows.UI.Xaml.Interop.TypeName): Windows.UI.Xaml.PropertyMetadata;
    }

    export interface IDependencyPropertyChangedEventArgs {
        newValue: any;
        oldValue: any;
        property: Windows.UI.Xaml.DependencyProperty;
    }

    export interface IDispatcherTimer {
        add_Tick(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Tick(token: Windows.Foundation.EventRegistrationToken): void;
        start(): void;
        stop(): void;
        interval: Windows.Foundation.TimeSpan;
        isEnabled: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "tick", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "tick", listener: Windows.Foundation.EventHandler<any>): void;
        ontick: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface IDragEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        handled: boolean;
    }

    export interface IDurationHelper {
    }

    export interface IEventTrigger {
        actions: Windows.UI.Xaml.TriggerActionCollection;
        routedEvent: Windows.UI.Xaml.RoutedEvent;
    }

    export interface IExceptionRoutedEventArgs {
        errorMessage: string;
    }

    export interface IFrameworkElement {
        add_Loaded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Loaded(token: Windows.Foundation.EventRegistrationToken): void;
        add_Unloaded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Unloaded(token: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(value: Windows.UI.Xaml.SizeChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_LayoutUpdated(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_LayoutUpdated(token: Windows.Foundation.EventRegistrationToken): void;
        findName(name: string): any;
        setBinding(dp: Windows.UI.Xaml.DependencyProperty, binding: Windows.UI.Xaml.Data.BindingBase): void;
        actualHeight: number;
        actualWidth: number;
        baseUri: Windows.Foundation.Uri;
        dataContext: any;
        flowDirection: Windows.UI.Xaml.FlowDirection;
        height: number;
        horizontalAlignment: Windows.UI.Xaml.HorizontalAlignment;
        language: string;
        margin: Windows.UI.Xaml.Thickness;
        maxHeight: number;
        maxWidth: number;
        minHeight: number;
        minWidth: number;
        name: string;
        parent: Windows.UI.Xaml.DependencyObject;
        resources: Windows.UI.Xaml.ResourceDictionary;
        style: Windows.UI.Xaml.Style;
        tag: any;
        triggers: Windows.UI.Xaml.TriggerCollection;
        verticalAlignment: Windows.UI.Xaml.VerticalAlignment;
        width: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "layoutupdated", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "layoutupdated", listener: Windows.Foundation.EventHandler<any>): void;
        onlayoutupdated: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "loaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "loaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onloaded: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.SizeChangedEventHandler): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.SizeChangedEventHandler): void;
        onsizechanged: (ev: Windows.UI.Xaml.SizeChangedEventHandler) => void;
        addEventListener(eventName: "unloaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "unloaded", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onunloaded: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IFrameworkElementOverrides {
        measureOverride(availableSize: Windows.Foundation.Size): Windows.Foundation.Size;
        arrangeOverride(finalSize: Windows.Foundation.Size): Windows.Foundation.Size;
        onApplyTemplate(): void;
    }

    export interface IFrameworkTemplate {
    }

    export interface IFrameworkView {
    }

    export interface IFrameworkViewSource {
    }

    export interface IGridLengthHelper {
    }

    export interface IMediaFailedRoutedEventArgs {
        errorTrace: string;
    }

    export interface IPointHelper {
    }

    export interface IPropertyMetadata {
        createDefaultValueCallback: Windows.UI.Xaml.CreateDefaultValueCallback;
        defaultValue: any;
    }

    export interface IPropertyPath {
        path: string;
    }

    export interface IRectHelper {
    }

    export interface IResourceDictionary {
        mergedDictionaries: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.ResourceDictionary>;
        source: Windows.Foundation.Uri;
        themeDictionaries: Windows.Foundation.Collections.IMap<any,any>;
    }

    export interface IRoutedEvent {
    }

    export interface IRoutedEventArgs {
        originalSource: any;
    }

    export interface ISetter {
        property: Windows.UI.Xaml.DependencyProperty;
        value: any;
    }

    export interface ISetterBase {
        isSealed: boolean;
    }

    export interface ISetterBaseCollection extends Windows.Foundation.Collections.IVector<Windows.UI.Xaml.SetterBase>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.SetterBase> {
        isSealed: boolean;
    }

    export interface ISizeChangedEventArgs {
        newSize: Windows.Foundation.Size;
        previousSize: Windows.Foundation.Size;
    }

    export interface ISizeHelper {
    }

    export interface IStyle {
        seal(): void;
        basedOn: Windows.UI.Xaml.Style;
        isSealed: boolean;
        setters: Windows.UI.Xaml.SetterBaseCollection;
        targetType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface IThicknessHelper {
    }

    export interface ITriggerAction {
    }

    export interface ITriggerBase {
    }

    export interface IUIElement {
        add_KeyUp(value: Windows.UI.Xaml.Input.KeyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeyUp(token: Windows.Foundation.EventRegistrationToken): void;
        add_KeyDown(value: Windows.UI.Xaml.Input.KeyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeyDown(token: Windows.Foundation.EventRegistrationToken): void;
        add_GotFocus(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_GotFocus(token: Windows.Foundation.EventRegistrationToken): void;
        add_LostFocus(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LostFocus(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragEnter(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragEnter(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragLeave(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragLeave(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragOver(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragOver(token: Windows.Foundation.EventRegistrationToken): void;
        add_Drop(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Drop(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerPressed(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerPressed(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerMoved(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerMoved(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerReleased(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerReleased(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerEntered(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerEntered(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerExited(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerExited(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCaptureLost(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerCaptureLost(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCanceled(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerCanceled(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerWheelChanged(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerWheelChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Tapped(value: Windows.UI.Xaml.Input.TappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Tapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_DoubleTapped(value: Windows.UI.Xaml.Input.DoubleTappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DoubleTapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_Holding(value: Windows.UI.Xaml.Input.HoldingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Holding(token: Windows.Foundation.EventRegistrationToken): void;
        add_RightTapped(value: Windows.UI.Xaml.Input.RightTappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RightTapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarting(value: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarting(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationInertiaStarting(value: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationInertiaStarting(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarted(value: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationDelta(value: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationDelta(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationCompleted(value: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        measure(availableSize: Windows.Foundation.Size): void;
        arrange(finalRect: Windows.Foundation.Rect): void;
        capturePointer(value: Windows.UI.Xaml.Input.Pointer): boolean;
        releasePointerCapture(value: Windows.UI.Xaml.Input.Pointer): void;
        releasePointerCaptures(): void;
        addHandler(routedEvent: Windows.UI.Xaml.RoutedEvent, handler: any, handledEventsToo: boolean): void;
        removeHandler(routedEvent: Windows.UI.Xaml.RoutedEvent, handler: any): void;
        transformToVisual(visual: Windows.UI.Xaml.UIElement): Windows.UI.Xaml.Media.GeneralTransform;
        invalidateMeasure(): void;
        invalidateArrange(): void;
        updateLayout(): void;
        allowDrop: boolean;
        cacheMode: Windows.UI.Xaml.Media.CacheMode;
        clip: Windows.UI.Xaml.Media.RectangleGeometry;
        desiredSize: Windows.Foundation.Size;
        isDoubleTapEnabled: boolean;
        isHitTestVisible: boolean;
        isHoldingEnabled: boolean;
        isRightTapEnabled: boolean;
        isTapEnabled: boolean;
        manipulationMode: Windows.UI.Xaml.Input.ManipulationModes;
        opacity: number;
        pointerCaptures: Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Input.Pointer>;
        projection: Windows.UI.Xaml.Media.Projection;
        renderSize: Windows.Foundation.Size;
        renderTransform: Windows.UI.Xaml.Media.Transform;
        renderTransformOrigin: Windows.Foundation.Point;
        transitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        useLayoutRounding: boolean;
        visibility: Windows.UI.Xaml.Visibility;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "doubletapped", listener: Windows.UI.Xaml.Input.DoubleTappedEventHandler): void;
        removeEventListener(eventName: "doubletapped", listener: Windows.UI.Xaml.Input.DoubleTappedEventHandler): void;
        ondoubletapped: (ev: Windows.UI.Xaml.Input.DoubleTappedEventHandler) => void;
        addEventListener(eventName: "dragenter", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragenter", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragenter: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "dragleave", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragleave", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragleave: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "dragover", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragover", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragover: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "drop", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "drop", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondrop: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "gotfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "gotfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ongotfocus: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "holding", listener: Windows.UI.Xaml.Input.HoldingEventHandler): void;
        removeEventListener(eventName: "holding", listener: Windows.UI.Xaml.Input.HoldingEventHandler): void;
        onholding: (ev: Windows.UI.Xaml.Input.HoldingEventHandler) => void;
        addEventListener(eventName: "keydown", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        removeEventListener(eventName: "keydown", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        onkeydown: (ev: Windows.UI.Xaml.Input.KeyEventHandler) => void;
        addEventListener(eventName: "keyup", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        removeEventListener(eventName: "keyup", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        onkeyup: (ev: Windows.UI.Xaml.Input.KeyEventHandler) => void;
        addEventListener(eventName: "lostfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "lostfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onlostfocus: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): void;
        onmanipulationcompleted: (ev: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler) => void;
        addEventListener(eventName: "manipulationdelta", listener: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): void;
        removeEventListener(eventName: "manipulationdelta", listener: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): void;
        onmanipulationdelta: (ev: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): void;
        onmanipulationinertiastarting: (ev: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): void;
        onmanipulationstarted: (ev: Windows.UI.Xaml.Input.ManipulationStartedEventHandler) => void;
        addEventListener(eventName: "manipulationstarting", listener: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): void;
        removeEventListener(eventName: "manipulationstarting", listener: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): void;
        onmanipulationstarting: (ev: Windows.UI.Xaml.Input.ManipulationStartingEventHandler) => void;
        addEventListener(eventName: "pointercanceled", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointercanceled", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointercanceled: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointercapturelost: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerentered: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerexited: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointermoved: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerpressed: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerreleased: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerwheelchanged: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "righttapped", listener: Windows.UI.Xaml.Input.RightTappedEventHandler): void;
        removeEventListener(eventName: "righttapped", listener: Windows.UI.Xaml.Input.RightTappedEventHandler): void;
        onrighttapped: (ev: Windows.UI.Xaml.Input.RightTappedEventHandler) => void;
        addEventListener(eventName: "tapped", listener: Windows.UI.Xaml.Input.TappedEventHandler): void;
        removeEventListener(eventName: "tapped", listener: Windows.UI.Xaml.Input.TappedEventHandler): void;
        ontapped: (ev: Windows.UI.Xaml.Input.TappedEventHandler) => void;

    }

    export interface IUIElementOverrides {
        onCreateAutomationPeer(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        onDisconnectVisualChildren(): void;
        findSubElementsForTouchTargeting(point: Windows.Foundation.Point, boundingRect: Windows.Foundation.Rect): Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IIterable<Windows.Foundation.Point>>;
    }

    export interface IUnhandledExceptionEventArgs {
        exception: Windows.Foundation.HResult;
        handled: boolean;
        message: string;
    }

    export interface IVisualState {
        name: string;
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
    }

    export interface IVisualStateChangedEventArgs {
        control: Windows.UI.Xaml.Controls.Control;
        newState: Windows.UI.Xaml.VisualState;
        oldState: Windows.UI.Xaml.VisualState;
    }

    export interface IVisualStateGroup {
        add_CurrentStateChanged(value: Windows.UI.Xaml.VisualStateChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentStateChanging(value: Windows.UI.Xaml.VisualStateChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanging(token: Windows.Foundation.EventRegistrationToken): void;
        currentState: Windows.UI.Xaml.VisualState;
        name: string;
        states: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.VisualState>;
        transitions: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.VisualTransition>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        removeEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        oncurrentstatechanged: (ev: Windows.UI.Xaml.VisualStateChangedEventHandler) => void;
        addEventListener(eventName: "currentstatechanging", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        removeEventListener(eventName: "currentstatechanging", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        oncurrentstatechanging: (ev: Windows.UI.Xaml.VisualStateChangedEventHandler) => void;

    }

    export interface IVisualStateManager {
    }

    export interface IVisualStateManagerOverrides {
        goToStateCore(control: Windows.UI.Xaml.Controls.Control, templateRoot: Windows.UI.Xaml.FrameworkElement, stateName: string, group: Windows.UI.Xaml.VisualStateGroup, state: Windows.UI.Xaml.VisualState, useTransitions: boolean): boolean;
    }

    export interface IVisualStateManagerProtected {
        raiseCurrentStateChanging(stateGroup: Windows.UI.Xaml.VisualStateGroup, oldState: Windows.UI.Xaml.VisualState, newState: Windows.UI.Xaml.VisualState, control: Windows.UI.Xaml.Controls.Control): void;
        raiseCurrentStateChanged(stateGroup: Windows.UI.Xaml.VisualStateGroup, oldState: Windows.UI.Xaml.VisualState, newState: Windows.UI.Xaml.VisualState, control: Windows.UI.Xaml.Controls.Control): void;
    }

    export interface IVisualTransition {
        from: string;
        generatedDuration: Windows.UI.Xaml.Duration;
        generatedEasingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
        to: string;
    }

    export interface IWindow {
        add_Activated(value: Windows.UI.Xaml.WindowActivatedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Activated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.UI.Xaml.WindowClosedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(value: Windows.UI.Xaml.WindowSizeChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VisibilityChanged(value: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(token: Windows.Foundation.EventRegistrationToken): void;
        activate(): void;
        close(): void;
        bounds: Windows.Foundation.Rect;
        content: Windows.UI.Xaml.UIElement;
        coreWindow: Windows.UI.Core.CoreWindow;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        visible: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.UI.Xaml.WindowActivatedEventHandler): void;
        removeEventListener(eventName: "activated", listener: Windows.UI.Xaml.WindowActivatedEventHandler): void;
        onactivated: (ev: Windows.UI.Xaml.WindowActivatedEventHandler) => void;
        addEventListener(eventName: "closed", listener: Windows.UI.Xaml.WindowClosedEventHandler): void;
        removeEventListener(eventName: "closed", listener: Windows.UI.Xaml.WindowClosedEventHandler): void;
        onclosed: (ev: Windows.UI.Xaml.WindowClosedEventHandler) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.WindowSizeChangedEventHandler): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.WindowSizeChangedEventHandler): void;
        onsizechanged: (ev: Windows.UI.Xaml.WindowSizeChangedEventHandler) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): void;
        onvisibilitychanged: (ev: Windows.UI.Xaml.WindowVisibilityChangedEventHandler) => void;

    }

    export interface IWindowCreatedEventArgs {
        window: Windows.UI.Xaml.Window;
    }

    enum LineStackingStrategy {
        maxHeight,
        blockLineHeight,
        baselineToBaseline
    }

    export class MediaFailedRoutedEventArgs implements Windows.UI.Xaml.IMediaFailedRoutedEventArgs {
        errorTrace: string;
    }

    export class PointHelper implements Windows.UI.Xaml.IPointHelper {
        static fromCoordinates(x: number, y: number): Windows.Foundation.Point;
    }

    export interface PropertyChangedCallback {
        target: Windows.UI.Xaml.DependencyObject;
        detail: any[];
        type: string;
    }

    export class PropertyMetadata implements Windows.UI.Xaml.IPropertyMetadata {
        constructor(defaultValue: any);
        constructor(defaultValue: any, propertyChangedCallback: Windows.UI.Xaml.PropertyChangedCallback);
        static create(defaultValue: any): Windows.UI.Xaml.PropertyMetadata;
        static create(defaultValue: any, propertyChangedCallback: Windows.UI.Xaml.PropertyChangedCallback): Windows.UI.Xaml.PropertyMetadata;
        static create(createDefaultValueCallback: Windows.UI.Xaml.CreateDefaultValueCallback): Windows.UI.Xaml.PropertyMetadata;
        static create(createDefaultValueCallback: Windows.UI.Xaml.CreateDefaultValueCallback, propertyChangedCallback: Windows.UI.Xaml.PropertyChangedCallback): Windows.UI.Xaml.PropertyMetadata;
        createDefaultValueCallback: Windows.UI.Xaml.CreateDefaultValueCallback;
        defaultValue: any;
    }

    export class PropertyPath implements Windows.UI.Xaml.IPropertyPath {
        constructor(path: string);
        path: string;
    }

    export class RectHelper implements Windows.UI.Xaml.IRectHelper {
        static fromCoordinatesAndDimensions(x: number, y: number, width: number, height: number): Windows.Foundation.Rect;
        static fromPoints(point1: Windows.Foundation.Point, point2: Windows.Foundation.Point): Windows.Foundation.Rect;
        static fromLocationAndSize(location: Windows.Foundation.Point, size: Windows.Foundation.Size): Windows.Foundation.Rect;
        static getIsEmpty(target: Windows.Foundation.Rect): boolean;
        static getBottom(target: Windows.Foundation.Rect): number;
        static getLeft(target: Windows.Foundation.Rect): number;
        static getRight(target: Windows.Foundation.Rect): number;
        static getTop(target: Windows.Foundation.Rect): number;
        static contains(target: Windows.Foundation.Rect, point: Windows.Foundation.Point): boolean;
        static equals(target: Windows.Foundation.Rect, value: Windows.Foundation.Rect): boolean;
        static intersect(target: Windows.Foundation.Rect, rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        static union(target: Windows.Foundation.Rect, point: Windows.Foundation.Point): Windows.Foundation.Rect;
        static union(target: Windows.Foundation.Rect, rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        static empty: Windows.Foundation.Rect;
    }

    export class ResourceDictionary implements Windows.UI.Xaml.IResourceDictionary, Windows.Foundation.Collections.IMap<any,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<any,any>> {
        constructor();
        lookup(key: any): any;
        hasKey(key: any): boolean;
        getView(): Windows.Foundation.Collections.IMapView<any,any>;
        insert(key: any, value: any): boolean;
        remove(key: any): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<any,any>>;
        mergedDictionaries: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.ResourceDictionary>;
        source: Windows.Foundation.Uri;
        themeDictionaries: Windows.Foundation.Collections.IMap<any,any>;
        size: number;
    }

    export class RoutedEvent implements Windows.UI.Xaml.IRoutedEvent {
    }

    export class RoutedEventArgs implements Windows.UI.Xaml.IRoutedEventArgs {
        constructor();
        originalSource: any;
    }

    export interface RoutedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class Setter implements Windows.UI.Xaml.ISetter {
        constructor();
        constructor(targetProperty: Windows.UI.Xaml.DependencyProperty, value: any);
        property: Windows.UI.Xaml.DependencyProperty;
        value: any;
    }

    export class SetterBase implements Windows.UI.Xaml.ISetterBase {
        isSealed: boolean;
    }

    export class SetterBaseCollection implements Windows.UI.Xaml.ISetterBaseCollection, Windows.Foundation.Collections.IVector<Windows.UI.Xaml.SetterBase>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.SetterBase> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.SetterBase;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.SetterBase>;
        indexOf(value: Windows.UI.Xaml.SetterBase): SetterBaseCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.SetterBase): void;
        insertAt(index: number, value: Windows.UI.Xaml.SetterBase): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.SetterBase): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): SetterBaseCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.SetterBase[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.SetterBase>;
        isSealed: boolean;
        size: number;
    }

    interface SetterBaseCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface SetterBaseCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.SetterBase[];
    }

    export class SizeChangedEventArgs implements Windows.UI.Xaml.ISizeChangedEventArgs {
        newSize: Windows.Foundation.Size;
        previousSize: Windows.Foundation.Size;
    }

    export interface SizeChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class SizeHelper implements Windows.UI.Xaml.ISizeHelper {
        static fromDimensions(width: number, height: number): Windows.Foundation.Size;
        static getIsEmpty(target: Windows.Foundation.Size): boolean;
        static equals(target: Windows.Foundation.Size, value: Windows.Foundation.Size): boolean;
        static empty: Windows.Foundation.Size;
    }

    export class Style implements Windows.UI.Xaml.IStyle {
        constructor();
        constructor(targetType: Windows.UI.Xaml.Interop.TypeName);
        seal(): void;
        basedOn: Windows.UI.Xaml.Style;
        isSealed: boolean;
        setters: Windows.UI.Xaml.SetterBaseCollection;
        targetType: Windows.UI.Xaml.Interop.TypeName;
    }

    export class StyleTypedPropertyAttribute {
        constructor();
        property: string;
        styleTargetType: string /*System.Type?*/;
    }

    export interface SuspendingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class TemplatePartAttribute {
        constructor();
        name: string;
        type: string /*System.Type?*/;
    }

    export class TemplateVisualStateAttribute {
        constructor();
        name: string;
        groupName: string;
    }

    enum TextAlignment {
        center,
        left,
        right,
        justify
    }

    enum TextTrimming {
        none,
        wordEllipsis
    }

    enum TextWrapping {
        noWrap,
        wrap
    }

    export class Thickness {
        left: number;
        top: number;
        right: number;
        bottom: number;
    }

    export class ThicknessHelper implements Windows.UI.Xaml.IThicknessHelper {
        static fromLengths(left: number, top: number, right: number, bottom: number): Windows.UI.Xaml.Thickness;
        static fromUniformLength(uniformLength: number): Windows.UI.Xaml.Thickness;
    }

    export class TriggerAction implements Windows.UI.Xaml.ITriggerAction {
    }

    export class TriggerActionCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.TriggerAction>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.TriggerAction> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.TriggerAction;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.TriggerAction>;
        indexOf(value: Windows.UI.Xaml.TriggerAction): TriggerActionCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.TriggerAction): void;
        insertAt(index: number, value: Windows.UI.Xaml.TriggerAction): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.TriggerAction): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TriggerActionCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.TriggerAction[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.TriggerAction>;
        size: number;
    }

    interface TriggerActionCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TriggerActionCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.TriggerAction[];
    }

    export class TriggerBase implements Windows.UI.Xaml.ITriggerBase {
    }

    export class TriggerCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.TriggerBase>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.TriggerBase> {
        getAt(index: number): Windows.UI.Xaml.TriggerBase;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.TriggerBase>;
        indexOf(value: Windows.UI.Xaml.TriggerBase): TriggerCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.TriggerBase): void;
        insertAt(index: number, value: Windows.UI.Xaml.TriggerBase): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.TriggerBase): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TriggerCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.TriggerBase[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.TriggerBase>;
        size: number;
    }

    interface TriggerCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TriggerCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.TriggerBase[];
    }

    export class UIElement implements Windows.UI.Xaml.IUIElement, Windows.UI.Xaml.IUIElementOverrides {
        add_KeyUp(value: Windows.UI.Xaml.Input.KeyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeyUp(token: Windows.Foundation.EventRegistrationToken): void;
        add_KeyDown(value: Windows.UI.Xaml.Input.KeyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_KeyDown(token: Windows.Foundation.EventRegistrationToken): void;
        add_GotFocus(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_GotFocus(token: Windows.Foundation.EventRegistrationToken): void;
        add_LostFocus(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LostFocus(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragEnter(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragEnter(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragLeave(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragLeave(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragOver(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragOver(token: Windows.Foundation.EventRegistrationToken): void;
        add_Drop(value: Windows.UI.Xaml.DragEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Drop(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerPressed(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerPressed(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerMoved(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerMoved(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerReleased(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerReleased(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerEntered(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerEntered(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerExited(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerExited(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCaptureLost(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerCaptureLost(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerCanceled(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerCanceled(token: Windows.Foundation.EventRegistrationToken): void;
        add_PointerWheelChanged(value: Windows.UI.Xaml.Input.PointerEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PointerWheelChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_Tapped(value: Windows.UI.Xaml.Input.TappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Tapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_DoubleTapped(value: Windows.UI.Xaml.Input.DoubleTappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DoubleTapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_Holding(value: Windows.UI.Xaml.Input.HoldingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Holding(token: Windows.Foundation.EventRegistrationToken): void;
        add_RightTapped(value: Windows.UI.Xaml.Input.RightTappedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RightTapped(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarting(value: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarting(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationInertiaStarting(value: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationInertiaStarting(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationStarted(value: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationDelta(value: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationDelta(token: Windows.Foundation.EventRegistrationToken): void;
        add_ManipulationCompleted(value: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ManipulationCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        measure(availableSize: Windows.Foundation.Size): void;
        arrange(finalRect: Windows.Foundation.Rect): void;
        capturePointer(value: Windows.UI.Xaml.Input.Pointer): boolean;
        releasePointerCapture(value: Windows.UI.Xaml.Input.Pointer): void;
        releasePointerCaptures(): void;
        addHandler(routedEvent: Windows.UI.Xaml.RoutedEvent, handler: any, handledEventsToo: boolean): void;
        removeHandler(routedEvent: Windows.UI.Xaml.RoutedEvent, handler: any): void;
        transformToVisual(visual: Windows.UI.Xaml.UIElement): Windows.UI.Xaml.Media.GeneralTransform;
        invalidateMeasure(): void;
        invalidateArrange(): void;
        updateLayout(): void;
        onCreateAutomationPeer(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        onDisconnectVisualChildren(): void;
        findSubElementsForTouchTargeting(point: Windows.Foundation.Point, boundingRect: Windows.Foundation.Rect): Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IIterable<Windows.Foundation.Point>>;
        allowDrop: boolean;
        cacheMode: Windows.UI.Xaml.Media.CacheMode;
        clip: Windows.UI.Xaml.Media.RectangleGeometry;
        desiredSize: Windows.Foundation.Size;
        isDoubleTapEnabled: boolean;
        isHitTestVisible: boolean;
        isHoldingEnabled: boolean;
        isRightTapEnabled: boolean;
        isTapEnabled: boolean;
        manipulationMode: Windows.UI.Xaml.Input.ManipulationModes;
        opacity: number;
        pointerCaptures: Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Input.Pointer>;
        projection: Windows.UI.Xaml.Media.Projection;
        renderSize: Windows.Foundation.Size;
        renderTransform: Windows.UI.Xaml.Media.Transform;
        renderTransformOrigin: Windows.Foundation.Point;
        transitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        useLayoutRounding: boolean;
        visibility: Windows.UI.Xaml.Visibility;
        static allowDropProperty: Windows.UI.Xaml.DependencyProperty;
        static cacheModeProperty: Windows.UI.Xaml.DependencyProperty;
        static clipProperty: Windows.UI.Xaml.DependencyProperty;
        static doubleTappedEvent: Windows.UI.Xaml.RoutedEvent;
        static dragEnterEvent: Windows.UI.Xaml.RoutedEvent;
        static dragLeaveEvent: Windows.UI.Xaml.RoutedEvent;
        static dragOverEvent: Windows.UI.Xaml.RoutedEvent;
        static dropEvent: Windows.UI.Xaml.RoutedEvent;
        static holdingEvent: Windows.UI.Xaml.RoutedEvent;
        static isDoubleTapEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isHitTestVisibleProperty: Windows.UI.Xaml.DependencyProperty;
        static isHoldingEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isRightTapEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isTapEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static keyDownEvent: Windows.UI.Xaml.RoutedEvent;
        static keyUpEvent: Windows.UI.Xaml.RoutedEvent;
        static manipulationCompletedEvent: Windows.UI.Xaml.RoutedEvent;
        static manipulationDeltaEvent: Windows.UI.Xaml.RoutedEvent;
        static manipulationInertiaStartingEvent: Windows.UI.Xaml.RoutedEvent;
        static manipulationModeProperty: Windows.UI.Xaml.DependencyProperty;
        static manipulationStartedEvent: Windows.UI.Xaml.RoutedEvent;
        static manipulationStartingEvent: Windows.UI.Xaml.RoutedEvent;
        static opacityProperty: Windows.UI.Xaml.DependencyProperty;
        static pointerCanceledEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerCaptureLostEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerCapturesProperty: Windows.UI.Xaml.DependencyProperty;
        static pointerEnteredEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerExitedEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerMovedEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerPressedEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerReleasedEvent: Windows.UI.Xaml.RoutedEvent;
        static pointerWheelChangedEvent: Windows.UI.Xaml.RoutedEvent;
        static projectionProperty: Windows.UI.Xaml.DependencyProperty;
        static renderTransformOriginProperty: Windows.UI.Xaml.DependencyProperty;
        static renderTransformProperty: Windows.UI.Xaml.DependencyProperty;
        static rightTappedEvent: Windows.UI.Xaml.RoutedEvent;
        static tappedEvent: Windows.UI.Xaml.RoutedEvent;
        static transitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static useLayoutRoundingProperty: Windows.UI.Xaml.DependencyProperty;
        static visibilityProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "doubletapped", listener: Windows.UI.Xaml.Input.DoubleTappedEventHandler): void;
        removeEventListener(eventName: "doubletapped", listener: Windows.UI.Xaml.Input.DoubleTappedEventHandler): void;
        ondoubletapped: (ev: Windows.UI.Xaml.Input.DoubleTappedEventHandler) => void;
        addEventListener(eventName: "dragenter", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragenter", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragenter: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "dragleave", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragleave", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragleave: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "dragover", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "dragover", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondragover: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "drop", listener: Windows.UI.Xaml.DragEventHandler): void;
        removeEventListener(eventName: "drop", listener: Windows.UI.Xaml.DragEventHandler): void;
        ondrop: (ev: Windows.UI.Xaml.DragEventHandler) => void;
        addEventListener(eventName: "gotfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "gotfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ongotfocus: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "holding", listener: Windows.UI.Xaml.Input.HoldingEventHandler): void;
        removeEventListener(eventName: "holding", listener: Windows.UI.Xaml.Input.HoldingEventHandler): void;
        onholding: (ev: Windows.UI.Xaml.Input.HoldingEventHandler) => void;
        addEventListener(eventName: "keydown", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        removeEventListener(eventName: "keydown", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        onkeydown: (ev: Windows.UI.Xaml.Input.KeyEventHandler) => void;
        addEventListener(eventName: "keyup", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        removeEventListener(eventName: "keyup", listener: Windows.UI.Xaml.Input.KeyEventHandler): void;
        onkeyup: (ev: Windows.UI.Xaml.Input.KeyEventHandler) => void;
        addEventListener(eventName: "lostfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "lostfocus", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onlostfocus: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "manipulationcompleted", listener: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): void;
        removeEventListener(eventName: "manipulationcompleted", listener: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler): void;
        onmanipulationcompleted: (ev: Windows.UI.Xaml.Input.ManipulationCompletedEventHandler) => void;
        addEventListener(eventName: "manipulationdelta", listener: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): void;
        removeEventListener(eventName: "manipulationdelta", listener: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler): void;
        onmanipulationdelta: (ev: Windows.UI.Xaml.Input.ManipulationDeltaEventHandler) => void;
        addEventListener(eventName: "manipulationinertiastarting", listener: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): void;
        removeEventListener(eventName: "manipulationinertiastarting", listener: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler): void;
        onmanipulationinertiastarting: (ev: Windows.UI.Xaml.Input.ManipulationInertiaStartingEventHandler) => void;
        addEventListener(eventName: "manipulationstarted", listener: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): void;
        removeEventListener(eventName: "manipulationstarted", listener: Windows.UI.Xaml.Input.ManipulationStartedEventHandler): void;
        onmanipulationstarted: (ev: Windows.UI.Xaml.Input.ManipulationStartedEventHandler) => void;
        addEventListener(eventName: "manipulationstarting", listener: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): void;
        removeEventListener(eventName: "manipulationstarting", listener: Windows.UI.Xaml.Input.ManipulationStartingEventHandler): void;
        onmanipulationstarting: (ev: Windows.UI.Xaml.Input.ManipulationStartingEventHandler) => void;
        addEventListener(eventName: "pointercanceled", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointercanceled", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointercanceled: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointercapturelost", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointercapturelost", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointercapturelost: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerentered", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerentered", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerentered: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerexited", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerexited", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerexited: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointermoved", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointermoved", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointermoved: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerpressed", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerpressed", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerpressed: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerreleased", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerreleased", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerreleased: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "pointerwheelchanged", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        removeEventListener(eventName: "pointerwheelchanged", listener: Windows.UI.Xaml.Input.PointerEventHandler): void;
        onpointerwheelchanged: (ev: Windows.UI.Xaml.Input.PointerEventHandler) => void;
        addEventListener(eventName: "righttapped", listener: Windows.UI.Xaml.Input.RightTappedEventHandler): void;
        removeEventListener(eventName: "righttapped", listener: Windows.UI.Xaml.Input.RightTappedEventHandler): void;
        onrighttapped: (ev: Windows.UI.Xaml.Input.RightTappedEventHandler) => void;
        addEventListener(eventName: "tapped", listener: Windows.UI.Xaml.Input.TappedEventHandler): void;
        removeEventListener(eventName: "tapped", listener: Windows.UI.Xaml.Input.TappedEventHandler): void;
        ontapped: (ev: Windows.UI.Xaml.Input.TappedEventHandler) => void;

    }

    export class UnhandledExceptionEventArgs implements Windows.UI.Xaml.IUnhandledExceptionEventArgs {
        exception: Windows.Foundation.HResult;
        handled: boolean;
        message: string;
    }

    export interface UnhandledExceptionEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum VerticalAlignment {
        top,
        center,
        bottom,
        stretch
    }

    enum Visibility {
        visible,
        collapsed
    }

    export class VisualState implements Windows.UI.Xaml.IVisualState {
        constructor();
        name: string;
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
    }

    export class VisualStateChangedEventArgs implements Windows.UI.Xaml.IVisualStateChangedEventArgs {
        constructor();
        control: Windows.UI.Xaml.Controls.Control;
        newState: Windows.UI.Xaml.VisualState;
        oldState: Windows.UI.Xaml.VisualState;
    }

    export interface VisualStateChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class VisualStateGroup implements Windows.UI.Xaml.IVisualStateGroup {
        constructor();
        add_CurrentStateChanged(value: Windows.UI.Xaml.VisualStateChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentStateChanging(value: Windows.UI.Xaml.VisualStateChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanging(token: Windows.Foundation.EventRegistrationToken): void;
        currentState: Windows.UI.Xaml.VisualState;
        name: string;
        states: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.VisualState>;
        transitions: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.VisualTransition>;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        removeEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        oncurrentstatechanged: (ev: Windows.UI.Xaml.VisualStateChangedEventHandler) => void;
        addEventListener(eventName: "currentstatechanging", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        removeEventListener(eventName: "currentstatechanging", listener: Windows.UI.Xaml.VisualStateChangedEventHandler): void;
        oncurrentstatechanging: (ev: Windows.UI.Xaml.VisualStateChangedEventHandler) => void;

    }

    export class VisualStateManager implements Windows.UI.Xaml.IVisualStateManager, Windows.UI.Xaml.IVisualStateManagerOverrides, Windows.UI.Xaml.IVisualStateManagerProtected {
        constructor();
        goToStateCore(control: Windows.UI.Xaml.Controls.Control, templateRoot: Windows.UI.Xaml.FrameworkElement, stateName: string, group: Windows.UI.Xaml.VisualStateGroup, state: Windows.UI.Xaml.VisualState, useTransitions: boolean): boolean;
        raiseCurrentStateChanging(stateGroup: Windows.UI.Xaml.VisualStateGroup, oldState: Windows.UI.Xaml.VisualState, newState: Windows.UI.Xaml.VisualState, control: Windows.UI.Xaml.Controls.Control): void;
        raiseCurrentStateChanged(stateGroup: Windows.UI.Xaml.VisualStateGroup, oldState: Windows.UI.Xaml.VisualState, newState: Windows.UI.Xaml.VisualState, control: Windows.UI.Xaml.Controls.Control): void;
        static getVisualStateGroups(obj: Windows.UI.Xaml.FrameworkElement): Windows.Foundation.Collections.IVector<Windows.UI.Xaml.VisualStateGroup>;
        static getCustomVisualStateManager(obj: Windows.UI.Xaml.FrameworkElement): Windows.UI.Xaml.VisualStateManager;
        static setCustomVisualStateManager(obj: Windows.UI.Xaml.FrameworkElement, value: Windows.UI.Xaml.VisualStateManager): void;
        static goToState(control: Windows.UI.Xaml.Controls.Control, stateName: string, useTransitions: boolean): boolean;
        static customVisualStateManagerProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class VisualTransition implements Windows.UI.Xaml.IVisualTransition {
        constructor();
        from: string;
        generatedDuration: Windows.UI.Xaml.Duration;
        generatedEasingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
        to: string;
    }

    export class Window implements Windows.UI.Xaml.IWindow {
        add_Activated(value: Windows.UI.Xaml.WindowActivatedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Activated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.UI.Xaml.WindowClosedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        add_SizeChanged(value: Windows.UI.Xaml.WindowSizeChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SizeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VisibilityChanged(value: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_VisibilityChanged(token: Windows.Foundation.EventRegistrationToken): void;
        activate(): void;
        close(): void;
        bounds: Windows.Foundation.Rect;
        content: Windows.UI.Xaml.UIElement;
        coreWindow: Windows.UI.Core.CoreWindow;
        dispatcher: Windows.UI.Core.CoreDispatcher;
        visible: boolean;
        static current: Windows.UI.Xaml.Window;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "activated", listener: Windows.UI.Xaml.WindowActivatedEventHandler): void;
        removeEventListener(eventName: "activated", listener: Windows.UI.Xaml.WindowActivatedEventHandler): void;
        onactivated: (ev: Windows.UI.Xaml.WindowActivatedEventHandler) => void;
        addEventListener(eventName: "closed", listener: Windows.UI.Xaml.WindowClosedEventHandler): void;
        removeEventListener(eventName: "closed", listener: Windows.UI.Xaml.WindowClosedEventHandler): void;
        onclosed: (ev: Windows.UI.Xaml.WindowClosedEventHandler) => void;
        addEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.WindowSizeChangedEventHandler): void;
        removeEventListener(eventName: "sizechanged", listener: Windows.UI.Xaml.WindowSizeChangedEventHandler): void;
        onsizechanged: (ev: Windows.UI.Xaml.WindowSizeChangedEventHandler) => void;
        addEventListener(eventName: "visibilitychanged", listener: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): void;
        removeEventListener(eventName: "visibilitychanged", listener: Windows.UI.Xaml.WindowVisibilityChangedEventHandler): void;
        onvisibilitychanged: (ev: Windows.UI.Xaml.WindowVisibilityChangedEventHandler) => void;

    }

    export interface WindowActivatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface WindowClosedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class WindowCreatedEventArgs implements Windows.UI.Xaml.IWindowCreatedEventArgs {
        window: Windows.UI.Xaml.Window;
    }

    export interface WindowSizeChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface WindowVisibilityChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

}
declare module Windows.UI.Xaml.Automation {

    export class AnnotationPatternIdentifiers implements Windows.UI.Xaml.Automation.IAnnotationPatternIdentifiers {
        static annotationTypeIdProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static annotationTypeNameProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static authorProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static dateTimeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static targetProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class AutomationElementIdentifiers implements Windows.UI.Xaml.Automation.IAutomationElementIdentifiers {
        static acceleratorKeyProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static accessKeyProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static automationIdProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static boundingRectangleProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static classNameProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static clickablePointProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static controlTypeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static hasKeyboardFocusProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static helpTextProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isContentElementProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isControlElementProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isEnabledProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isKeyboardFocusableProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isOffscreenProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isPasswordProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isRequiredForFormProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static itemStatusProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static itemTypeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static labeledByProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static liveSettingProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static localizedControlTypeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static nameProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static orientationProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class AutomationProperties implements Windows.UI.Xaml.Automation.IAutomationProperties {
        static getAcceleratorKey(element: Windows.UI.Xaml.DependencyObject): string;
        static setAcceleratorKey(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getAccessKey(element: Windows.UI.Xaml.DependencyObject): string;
        static setAccessKey(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getAutomationId(element: Windows.UI.Xaml.DependencyObject): string;
        static setAutomationId(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getHelpText(element: Windows.UI.Xaml.DependencyObject): string;
        static setHelpText(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getIsRequiredForForm(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsRequiredForForm(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getItemStatus(element: Windows.UI.Xaml.DependencyObject): string;
        static setItemStatus(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getItemType(element: Windows.UI.Xaml.DependencyObject): string;
        static setItemType(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getLabeledBy(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.UIElement;
        static setLabeledBy(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.UIElement): void;
        static getName(element: Windows.UI.Xaml.DependencyObject): string;
        static setName(element: Windows.UI.Xaml.DependencyObject, value: string): void;
        static getLiveSetting(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting;
        static setLiveSetting(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting): void;
        static acceleratorKeyProperty: Windows.UI.Xaml.DependencyProperty;
        static accessKeyProperty: Windows.UI.Xaml.DependencyProperty;
        static automationIdProperty: Windows.UI.Xaml.DependencyProperty;
        static helpTextProperty: Windows.UI.Xaml.DependencyProperty;
        static isRequiredForFormProperty: Windows.UI.Xaml.DependencyProperty;
        static itemStatusProperty: Windows.UI.Xaml.DependencyProperty;
        static itemTypeProperty: Windows.UI.Xaml.DependencyProperty;
        static labeledByProperty: Windows.UI.Xaml.DependencyProperty;
        static liveSettingProperty: Windows.UI.Xaml.DependencyProperty;
        static nameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class AutomationProperty implements Windows.UI.Xaml.Automation.IAutomationProperty {
    }

    export class DockPatternIdentifiers implements Windows.UI.Xaml.Automation.IDockPatternIdentifiers {
        static dockPositionProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum DockPosition {
        top,
        left,
        bottom,
        right,
        fill,
        none
    }

    export class DragPatternIdentifiers implements Windows.UI.Xaml.Automation.IDragPatternIdentifiers {
        static dropEffectProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static dropEffectsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static grabbedItemsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isGrabbedProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class DropTargetPatternIdentifiers implements Windows.UI.Xaml.Automation.IDropTargetPatternIdentifiers {
        static dropTargetEffectProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static dropTargetEffectsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class ExpandCollapsePatternIdentifiers implements Windows.UI.Xaml.Automation.IExpandCollapsePatternIdentifiers {
        static expandCollapseStateProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum ExpandCollapseState {
        collapsed,
        expanded,
        partiallyExpanded,
        leafNode
    }

    export class GridItemPatternIdentifiers implements Windows.UI.Xaml.Automation.IGridItemPatternIdentifiers {
        static columnProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static columnSpanProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static containingGridProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowSpanProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class GridPatternIdentifiers implements Windows.UI.Xaml.Automation.IGridPatternIdentifiers {
        static columnCountProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowCountProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export interface IAnnotationPatternIdentifiers {
    }

    export interface IAutomationElementIdentifiers {
    }

    export interface IAutomationProperties {
    }

    export interface IAutomationProperty {
    }

    export interface IDockPatternIdentifiers {
    }

    export interface IDragPatternIdentifiers {
    }

    export interface IDropTargetPatternIdentifiers {
    }

    export interface IExpandCollapsePatternIdentifiers {
    }

    export interface IGridItemPatternIdentifiers {
    }

    export interface IGridPatternIdentifiers {
    }

    export interface IMultipleViewPatternIdentifiers {
    }

    export interface IRangeValuePatternIdentifiers {
    }

    export interface IScrollPatternIdentifiers {
    }

    export interface ISelectionItemPatternIdentifiers {
    }

    export interface ISelectionPatternIdentifiers {
    }

    export interface ITableItemPatternIdentifiers {
    }

    export interface ITablePatternIdentifiers {
    }

    export interface ITogglePatternIdentifiers {
    }

    export interface ITransformPatternIdentifiers {
    }

    export interface IValuePatternIdentifiers {
    }

    export interface IWindowPatternIdentifiers {
    }

    export class MultipleViewPatternIdentifiers implements Windows.UI.Xaml.Automation.IMultipleViewPatternIdentifiers {
        static currentViewProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static supportedViewsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class RangeValuePatternIdentifiers implements Windows.UI.Xaml.Automation.IRangeValuePatternIdentifiers {
        static isReadOnlyProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static largeChangeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static maximumProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static minimumProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static smallChangeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static valueProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum RowOrColumnMajor {
        rowMajor,
        columnMajor,
        indeterminate
    }

    enum ScrollAmount {
        largeDecrement,
        smallDecrement,
        noAmount,
        largeIncrement,
        smallIncrement
    }

    export class ScrollPatternIdentifiers implements Windows.UI.Xaml.Automation.IScrollPatternIdentifiers {
        static horizontalScrollPercentProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static horizontalViewSizeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static horizontallyScrollableProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static noScroll: number;
        static verticalScrollPercentProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static verticalViewSizeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static verticallyScrollableProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class SelectionItemPatternIdentifiers implements Windows.UI.Xaml.Automation.ISelectionItemPatternIdentifiers {
        static isSelectedProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static selectionContainerProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class SelectionPatternIdentifiers implements Windows.UI.Xaml.Automation.ISelectionPatternIdentifiers {
        static canSelectMultipleProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isSelectionRequiredProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static selectionProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum SupportedTextSelection {
        none,
        single,
        multiple
    }

    export class TableItemPatternIdentifiers implements Windows.UI.Xaml.Automation.ITableItemPatternIdentifiers {
        static columnHeaderItemsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowHeaderItemsProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class TablePatternIdentifiers implements Windows.UI.Xaml.Automation.ITablePatternIdentifiers {
        static columnHeadersProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowHeadersProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static rowOrColumnMajorProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class TogglePatternIdentifiers implements Windows.UI.Xaml.Automation.ITogglePatternIdentifiers {
        static toggleStateProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum ToggleState {
        off,
        on,
        indeterminate
    }

    export class TransformPatternIdentifiers implements Windows.UI.Xaml.Automation.ITransformPatternIdentifiers {
        static canMoveProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static canResizeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static canRotateProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    export class ValuePatternIdentifiers implements Windows.UI.Xaml.Automation.IValuePatternIdentifiers {
        static isReadOnlyProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static valueProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum WindowInteractionState {
        running,
        closing,
        readyForUserInteraction,
        blockedByModalWindow,
        notResponding
    }

    export class WindowPatternIdentifiers implements Windows.UI.Xaml.Automation.IWindowPatternIdentifiers {
        static canMaximizeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static canMinimizeProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isModalProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static isTopmostProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static windowInteractionStateProperty: Windows.UI.Xaml.Automation.AutomationProperty;
        static windowVisualStateProperty: Windows.UI.Xaml.Automation.AutomationProperty;
    }

    enum WindowVisualState {
        normal,
        maximized,
        minimized
    }

}
declare module Windows.UI.Xaml.Automation.Peers {

    export class AppBarAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IAppBarAutomationPeer, Windows.UI.Xaml.Automation.Provider.IToggleProvider {
        constructor(owner: Windows.UI.Xaml.Controls.AppBar);
        toggle(): void;
        toggleState: Windows.UI.Xaml.Automation.ToggleState;
    }

    enum AutomationControlType {
        button,
        calendar,
        checkBox,
        comboBox,
        edit,
        hyperlink,
        image,
        listItem,
        list,
        menu,
        menuBar,
        menuItem,
        progressBar,
        radioButton,
        scrollBar,
        slider,
        spinner,
        statusBar,
        tab,
        tabItem,
        text,
        toolBar,
        toolTip,
        tree,
        treeItem,
        custom,
        group,
        thumb,
        dataGrid,
        dataItem,
        document,
        splitButton,
        window,
        pane,
        header,
        headerItem,
        table,
        titleBar,
        separator,
        semanticZoom
    }

    enum AutomationEvents {
        toolTipOpened,
        toolTipClosed,
        menuOpened,
        menuClosed,
        automationFocusChanged,
        invokePatternOnInvoked,
        selectionItemPatternOnElementAddedToSelection,
        selectionItemPatternOnElementRemovedFromSelection,
        selectionItemPatternOnElementSelected,
        selectionPatternOnInvalidated,
        textPatternOnTextSelectionChanged,
        textPatternOnTextChanged,
        asyncContentLoaded,
        propertyChanged,
        structureChanged,
        dragStart,
        dragCancel,
        dragComplete,
        dragEnter,
        dragLeave,
        dropped,
        liveRegionChanged
    }

    enum AutomationLiveSetting {
        off,
        polite,
        assertive
    }

    enum AutomationOrientation {
        none,
        horizontal,
        vertical
    }

    export class AutomationPeer implements Windows.UI.Xaml.Automation.Peers.IAutomationPeer, Windows.UI.Xaml.Automation.Peers.IAutomationPeerOverrides, Windows.UI.Xaml.Automation.Peers.IAutomationPeerProtected {
        constructor();
        getPattern(patternInterface: Windows.UI.Xaml.Automation.Peers.PatternInterface): any;
        raiseAutomationEvent(eventId: Windows.UI.Xaml.Automation.Peers.AutomationEvents): void;
        raisePropertyChangedEvent(automationProperty: Windows.UI.Xaml.Automation.AutomationProperty, oldValue: any, newValue: any): void;
        getAcceleratorKey(): string;
        getAccessKey(): string;
        getAutomationControlType(): Windows.UI.Xaml.Automation.Peers.AutomationControlType;
        getAutomationId(): string;
        getBoundingRectangle(): Windows.Foundation.Rect;
        getChildren(): Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Automation.Peers.AutomationPeer>;
        getClassName(): string;
        getClickablePoint(): Windows.Foundation.Point;
        getHelpText(): string;
        getItemStatus(): string;
        getItemType(): string;
        getLabeledBy(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLocalizedControlType(): string;
        getName(): string;
        getOrientation(): Windows.UI.Xaml.Automation.Peers.AutomationOrientation;
        hasKeyboardFocus(): boolean;
        isContentElement(): boolean;
        isControlElement(): boolean;
        isEnabled(): boolean;
        isKeyboardFocusable(): boolean;
        isOffscreen(): boolean;
        isPassword(): boolean;
        isRequiredForForm(): boolean;
        setFocus(): void;
        getParent(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        invalidatePeer(): void;
        getPeerFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLiveSetting(): Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting;
        getPatternCore(patternInterface: Windows.UI.Xaml.Automation.Peers.PatternInterface): any;
        getAcceleratorKeyCore(): string;
        getAccessKeyCore(): string;
        getAutomationControlTypeCore(): Windows.UI.Xaml.Automation.Peers.AutomationControlType;
        getAutomationIdCore(): string;
        getBoundingRectangleCore(): Windows.Foundation.Rect;
        getChildrenCore(): Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Automation.Peers.AutomationPeer>;
        getClassNameCore(): string;
        getClickablePointCore(): Windows.Foundation.Point;
        getHelpTextCore(): string;
        getItemStatusCore(): string;
        getItemTypeCore(): string;
        getLabeledByCore(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLocalizedControlTypeCore(): string;
        getNameCore(): string;
        getOrientationCore(): Windows.UI.Xaml.Automation.Peers.AutomationOrientation;
        hasKeyboardFocusCore(): boolean;
        isContentElementCore(): boolean;
        isControlElementCore(): boolean;
        isEnabledCore(): boolean;
        isKeyboardFocusableCore(): boolean;
        isOffscreenCore(): boolean;
        isPasswordCore(): boolean;
        isRequiredForFormCore(): boolean;
        setFocusCore(): void;
        getPeerFromPointCore(point: Windows.Foundation.Point): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLiveSettingCore(): Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting;
        peerFromProvider(provider: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        providerFromPeer(peer: Windows.UI.Xaml.Automation.Peers.AutomationPeer): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
        static listenerExists(eventId: Windows.UI.Xaml.Automation.Peers.AutomationEvents): boolean;
        eventsSource: Windows.UI.Xaml.Automation.Peers.AutomationPeer;
    }

    export class ButtonAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IButtonAutomationPeer, Windows.UI.Xaml.Automation.Provider.IInvokeProvider {
        constructor(owner: Windows.UI.Xaml.Controls.Button);
        invoke(): void;
    }

    export class ButtonBaseAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IButtonBaseAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.ButtonBase);
    }

    export class CaptureElementAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ICaptureElementAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.CaptureElement);
    }

    export class CheckBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ICheckBoxAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.CheckBox);
    }

    export class ComboBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IComboBoxAutomationPeer, Windows.UI.Xaml.Automation.Provider.IValueProvider, Windows.UI.Xaml.Automation.Provider.IExpandCollapseProvider {
        constructor(owner: Windows.UI.Xaml.Controls.ComboBox);
        setValue(value: string): void;
        collapse(): void;
        expand(): void;
        isReadOnly: boolean;
        value: string;
        expandCollapseState: Windows.UI.Xaml.Automation.ExpandCollapseState;
    }

    export class ComboBoxItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IComboBoxItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ComboBoxItem);
    }

    export class ComboBoxItemDataAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IComboBoxItemDataAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer);
        scrollIntoView(): void;
    }

    export class FlipViewAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IFlipViewAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.FlipView);
    }

    export class FlipViewItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IFlipViewItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.FlipViewItem);
    }

    export class FlipViewItemDataAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IFlipViewItemDataAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.FlipViewAutomationPeer);
        scrollIntoView(): void;
    }

    export class FrameworkElementAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IFrameworkElementAutomationPeer {
        constructor(owner: Windows.UI.Xaml.FrameworkElement);
        static fromElement(element: Windows.UI.Xaml.UIElement): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        static createPeerForElement(element: Windows.UI.Xaml.UIElement): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        owner: Windows.UI.Xaml.UIElement;
    }

    export class GridViewAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IGridViewAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.GridView);
    }

    export class GridViewItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IGridViewItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.GridViewItem);
    }

    export class GridViewItemDataAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IGridViewItemDataAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.GridViewAutomationPeer);
        scrollIntoView(): void;
    }

    export class GroupItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IGroupItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.GroupItem);
    }

    export class HyperlinkButtonAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IHyperlinkButtonAutomationPeer, Windows.UI.Xaml.Automation.Provider.IInvokeProvider {
        constructor(owner: Windows.UI.Xaml.Controls.HyperlinkButton);
        invoke(): void;
    }

    export interface IAppBarAutomationPeer {
    }

    export interface IAutomationPeer {
        getPattern(patternInterface: Windows.UI.Xaml.Automation.Peers.PatternInterface): any;
        raiseAutomationEvent(eventId: Windows.UI.Xaml.Automation.Peers.AutomationEvents): void;
        raisePropertyChangedEvent(automationProperty: Windows.UI.Xaml.Automation.AutomationProperty, oldValue: any, newValue: any): void;
        getAcceleratorKey(): string;
        getAccessKey(): string;
        getAutomationControlType(): Windows.UI.Xaml.Automation.Peers.AutomationControlType;
        getAutomationId(): string;
        getBoundingRectangle(): Windows.Foundation.Rect;
        getChildren(): Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Automation.Peers.AutomationPeer>;
        getClassName(): string;
        getClickablePoint(): Windows.Foundation.Point;
        getHelpText(): string;
        getItemStatus(): string;
        getItemType(): string;
        getLabeledBy(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLocalizedControlType(): string;
        getName(): string;
        getOrientation(): Windows.UI.Xaml.Automation.Peers.AutomationOrientation;
        hasKeyboardFocus(): boolean;
        isContentElement(): boolean;
        isControlElement(): boolean;
        isEnabled(): boolean;
        isKeyboardFocusable(): boolean;
        isOffscreen(): boolean;
        isPassword(): boolean;
        isRequiredForForm(): boolean;
        setFocus(): void;
        getParent(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        invalidatePeer(): void;
        getPeerFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLiveSetting(): Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting;
        eventsSource: Windows.UI.Xaml.Automation.Peers.AutomationPeer;
    }

    export interface IAutomationPeerOverrides {
        getPatternCore(patternInterface: Windows.UI.Xaml.Automation.Peers.PatternInterface): any;
        getAcceleratorKeyCore(): string;
        getAccessKeyCore(): string;
        getAutomationControlTypeCore(): Windows.UI.Xaml.Automation.Peers.AutomationControlType;
        getAutomationIdCore(): string;
        getBoundingRectangleCore(): Windows.Foundation.Rect;
        getChildrenCore(): Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Automation.Peers.AutomationPeer>;
        getClassNameCore(): string;
        getClickablePointCore(): Windows.Foundation.Point;
        getHelpTextCore(): string;
        getItemStatusCore(): string;
        getItemTypeCore(): string;
        getLabeledByCore(): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLocalizedControlTypeCore(): string;
        getNameCore(): string;
        getOrientationCore(): Windows.UI.Xaml.Automation.Peers.AutomationOrientation;
        hasKeyboardFocusCore(): boolean;
        isContentElementCore(): boolean;
        isControlElementCore(): boolean;
        isEnabledCore(): boolean;
        isKeyboardFocusableCore(): boolean;
        isOffscreenCore(): boolean;
        isPasswordCore(): boolean;
        isRequiredForFormCore(): boolean;
        setFocusCore(): void;
        getPeerFromPointCore(point: Windows.Foundation.Point): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        getLiveSettingCore(): Windows.UI.Xaml.Automation.Peers.AutomationLiveSetting;
    }

    export interface IAutomationPeerProtected {
        peerFromProvider(provider: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple): Windows.UI.Xaml.Automation.Peers.AutomationPeer;
        providerFromPeer(peer: Windows.UI.Xaml.Automation.Peers.AutomationPeer): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export interface IButtonAutomationPeer {
    }

    export interface IButtonBaseAutomationPeer {
    }

    export interface ICaptureElementAutomationPeer {
    }

    export interface ICheckBoxAutomationPeer {
    }

    export interface IComboBoxAutomationPeer {
    }

    export interface IComboBoxItemAutomationPeer {
    }

    export interface IComboBoxItemDataAutomationPeer {
    }

    export interface IFlipViewAutomationPeer {
    }

    export interface IFlipViewItemAutomationPeer {
    }

    export interface IFlipViewItemDataAutomationPeer {
    }

    export interface IFrameworkElementAutomationPeer {
        owner: Windows.UI.Xaml.UIElement;
    }

    export interface IGridViewAutomationPeer {
    }

    export interface IGridViewItemAutomationPeer {
    }

    export interface IGridViewItemDataAutomationPeer {
    }

    export interface IGroupItemAutomationPeer {
    }

    export interface IHyperlinkButtonAutomationPeer {
    }

    export interface IImageAutomationPeer {
    }

    export interface IItemAutomationPeer {
        item: any;
        itemsControlAutomationPeer: Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer;
    }

    export interface IItemsControlAutomationPeer {
    }

    export interface IListBoxAutomationPeer {
    }

    export interface IListBoxItemAutomationPeer {
    }

    export interface IListBoxItemDataAutomationPeer {
    }

    export interface IListViewAutomationPeer {
    }

    export interface IListViewBaseAutomationPeer {
    }

    export interface IListViewItemAutomationPeer {
    }

    export interface IListViewItemDataAutomationPeer {
    }

    export class ImageAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IImageAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.Image);
    }

    export interface IMediaElementAutomationPeer {
    }

    export interface IPasswordBoxAutomationPeer {
    }

    export interface IProgressBarAutomationPeer {
    }

    export interface IProgressRingAutomationPeer {
    }

    export interface IRadioButtonAutomationPeer {
    }

    export interface IRangeBaseAutomationPeer {
    }

    export interface IRepeatButtonAutomationPeer {
    }

    export interface IRichEditBoxAutomationPeer {
    }

    export interface IRichTextBlockAutomationPeer {
    }

    export interface IRichTextBlockOverflowAutomationPeer {
    }

    export interface IScrollBarAutomationPeer {
    }

    export interface IScrollViewerAutomationPeer {
    }

    export interface ISelectorAutomationPeer {
    }

    export interface ISelectorItemAutomationPeer {
    }

    export interface ISemanticZoomAutomationPeer {
    }

    export interface ISliderAutomationPeer {
    }

    export class ItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IItemAutomationPeer, Windows.UI.Xaml.Automation.Provider.IVirtualizedItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer);
        realize(): void;
        item: any;
        itemsControlAutomationPeer: Windows.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer;
    }

    export class ItemsControlAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IItemsControlAutomationPeer, Windows.UI.Xaml.Automation.Provider.IItemContainerProvider {
        constructor(owner: Windows.UI.Xaml.Controls.ItemsControl);
        findItemByProperty(startAfter: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple, automationProperty: Windows.UI.Xaml.Automation.AutomationProperty, value: any): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export interface ITextBlockAutomationPeer {
    }

    export interface ITextBoxAutomationPeer {
    }

    export interface IThumbAutomationPeer {
    }

    export interface IToggleButtonAutomationPeer {
    }

    export interface IToggleSwitchAutomationPeer {
    }

    export class ListBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListBoxAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ListBox);
    }

    export class ListBoxItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListBoxItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ListBoxItem);
    }

    export class ListBoxItemDataAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListBoxItemDataAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.ListBoxAutomationPeer);
        scrollIntoView(): void;
    }

    export class ListViewAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListViewAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ListView);
    }

    export class ListViewBaseAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListViewBaseAutomationPeer, Windows.UI.Xaml.Automation.Provider.IDropTargetProvider {
        constructor(owner: Windows.UI.Xaml.Controls.ListViewBase);
        dropEffect: string;
        dropEffects: string[];
    }

    export class ListViewItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListViewItemAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ListViewItem);
    }

    export class ListViewItemDataAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IListViewItemDataAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer);
        scrollIntoView(): void;
    }

    export class MediaElementAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IMediaElementAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.MediaElement);
    }

    export class PasswordBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IPasswordBoxAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.PasswordBox);
    }

    enum PatternInterface {
        invoke,
        selection,
        value,
        rangeValue,
        scroll,
        scrollItem,
        expandCollapse,
        grid,
        gridItem,
        multipleView,
        window,
        selectionItem,
        dock,
        table,
        tableItem,
        toggle,
        transform,
        text,
        itemContainer,
        virtualizedItem,
        text2,
        textChild,
        textRange,
        annotation,
        drag,
        dropTarget
    }

    export class ProgressBarAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IProgressBarAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ProgressBar);
    }

    export class ProgressRingAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IProgressRingAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.ProgressRing);
    }

    export class RadioButtonAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRadioButtonAutomationPeer, Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider {
        constructor(owner: Windows.UI.Xaml.Controls.RadioButton);
        addToSelection(): void;
        removeFromSelection(): void;
        select(): void;
        isSelected: boolean;
        selectionContainer: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export class RangeBaseAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRangeBaseAutomationPeer, Windows.UI.Xaml.Automation.Provider.IRangeValueProvider {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.RangeBase);
        setValue(value: number): void;
        isReadOnly: boolean;
        largeChange: number;
        maximum: number;
        minimum: number;
        smallChange: number;
        value: number;
    }

    export class RepeatButtonAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRepeatButtonAutomationPeer, Windows.UI.Xaml.Automation.Provider.IInvokeProvider {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.RepeatButton);
        invoke(): void;
    }

    export class RichEditBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRichEditBoxAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.RichEditBox);
    }

    export class RichTextBlockAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRichTextBlockAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.RichTextBlock);
    }

    export class RichTextBlockOverflowAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IRichTextBlockOverflowAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.RichTextBlockOverflow);
    }

    export class ScrollBarAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IScrollBarAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.ScrollBar);
    }

    export class ScrollViewerAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IScrollViewerAutomationPeer, Windows.UI.Xaml.Automation.Provider.IScrollProvider {
        constructor(owner: Windows.UI.Xaml.Controls.ScrollViewer);
        scroll(horizontalAmount: Windows.UI.Xaml.Automation.ScrollAmount, verticalAmount: Windows.UI.Xaml.Automation.ScrollAmount): void;
        setScrollPercent(horizontalPercent: number, verticalPercent: number): void;
        horizontalScrollPercent: number;
        horizontalViewSize: number;
        horizontallyScrollable: boolean;
        verticalScrollPercent: number;
        verticalViewSize: number;
        verticallyScrollable: boolean;
    }

    export class SelectorAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ISelectorAutomationPeer, Windows.UI.Xaml.Automation.Provider.ISelectionProvider {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.Selector);
        getSelection(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        canSelectMultiple: boolean;
        isSelectionRequired: boolean;
    }

    export class SelectorItemAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ISelectorItemAutomationPeer, Windows.UI.Xaml.Automation.Provider.ISelectionItemProvider {
        constructor(item: any, parent: Windows.UI.Xaml.Automation.Peers.SelectorAutomationPeer);
        addToSelection(): void;
        removeFromSelection(): void;
        select(): void;
        isSelected: boolean;
        selectionContainer: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export class SemanticZoomAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ISemanticZoomAutomationPeer, Windows.UI.Xaml.Automation.Provider.IToggleProvider {
        constructor(owner: Windows.UI.Xaml.Controls.SemanticZoom);
        toggle(): void;
        toggleState: Windows.UI.Xaml.Automation.ToggleState;
    }

    export class SliderAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ISliderAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.Slider);
    }

    export class TextBlockAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ITextBlockAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.TextBlock);
    }

    export class TextBoxAutomationPeer implements Windows.UI.Xaml.Automation.Peers.ITextBoxAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.TextBox);
    }

    export class ThumbAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IThumbAutomationPeer {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.Thumb);
    }

    export class ToggleButtonAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IToggleButtonAutomationPeer, Windows.UI.Xaml.Automation.Provider.IToggleProvider {
        constructor(owner: Windows.UI.Xaml.Controls.Primitives.ToggleButton);
        toggle(): void;
        toggleState: Windows.UI.Xaml.Automation.ToggleState;
    }

    export class ToggleSwitchAutomationPeer implements Windows.UI.Xaml.Automation.Peers.IToggleSwitchAutomationPeer, Windows.UI.Xaml.Automation.Provider.IToggleProvider {
        constructor(owner: Windows.UI.Xaml.Controls.ToggleSwitch);
        toggle(): void;
        toggleState: Windows.UI.Xaml.Automation.ToggleState;
    }

}
declare module Windows.UI.Xaml.Automation.Provider {

    export interface IAnnotationProvider {
        annotationTypeId: number;
        annotationTypeName: string;
        author: string;
        dateTime: string;
        target: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export interface IDockProvider {
        setDockPosition(dockPosition: Windows.UI.Xaml.Automation.DockPosition): void;
        dockPosition: Windows.UI.Xaml.Automation.DockPosition;
    }

    export interface IDragProvider {
        getGrabbedItems(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        dropEffect: string;
        dropEffects: string[];
        isGrabbed: boolean;
    }

    export interface IDropTargetProvider {
        dropEffect: string;
        dropEffects: string[];
    }

    export interface IExpandCollapseProvider {
        collapse(): void;
        expand(): void;
        expandCollapseState: Windows.UI.Xaml.Automation.ExpandCollapseState;
    }

    export interface IGridItemProvider {
        column: number;
        columnSpan: number;
        containingGrid: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
        row: number;
        rowSpan: number;
    }

    export interface IGridProvider {
        getItem(row: number, column: number): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
        columnCount: number;
        rowCount: number;
    }

    export interface IInvokeProvider {
        invoke(): void;
    }

    export interface IIRawElementProviderSimple {
    }

    export interface IItemContainerProvider {
        findItemByProperty(startAfter: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple, automationProperty: Windows.UI.Xaml.Automation.AutomationProperty, value: any): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export interface IMultipleViewProvider {
        getSupportedViews(): number[];
        getViewName(viewId: number): string;
        setCurrentView(viewId: number): void;
        currentView: number;
    }

    export interface IRangeValueProvider {
        setValue(value: number): void;
        isReadOnly: boolean;
        largeChange: number;
        maximum: number;
        minimum: number;
        smallChange: number;
        value: number;
    }

    export class IRawElementProviderSimple implements Windows.UI.Xaml.Automation.Provider.IIRawElementProviderSimple {
    }

    export interface IScrollItemProvider {
        scrollIntoView(): void;
    }

    export interface IScrollProvider {
        scroll(horizontalAmount: Windows.UI.Xaml.Automation.ScrollAmount, verticalAmount: Windows.UI.Xaml.Automation.ScrollAmount): void;
        setScrollPercent(horizontalPercent: number, verticalPercent: number): void;
        horizontalScrollPercent: number;
        horizontalViewSize: number;
        horizontallyScrollable: boolean;
        verticalScrollPercent: number;
        verticalViewSize: number;
        verticallyScrollable: boolean;
    }

    export interface ISelectionItemProvider {
        addToSelection(): void;
        removeFromSelection(): void;
        select(): void;
        isSelected: boolean;
        selectionContainer: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
    }

    export interface ISelectionProvider {
        getSelection(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        canSelectMultiple: boolean;
        isSelectionRequired: boolean;
    }

    export interface ITableItemProvider {
        getColumnHeaderItems(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        getRowHeaderItems(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
    }

    export interface ITableProvider {
        getColumnHeaders(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        getRowHeaders(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
        rowOrColumnMajor: Windows.UI.Xaml.Automation.RowOrColumnMajor;
    }

    export interface ITextChildProvider {
        textContainer: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
        textRange: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
    }

    export interface ITextProvider {
        getSelection(): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider[];
        getVisibleRanges(): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider[];
        rangeFromChild(childElement: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        rangeFromPoint(screenLocation: Windows.Foundation.Point): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        documentRange: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        supportedTextSelection: Windows.UI.Xaml.Automation.SupportedTextSelection;
    }

    export interface ITextProvider2 extends Windows.UI.Xaml.Automation.Provider.ITextProvider {
        rangeFromAnnotation(annotationElement: Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        getCaretRange(): ITextProvider2_getCaretRange_OUT;
    }

    interface ITextProvider2_getCaretRange_OUT {
        __returnValue: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        isActive: boolean;
    }

    export interface ITextRangeProvider {
        clone(): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        compare(textRangeProvider: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider): boolean;
        compareEndpoints(endpoint: Windows.UI.Xaml.Automation.Text.TextPatternRangeEndpoint, textRangeProvider: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider, targetEndpoint: Windows.UI.Xaml.Automation.Text.TextPatternRangeEndpoint): number;
        expandToEnclosingUnit(unit: Windows.UI.Xaml.Automation.Text.TextUnit): void;
        findAttribute(attributeId: number, value: any, backward: boolean): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        findText(text: string, backward: boolean, ignoreCase: boolean): Windows.UI.Xaml.Automation.Provider.ITextRangeProvider;
        getAttributeValue(attributeId: number): any;
        getBoundingRectangles(): ITextRangeProvider_getBoundingRectangles_OUT;
        getEnclosingElement(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple;
        getText(maxLength: number): string;
        move(unit: Windows.UI.Xaml.Automation.Text.TextUnit, count: number): number;
        moveEndpointByUnit(endpoint: Windows.UI.Xaml.Automation.Text.TextPatternRangeEndpoint, unit: Windows.UI.Xaml.Automation.Text.TextUnit, count: number): number;
        moveEndpointByRange(endpoint: Windows.UI.Xaml.Automation.Text.TextPatternRangeEndpoint, textRangeProvider: Windows.UI.Xaml.Automation.Provider.ITextRangeProvider, targetEndpoint: Windows.UI.Xaml.Automation.Text.TextPatternRangeEndpoint): void;
        select(): void;
        addToSelection(): void;
        removeFromSelection(): void;
        scrollIntoView(alignToTop: boolean): void;
        getChildren(): Windows.UI.Xaml.Automation.Provider.IRawElementProviderSimple[];
    }

    interface ITextRangeProvider_getBoundingRectangles_OUT {
        returnValue: number[];
    }

    export interface IToggleProvider {
        toggle(): void;
        toggleState: Windows.UI.Xaml.Automation.ToggleState;
    }

    export interface ITransformProvider {
        move(x: number, y: number): void;
        resize(width: number, height: number): void;
        rotate(degrees: number): void;
        canMove: boolean;
        canResize: boolean;
        canRotate: boolean;
    }

    export interface IValueProvider {
        setValue(value: string): void;
        isReadOnly: boolean;
        value: string;
    }

    export interface IVirtualizedItemProvider {
        realize(): void;
    }

    export interface IWindowProvider {
        close(): void;
        setVisualState(state: Windows.UI.Xaml.Automation.WindowVisualState): void;
        waitForInputIdle(milliseconds: number): boolean;
        interactionState: Windows.UI.Xaml.Automation.WindowInteractionState;
        isModal: boolean;
        isTopmost: boolean;
        maximizable: boolean;
        minimizable: boolean;
        visualState: Windows.UI.Xaml.Automation.WindowVisualState;
    }

}
declare module Windows.UI.Xaml.Automation.Text {

    enum TextPatternRangeEndpoint {
        start,
        end
    }

    enum TextUnit {
        character,
        format,
        word,
        line,
        paragraph,
        page,
        document
    }

}
declare module Windows.UI.Xaml.Controls {

    export class AppBar implements Windows.UI.Xaml.Controls.IAppBar, Windows.UI.Xaml.Controls.IAppBarOverrides {
        constructor();
        add_Opened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        onClosed(e: any): void;
        onOpened(e: any): void;
        isOpen: boolean;
        isSticky: boolean;
        static isOpenProperty: Windows.UI.Xaml.DependencyProperty;
        static isStickyProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        onclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        onopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class Border implements Windows.UI.Xaml.Controls.IBorder {
        constructor();
        background: Windows.UI.Xaml.Media.Brush;
        borderBrush: Windows.UI.Xaml.Media.Brush;
        borderThickness: Windows.UI.Xaml.Thickness;
        child: Windows.UI.Xaml.UIElement;
        childTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        cornerRadius: Windows.UI.Xaml.CornerRadius;
        padding: Windows.UI.Xaml.Thickness;
        static backgroundProperty: Windows.UI.Xaml.DependencyProperty;
        static borderBrushProperty: Windows.UI.Xaml.DependencyProperty;
        static borderThicknessProperty: Windows.UI.Xaml.DependencyProperty;
        static childTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static cornerRadiusProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Button implements Windows.UI.Xaml.Controls.IButton {
        constructor();
    }

    export class Canvas implements Windows.UI.Xaml.Controls.ICanvas {
        constructor();
        static getLeft(element: Windows.UI.Xaml.UIElement): number;
        static setLeft(element: Windows.UI.Xaml.UIElement, length: number): void;
        static getTop(element: Windows.UI.Xaml.UIElement): number;
        static setTop(element: Windows.UI.Xaml.UIElement, length: number): void;
        static getZIndex(element: Windows.UI.Xaml.UIElement): number;
        static setZIndex(element: Windows.UI.Xaml.UIElement, value: number): void;
        static leftProperty: Windows.UI.Xaml.DependencyProperty;
        static topProperty: Windows.UI.Xaml.DependencyProperty;
        static zIndexProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CaptureElement implements Windows.UI.Xaml.Controls.ICaptureElement {
        constructor();
        source: Windows.Media.Capture.MediaCapture;
        stretch: Windows.UI.Xaml.Media.Stretch;
        static sourceProperty: Windows.UI.Xaml.DependencyProperty;
        static stretchProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CheckBox implements Windows.UI.Xaml.Controls.ICheckBox {
        constructor();
    }

    export class CleanUpVirtualizedItemEventArgs implements Windows.UI.Xaml.Controls.ICleanUpVirtualizedItemEventArgs {
        cancel: boolean;
        uIElement: Windows.UI.Xaml.UIElement;
        value: any;
    }

    export interface CleanUpVirtualizedItemEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum ClickMode {
        release,
        press,
        hover
    }

    export class ColumnDefinition implements Windows.UI.Xaml.Controls.IColumnDefinition {
        constructor();
        actualWidth: number;
        maxWidth: number;
        minWidth: number;
        width: Windows.UI.Xaml.GridLength;
        static maxWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static minWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static widthProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ColumnDefinitionCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Controls.ColumnDefinition>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Controls.ColumnDefinition> {
        getAt(index: number): Windows.UI.Xaml.Controls.ColumnDefinition;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Controls.ColumnDefinition>;
        indexOf(value: Windows.UI.Xaml.Controls.ColumnDefinition): ColumnDefinitionCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Controls.ColumnDefinition): void;
        insertAt(index: number, value: Windows.UI.Xaml.Controls.ColumnDefinition): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Controls.ColumnDefinition): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): ColumnDefinitionCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Controls.ColumnDefinition[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Controls.ColumnDefinition>;
        size: number;
    }

    interface ColumnDefinitionCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ColumnDefinitionCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Controls.ColumnDefinition[];
    }

    export class ComboBox implements Windows.UI.Xaml.Controls.IComboBox, Windows.UI.Xaml.Controls.IComboBoxOverrides {
        constructor();
        add_DropDownClosed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_DropDownClosed(token: Windows.Foundation.EventRegistrationToken): void;
        add_DropDownOpened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_DropDownOpened(token: Windows.Foundation.EventRegistrationToken): void;
        onDropDownClosed(e: any): void;
        onDropDownOpened(e: any): void;
        isDropDownOpen: boolean;
        isEditable: boolean;
        isSelectionBoxHighlighted: boolean;
        maxDropDownHeight: number;
        selectionBoxItem: any;
        selectionBoxItemTemplate: Windows.UI.Xaml.DataTemplate;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings;
        static isDropDownOpenProperty: Windows.UI.Xaml.DependencyProperty;
        static maxDropDownHeightProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dropdownclosed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "dropdownclosed", listener: Windows.Foundation.EventHandler<any>): void;
        ondropdownclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "dropdownopened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "dropdownopened", listener: Windows.Foundation.EventHandler<any>): void;
        ondropdownopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class ComboBoxItem implements Windows.UI.Xaml.Controls.IComboBoxItem {
        constructor();
    }

    export class ContentControl implements Windows.UI.Xaml.Controls.IContentControl, Windows.UI.Xaml.Controls.IContentControlOverrides {
        constructor();
        onContentChanged(oldContent: any, newContent: any): void;
        onContentTemplateChanged(oldContentTemplate: Windows.UI.Xaml.DataTemplate, newContentTemplate: Windows.UI.Xaml.DataTemplate): void;
        onContentTemplateSelectorChanged(oldContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
        content: any;
        contentTemplate: Windows.UI.Xaml.DataTemplate;
        contentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        contentTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        static contentProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTemplateSelectorProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ContentPresenter implements Windows.UI.Xaml.Controls.IContentPresenter, Windows.UI.Xaml.Controls.IContentPresenterOverrides {
        constructor();
        onContentTemplateChanged(oldContentTemplate: Windows.UI.Xaml.DataTemplate, newContentTemplate: Windows.UI.Xaml.DataTemplate): void;
        onContentTemplateSelectorChanged(oldContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
        characterSpacing: number;
        content: any;
        contentTemplate: Windows.UI.Xaml.DataTemplate;
        contentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        contentTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        static characterSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static contentProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTemplateSelectorProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static fontFamilyProperty: Windows.UI.Xaml.DependencyProperty;
        static fontSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStretchProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static fontWeightProperty: Windows.UI.Xaml.DependencyProperty;
        static foregroundProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ContextMenuEventArgs implements Windows.UI.Xaml.Controls.IContextMenuEventArgs {
        cursorLeft: number;
        cursorTop: number;
        handled: boolean;
    }

    export interface ContextMenuOpeningEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class Control implements Windows.UI.Xaml.Controls.IControl, Windows.UI.Xaml.Controls.IControlOverrides, Windows.UI.Xaml.Controls.IControlProtected {
        constructor();
        add_IsEnabledChanged(value: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_IsEnabledChanged(token: Windows.Foundation.EventRegistrationToken): void;
        applyTemplate(): boolean;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        onPointerEntered(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerPressed(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerMoved(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerReleased(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerExited(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerCaptureLost(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerCanceled(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerWheelChanged(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onTapped(e: Windows.UI.Xaml.Input.TappedRoutedEventArgs): void;
        onDoubleTapped(e: Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs): void;
        onHolding(e: Windows.UI.Xaml.Input.HoldingRoutedEventArgs): void;
        onRightTapped(e: Windows.UI.Xaml.Input.RightTappedRoutedEventArgs): void;
        onManipulationStarting(e: Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs): void;
        onManipulationInertiaStarting(e: Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs): void;
        onManipulationStarted(e: Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs): void;
        onManipulationDelta(e: Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs): void;
        onManipulationCompleted(e: Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs): void;
        onKeyUp(e: Windows.UI.Xaml.Input.KeyRoutedEventArgs): void;
        onKeyDown(e: Windows.UI.Xaml.Input.KeyRoutedEventArgs): void;
        onGotFocus(e: Windows.UI.Xaml.RoutedEventArgs): void;
        onLostFocus(e: Windows.UI.Xaml.RoutedEventArgs): void;
        onDragEnter(e: Windows.UI.Xaml.DragEventArgs): void;
        onDragLeave(e: Windows.UI.Xaml.DragEventArgs): void;
        onDragOver(e: Windows.UI.Xaml.DragEventArgs): void;
        onDrop(e: Windows.UI.Xaml.DragEventArgs): void;
        getTemplateChild(childName: string): Windows.UI.Xaml.DependencyObject;
        background: Windows.UI.Xaml.Media.Brush;
        borderBrush: Windows.UI.Xaml.Media.Brush;
        borderThickness: Windows.UI.Xaml.Thickness;
        characterSpacing: number;
        focusState: Windows.UI.Xaml.FocusState;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        horizontalContentAlignment: Windows.UI.Xaml.HorizontalAlignment;
        isEnabled: boolean;
        isTabStop: boolean;
        padding: Windows.UI.Xaml.Thickness;
        tabIndex: number;
        tabNavigation: Windows.UI.Xaml.Input.KeyboardNavigationMode;
        template: Windows.UI.Xaml.Controls.ControlTemplate;
        verticalContentAlignment: Windows.UI.Xaml.VerticalAlignment;
        defaultStyleKey: any;
        static backgroundProperty: Windows.UI.Xaml.DependencyProperty;
        static borderBrushProperty: Windows.UI.Xaml.DependencyProperty;
        static borderThicknessProperty: Windows.UI.Xaml.DependencyProperty;
        static characterSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static defaultStyleKeyProperty: Windows.UI.Xaml.DependencyProperty;
        static focusStateProperty: Windows.UI.Xaml.DependencyProperty;
        static fontFamilyProperty: Windows.UI.Xaml.DependencyProperty;
        static fontSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStretchProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static fontWeightProperty: Windows.UI.Xaml.DependencyProperty;
        static foregroundProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalContentAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static isEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isTabStopProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
        static tabIndexProperty: Windows.UI.Xaml.DependencyProperty;
        static tabNavigationProperty: Windows.UI.Xaml.DependencyProperty;
        static templateProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalContentAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "isenabledchanged", listener: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): void;
        removeEventListener(eventName: "isenabledchanged", listener: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): void;
        onisenabledchanged: (ev: Windows.UI.Xaml.DependencyPropertyChangedEventHandler) => void;

    }

    export class ControlTemplate implements Windows.UI.Xaml.Controls.IControlTemplate {
        constructor();
        targetType: Windows.UI.Xaml.Interop.TypeName;
    }

    export class DataTemplateSelector implements Windows.UI.Xaml.Controls.IDataTemplateSelector, Windows.UI.Xaml.Controls.IDataTemplateSelectorOverrides {
        constructor();
        selectTemplate(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.DataTemplate;
        selectTemplateCore(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.DataTemplate;
    }

    export class DragItemsStartingEventArgs implements Windows.UI.Xaml.Controls.IDragItemsStartingEventArgs {
        constructor();
        cancel: boolean;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        items: Windows.Foundation.Collections.IVector<any>;
    }

    export interface DragItemsStartingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class FlipView implements Windows.UI.Xaml.Controls.IFlipView {
        constructor();
    }

    export class FlipViewItem implements Windows.UI.Xaml.Controls.IFlipViewItem {
        constructor();
    }

    export class Frame implements Windows.UI.Xaml.Controls.IFrame, Windows.UI.Xaml.Controls.INavigate {
        constructor();
        add_Navigated(value: Windows.UI.Xaml.Navigation.NavigatedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Navigated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Navigating(value: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Navigating(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationFailed(value: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationStopped(value: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationStopped(token: Windows.Foundation.EventRegistrationToken): void;
        goBack(): void;
        goForward(): void;
        navigate(sourcePageType: Windows.UI.Xaml.Interop.TypeName, parameter: any): boolean;
        getNavigationState(): string;
        setNavigationState(navigationState: string): void;
        navigate(sourcePageType: Windows.UI.Xaml.Interop.TypeName): boolean;
        backStackDepth: number;
        cacheSize: number;
        canGoBack: boolean;
        canGoForward: boolean;
        currentSourcePageType: Windows.UI.Xaml.Interop.TypeName;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
        static backStackDepthProperty: Windows.UI.Xaml.DependencyProperty;
        static cacheSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static canGoBackProperty: Windows.UI.Xaml.DependencyProperty;
        static canGoForwardProperty: Windows.UI.Xaml.DependencyProperty;
        static currentSourcePageTypeProperty: Windows.UI.Xaml.DependencyProperty;
        static sourcePageTypeProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "navigated", listener: Windows.UI.Xaml.Navigation.NavigatedEventHandler): void;
        removeEventListener(eventName: "navigated", listener: Windows.UI.Xaml.Navigation.NavigatedEventHandler): void;
        onnavigated: (ev: Windows.UI.Xaml.Navigation.NavigatedEventHandler) => void;
        addEventListener(eventName: "navigating", listener: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): void;
        removeEventListener(eventName: "navigating", listener: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): void;
        onnavigating: (ev: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler) => void;
        addEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): void;
        removeEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): void;
        onnavigationfailed: (ev: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler) => void;
        addEventListener(eventName: "navigationstopped", listener: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): void;
        removeEventListener(eventName: "navigationstopped", listener: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): void;
        onnavigationstopped: (ev: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler) => void;

    }

    export class Grid implements Windows.UI.Xaml.Controls.IGrid {
        constructor();
        static getRow(element: Windows.UI.Xaml.FrameworkElement): number;
        static setRow(element: Windows.UI.Xaml.FrameworkElement, value: number): void;
        static getColumn(element: Windows.UI.Xaml.FrameworkElement): number;
        static setColumn(element: Windows.UI.Xaml.FrameworkElement, value: number): void;
        static getRowSpan(element: Windows.UI.Xaml.FrameworkElement): number;
        static setRowSpan(element: Windows.UI.Xaml.FrameworkElement, value: number): void;
        static getColumnSpan(element: Windows.UI.Xaml.FrameworkElement): number;
        static setColumnSpan(element: Windows.UI.Xaml.FrameworkElement, value: number): void;
        columnDefinitions: Windows.UI.Xaml.Controls.ColumnDefinitionCollection;
        rowDefinitions: Windows.UI.Xaml.Controls.RowDefinitionCollection;
        static columnProperty: Windows.UI.Xaml.DependencyProperty;
        static columnSpanProperty: Windows.UI.Xaml.DependencyProperty;
        static rowProperty: Windows.UI.Xaml.DependencyProperty;
        static rowSpanProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class GridView implements Windows.UI.Xaml.Controls.IGridView {
        constructor();
    }

    export class GridViewItem implements Windows.UI.Xaml.Controls.IGridViewItem {
        constructor();
        templateSettings: Windows.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings;
    }

    export class GroupItem implements Windows.UI.Xaml.Controls.IGroupItem {
        constructor();
    }

    export class GroupStyle implements Windows.UI.Xaml.Controls.IGroupStyle, Windows.UI.Xaml.Data.INotifyPropertyChanged {
        constructor();
        add_PropertyChanged(value: Windows.UI.Xaml.Data.PropertyChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PropertyChanged(token: Windows.Foundation.EventRegistrationToken): void;
        containerStyle: Windows.UI.Xaml.Style;
        containerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        hidesIfEmpty: boolean;
        panel: Windows.UI.Xaml.Controls.ItemsPanelTemplate;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertychanged", listener: Windows.UI.Xaml.Data.PropertyChangedEventHandler): void;
        removeEventListener(eventName: "propertychanged", listener: Windows.UI.Xaml.Data.PropertyChangedEventHandler): void;
        onpropertychanged: (ev: Windows.UI.Xaml.Data.PropertyChangedEventHandler) => void;

    }

    export class GroupStyleSelector implements Windows.UI.Xaml.Controls.IGroupStyleSelector, Windows.UI.Xaml.Controls.IGroupStyleSelectorOverrides {
        constructor();
        selectGroupStyle(group: any, level: number): Windows.UI.Xaml.Controls.GroupStyle;
        selectGroupStyleCore(group: any, level: number): Windows.UI.Xaml.Controls.GroupStyle;
    }

    export class HyperlinkButton implements Windows.UI.Xaml.Controls.IHyperlinkButton {
        constructor();
        navigateUri: Windows.Foundation.Uri;
        static navigateUriProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export interface IAppBar {
        add_Opened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        isOpen: boolean;
        isSticky: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        onclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        onopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface IAppBarOverrides {
        onClosed(e: any): void;
        onOpened(e: any): void;
    }

    export interface IBorder {
        background: Windows.UI.Xaml.Media.Brush;
        borderBrush: Windows.UI.Xaml.Media.Brush;
        borderThickness: Windows.UI.Xaml.Thickness;
        child: Windows.UI.Xaml.UIElement;
        childTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        cornerRadius: Windows.UI.Xaml.CornerRadius;
        padding: Windows.UI.Xaml.Thickness;
    }

    export interface IButton {
    }

    export interface ICanvas {
    }

    export interface ICaptureElement {
        source: Windows.Media.Capture.MediaCapture;
        stretch: Windows.UI.Xaml.Media.Stretch;
    }

    export interface ICheckBox {
    }

    export interface ICleanUpVirtualizedItemEventArgs {
        cancel: boolean;
        uIElement: Windows.UI.Xaml.UIElement;
        value: any;
    }

    export interface IColumnDefinition {
        actualWidth: number;
        maxWidth: number;
        minWidth: number;
        width: Windows.UI.Xaml.GridLength;
    }

    export interface IComboBox {
        add_DropDownClosed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_DropDownClosed(token: Windows.Foundation.EventRegistrationToken): void;
        add_DropDownOpened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_DropDownOpened(token: Windows.Foundation.EventRegistrationToken): void;
        isDropDownOpen: boolean;
        isEditable: boolean;
        isSelectionBoxHighlighted: boolean;
        maxDropDownHeight: number;
        selectionBoxItem: any;
        selectionBoxItemTemplate: Windows.UI.Xaml.DataTemplate;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ComboBoxTemplateSettings;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dropdownclosed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "dropdownclosed", listener: Windows.Foundation.EventHandler<any>): void;
        ondropdownclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "dropdownopened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "dropdownopened", listener: Windows.Foundation.EventHandler<any>): void;
        ondropdownopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface IComboBoxItem {
    }

    export interface IComboBoxOverrides {
        onDropDownClosed(e: any): void;
        onDropDownOpened(e: any): void;
    }

    export interface IContentControl {
        content: any;
        contentTemplate: Windows.UI.Xaml.DataTemplate;
        contentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        contentTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
    }

    export interface IContentControlOverrides {
        onContentChanged(oldContent: any, newContent: any): void;
        onContentTemplateChanged(oldContentTemplate: Windows.UI.Xaml.DataTemplate, newContentTemplate: Windows.UI.Xaml.DataTemplate): void;
        onContentTemplateSelectorChanged(oldContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
    }

    export interface IContentPresenter {
        characterSpacing: number;
        content: any;
        contentTemplate: Windows.UI.Xaml.DataTemplate;
        contentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        contentTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
    }

    export interface IContentPresenterOverrides {
        onContentTemplateChanged(oldContentTemplate: Windows.UI.Xaml.DataTemplate, newContentTemplate: Windows.UI.Xaml.DataTemplate): void;
        onContentTemplateSelectorChanged(oldContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newContentTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
    }

    export interface IContextMenuEventArgs {
        cursorLeft: number;
        cursorTop: number;
        handled: boolean;
    }

    export interface IControl {
        add_IsEnabledChanged(value: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_IsEnabledChanged(token: Windows.Foundation.EventRegistrationToken): void;
        applyTemplate(): boolean;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        background: Windows.UI.Xaml.Media.Brush;
        borderBrush: Windows.UI.Xaml.Media.Brush;
        borderThickness: Windows.UI.Xaml.Thickness;
        characterSpacing: number;
        focusState: Windows.UI.Xaml.FocusState;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        horizontalContentAlignment: Windows.UI.Xaml.HorizontalAlignment;
        isEnabled: boolean;
        isTabStop: boolean;
        padding: Windows.UI.Xaml.Thickness;
        tabIndex: number;
        tabNavigation: Windows.UI.Xaml.Input.KeyboardNavigationMode;
        template: Windows.UI.Xaml.Controls.ControlTemplate;
        verticalContentAlignment: Windows.UI.Xaml.VerticalAlignment;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "isenabledchanged", listener: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): void;
        removeEventListener(eventName: "isenabledchanged", listener: Windows.UI.Xaml.DependencyPropertyChangedEventHandler): void;
        onisenabledchanged: (ev: Windows.UI.Xaml.DependencyPropertyChangedEventHandler) => void;

    }

    export interface IControlOverrides {
        onPointerEntered(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerPressed(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerMoved(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerReleased(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerExited(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerCaptureLost(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerCanceled(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onPointerWheelChanged(e: Windows.UI.Xaml.Input.PointerRoutedEventArgs): void;
        onTapped(e: Windows.UI.Xaml.Input.TappedRoutedEventArgs): void;
        onDoubleTapped(e: Windows.UI.Xaml.Input.DoubleTappedRoutedEventArgs): void;
        onHolding(e: Windows.UI.Xaml.Input.HoldingRoutedEventArgs): void;
        onRightTapped(e: Windows.UI.Xaml.Input.RightTappedRoutedEventArgs): void;
        onManipulationStarting(e: Windows.UI.Xaml.Input.ManipulationStartingRoutedEventArgs): void;
        onManipulationInertiaStarting(e: Windows.UI.Xaml.Input.ManipulationInertiaStartingRoutedEventArgs): void;
        onManipulationStarted(e: Windows.UI.Xaml.Input.ManipulationStartedRoutedEventArgs): void;
        onManipulationDelta(e: Windows.UI.Xaml.Input.ManipulationDeltaRoutedEventArgs): void;
        onManipulationCompleted(e: Windows.UI.Xaml.Input.ManipulationCompletedRoutedEventArgs): void;
        onKeyUp(e: Windows.UI.Xaml.Input.KeyRoutedEventArgs): void;
        onKeyDown(e: Windows.UI.Xaml.Input.KeyRoutedEventArgs): void;
        onGotFocus(e: Windows.UI.Xaml.RoutedEventArgs): void;
        onLostFocus(e: Windows.UI.Xaml.RoutedEventArgs): void;
        onDragEnter(e: Windows.UI.Xaml.DragEventArgs): void;
        onDragLeave(e: Windows.UI.Xaml.DragEventArgs): void;
        onDragOver(e: Windows.UI.Xaml.DragEventArgs): void;
        onDrop(e: Windows.UI.Xaml.DragEventArgs): void;
    }

    export interface IControlProtected {
        getTemplateChild(childName: string): Windows.UI.Xaml.DependencyObject;
        defaultStyleKey: any;
    }

    export interface IControlTemplate {
        targetType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface IDataTemplateSelector {
        selectTemplate(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.DataTemplate;
    }

    export interface IDataTemplateSelectorOverrides {
        selectTemplateCore(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.DataTemplate;
    }

    export interface IDragItemsStartingEventArgs {
        cancel: boolean;
        data: Windows.ApplicationModel.DataTransfer.DataPackage;
        items: Windows.Foundation.Collections.IVector<any>;
    }

    export interface IFlipView {
    }

    export interface IFlipViewItem {
    }

    export interface IFrame {
        add_Navigated(value: Windows.UI.Xaml.Navigation.NavigatedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Navigated(token: Windows.Foundation.EventRegistrationToken): void;
        add_Navigating(value: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Navigating(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationFailed(value: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationStopped(value: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationStopped(token: Windows.Foundation.EventRegistrationToken): void;
        goBack(): void;
        goForward(): void;
        navigate(sourcePageType: Windows.UI.Xaml.Interop.TypeName, parameter: any): boolean;
        getNavigationState(): string;
        setNavigationState(navigationState: string): void;
        backStackDepth: number;
        cacheSize: number;
        canGoBack: boolean;
        canGoForward: boolean;
        currentSourcePageType: Windows.UI.Xaml.Interop.TypeName;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "navigated", listener: Windows.UI.Xaml.Navigation.NavigatedEventHandler): void;
        removeEventListener(eventName: "navigated", listener: Windows.UI.Xaml.Navigation.NavigatedEventHandler): void;
        onnavigated: (ev: Windows.UI.Xaml.Navigation.NavigatedEventHandler) => void;
        addEventListener(eventName: "navigating", listener: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): void;
        removeEventListener(eventName: "navigating", listener: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler): void;
        onnavigating: (ev: Windows.UI.Xaml.Navigation.NavigatingCancelEventHandler) => void;
        addEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): void;
        removeEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler): void;
        onnavigationfailed: (ev: Windows.UI.Xaml.Navigation.NavigationFailedEventHandler) => void;
        addEventListener(eventName: "navigationstopped", listener: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): void;
        removeEventListener(eventName: "navigationstopped", listener: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler): void;
        onnavigationstopped: (ev: Windows.UI.Xaml.Navigation.NavigationStoppedEventHandler) => void;

    }

    export interface IGrid {
        columnDefinitions: Windows.UI.Xaml.Controls.ColumnDefinitionCollection;
        rowDefinitions: Windows.UI.Xaml.Controls.RowDefinitionCollection;
    }

    export interface IGridView {
    }

    export interface IGridViewItem {
        templateSettings: Windows.UI.Xaml.Controls.Primitives.GridViewItemTemplateSettings;
    }

    export interface IGroupItem {
    }

    export interface IGroupStyle {
        containerStyle: Windows.UI.Xaml.Style;
        containerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        hidesIfEmpty: boolean;
        panel: Windows.UI.Xaml.Controls.ItemsPanelTemplate;
    }

    export interface IGroupStyleSelector {
        selectGroupStyle(group: any, level: number): Windows.UI.Xaml.Controls.GroupStyle;
    }

    export interface IGroupStyleSelectorOverrides {
        selectGroupStyleCore(group: any, level: number): Windows.UI.Xaml.Controls.GroupStyle;
    }

    export interface IHyperlinkButton {
        navigateUri: Windows.Foundation.Uri;
    }

    export interface IImage {
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        nineGrid: Windows.UI.Xaml.Thickness;
        playToSource: Windows.Media.PlayTo.PlayToSource;
        source: Windows.UI.Xaml.Media.ImageSource;
        stretch: Windows.UI.Xaml.Media.Stretch;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IItemClickEventArgs {
        clickedItem: any;
    }

    export interface IItemContainerGenerator {
        add_ItemsChanged(value: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ItemsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        itemFromContainer(container: Windows.UI.Xaml.DependencyObject): any;
        containerFromItem(item: any): Windows.UI.Xaml.DependencyObject;
        indexFromContainer(container: Windows.UI.Xaml.DependencyObject): number;
        containerFromIndex(index: number): Windows.UI.Xaml.DependencyObject;
        getItemContainerGeneratorForPanel(panel: Windows.UI.Xaml.Controls.Panel): Windows.UI.Xaml.Controls.ItemContainerGenerator;
        startAt(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, direction: Windows.UI.Xaml.Controls.Primitives.GeneratorDirection, allowStartAtRealizedItem: boolean): void;
        stop(): void;
        generateNext(): IItemContainerGenerator_generateNext_OUT;
        prepareItemContainer(container: Windows.UI.Xaml.DependencyObject): void;
        removeAll(): void;
        remove(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, count: number): void;
        generatorPositionFromIndex(itemIndex: number): Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
        indexFromGeneratorPosition(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition): number;
        recycle(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, count: number): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemschanged", listener: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): void;
        removeEventListener(eventName: "itemschanged", listener: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): void;
        onitemschanged: (ev: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler) => void;

    }

    interface IItemContainerGenerator_generateNext_OUT {
        __returnValue: Windows.UI.Xaml.DependencyObject;
        isNewlyRealized: boolean;
    }

    export interface IItemsControl {
        displayMemberPath: string;
        groupStyle: Windows.Foundation.Collections.IObservableVector<Windows.UI.Xaml.Controls.GroupStyle>;
        groupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector;
        isGrouping: boolean;
        itemContainerGenerator: Windows.UI.Xaml.Controls.ItemContainerGenerator;
        itemContainerStyle: Windows.UI.Xaml.Style;
        itemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector;
        itemContainerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        itemTemplate: Windows.UI.Xaml.DataTemplate;
        itemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        items: Windows.UI.Xaml.Controls.ItemCollection;
        itemsPanel: Windows.UI.Xaml.Controls.ItemsPanelTemplate;
        itemsSource: any;
    }

    export interface IItemsControlOverrides {
        isItemItsOwnContainerOverride(item: any): boolean;
        getContainerForItemOverride(): Windows.UI.Xaml.DependencyObject;
        clearContainerForItemOverride(element: Windows.UI.Xaml.DependencyObject, item: any): void;
        prepareContainerForItemOverride(element: Windows.UI.Xaml.DependencyObject, item: any): void;
        onItemsChanged(e: any): void;
        onItemContainerStyleChanged(oldItemContainerStyle: Windows.UI.Xaml.Style, newItemContainerStyle: Windows.UI.Xaml.Style): void;
        onItemContainerStyleSelectorChanged(oldItemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector, newItemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector): void;
        onItemTemplateChanged(oldItemTemplate: Windows.UI.Xaml.DataTemplate, newItemTemplate: Windows.UI.Xaml.DataTemplate): void;
        onItemTemplateSelectorChanged(oldItemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newItemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
        onGroupStyleSelectorChanged(oldGroupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector, newGroupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector): void;
    }

    export interface IItemsPanelTemplate {
    }

    export interface IItemsPresenter {
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        padding: Windows.UI.Xaml.Thickness;
    }

    export interface IListBox {
        scrollIntoView(item: any): void;
        selectAll(): void;
        selectedItems: Windows.Foundation.Collections.IVector<any>;
        selectionMode: Windows.UI.Xaml.Controls.SelectionMode;
    }

    export interface IListBoxItem {
    }

    export interface IListView {
    }

    export interface IListViewBase {
        add_ItemClick(value: Windows.UI.Xaml.Controls.ItemClickEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ItemClick(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragItemsStarting(value: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragItemsStarting(token: Windows.Foundation.EventRegistrationToken): void;
        scrollIntoView(item: any): void;
        selectAll(): void;
        loadMoreItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Xaml.Data.LoadMoreItemsResult>;
        scrollIntoView(item: any, alignment: Windows.UI.Xaml.Controls.ScrollIntoViewAlignment): void;
        canDragItems: boolean;
        canReorderItems: boolean;
        dataFetchSize: number;
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        incrementalLoadingThreshold: number;
        incrementalLoadingTrigger: Windows.UI.Xaml.Controls.IncrementalLoadingTrigger;
        isItemClickEnabled: boolean;
        isSwipeEnabled: boolean;
        selectedItems: Windows.Foundation.Collections.IVector<any>;
        selectionMode: Windows.UI.Xaml.Controls.ListViewSelectionMode;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dragitemsstarting", listener: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): void;
        removeEventListener(eventName: "dragitemsstarting", listener: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): void;
        ondragitemsstarting: (ev: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler) => void;
        addEventListener(eventName: "itemclick", listener: Windows.UI.Xaml.Controls.ItemClickEventHandler): void;
        removeEventListener(eventName: "itemclick", listener: Windows.UI.Xaml.Controls.ItemClickEventHandler): void;
        onitemclick: (ev: Windows.UI.Xaml.Controls.ItemClickEventHandler) => void;

    }

    export interface IListViewItem {
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings;
    }

    export class Image implements Windows.UI.Xaml.Controls.IImage {
        constructor();
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        nineGrid: Windows.UI.Xaml.Thickness;
        playToSource: Windows.Media.PlayTo.PlayToSource;
        source: Windows.UI.Xaml.Media.ImageSource;
        stretch: Windows.UI.Xaml.Media.Stretch;
        static nineGridProperty: Windows.UI.Xaml.DependencyProperty;
        static playToSourceProperty: Windows.UI.Xaml.DependencyProperty;
        static sourceProperty: Windows.UI.Xaml.DependencyProperty;
        static stretchProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IMediaElement {
        add_MediaOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaOpened(token: Windows.Foundation.EventRegistrationToken): void;
        add_MediaEnded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaEnded(token: Windows.Foundation.EventRegistrationToken): void;
        add_MediaFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_DownloadProgressChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DownloadProgressChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_BufferingProgressChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_BufferingProgressChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentStateChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_MarkerReached(value: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MarkerReached(token: Windows.Foundation.EventRegistrationToken): void;
        add_RateChanged(value: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VolumeChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_VolumeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SeekCompleted(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SeekCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        stop(): void;
        play(): void;
        pause(): void;
        canPlayType(type: string): Windows.UI.Xaml.Media.MediaCanPlayResponse;
        setSource(stream: Windows.Storage.Streams.IRandomAccessStream, mimeType: string): void;
        getAudioStreamLanguage(index: Windows.Foundation.IReference<number>): string;
        addAudioEffect(effectID: string, effectOptional: boolean, effectConfiguration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(effectID: string, effectOptional: boolean, effectConfiguration: Windows.Foundation.Collections.IPropertySet): void;
        removeAllEffects(): void;
        actualStereo3DVideoPackingMode: Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
        aspectRatioHeight: number;
        aspectRatioWidth: number;
        audioCategory: Windows.UI.Xaml.Media.AudioCategory;
        audioDeviceType: Windows.UI.Xaml.Media.AudioDeviceType;
        audioStreamCount: number;
        audioStreamIndex: Windows.Foundation.IReference<number>;
        autoPlay: boolean;
        balance: number;
        bufferingProgress: number;
        canPause: boolean;
        canSeek: boolean;
        currentState: Windows.UI.Xaml.Media.MediaElementState;
        defaultPlaybackRate: number;
        downloadProgress: number;
        downloadProgressOffset: number;
        isAudioOnly: boolean;
        isLooping: boolean;
        isMuted: boolean;
        isStereo3DVideo: boolean;
        markers: Windows.UI.Xaml.Media.TimelineMarkerCollection;
        naturalDuration: Windows.UI.Xaml.Duration;
        naturalVideoHeight: number;
        naturalVideoWidth: number;
        playToSource: Windows.Media.PlayTo.PlayToSource;
        playbackRate: number;
        position: Windows.Foundation.TimeSpan;
        posterSource: Windows.UI.Xaml.Media.ImageSource;
        protectionManager: Windows.Media.Protection.MediaProtectionManager;
        realTimePlayback: boolean;
        source: Windows.Foundation.Uri;
        stereo3DVideoPackingMode: Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
        stereo3DVideoRenderMode: Windows.UI.Xaml.Media.Stereo3DVideoRenderMode;
        volume: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "bufferingprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "bufferingprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onbufferingprogresschanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        oncurrentstatechanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "downloadprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "downloadprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ondownloadprogresschanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "markerreached", listener: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): void;
        removeEventListener(eventName: "markerreached", listener: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): void;
        onmarkerreached: (ev: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler) => void;
        addEventListener(eventName: "mediaended", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "mediaended", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onmediaended: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "mediafailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "mediafailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onmediafailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "mediaopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "mediaopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onmediaopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "ratechanged", listener: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): void;
        removeEventListener(eventName: "ratechanged", listener: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): void;
        onratechanged: (ev: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler) => void;
        addEventListener(eventName: "seekcompleted", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "seekcompleted", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onseekcompleted: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "volumechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "volumechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onvolumechanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface INavigate {
        navigate(sourcePageType: Windows.UI.Xaml.Interop.TypeName): boolean;
    }

    enum IncrementalLoadingTrigger {
        none,
        edge
    }

    export interface INotifyEventArgs {
        value: string;
    }

    export interface IPage {
        bottomAppBar: Windows.UI.Xaml.Controls.AppBar;
        frame: Windows.UI.Xaml.Controls.Frame;
        navigationCacheMode: Windows.UI.Xaml.Navigation.NavigationCacheMode;
        topAppBar: Windows.UI.Xaml.Controls.AppBar;
    }

    export interface IPageOverrides {
        onNavigatedFrom(e: Windows.UI.Xaml.Navigation.NavigationEventArgs): void;
        onNavigatedTo(e: Windows.UI.Xaml.Navigation.NavigationEventArgs): void;
        onNavigatingFrom(e: Windows.UI.Xaml.Navigation.NavigatingCancelEventArgs): void;
    }

    export interface IPanel {
        background: Windows.UI.Xaml.Media.Brush;
        children: Windows.UI.Xaml.Controls.UIElementCollection;
        childrenTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        isItemsHost: boolean;
    }

    export interface IPasswordBox {
        add_PasswordChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PasswordChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        isPasswordRevealButtonEnabled: boolean;
        maxLength: number;
        password: string;
        passwordChar: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "passwordchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "passwordchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onpasswordchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IProgressBar {
        isIndeterminate: boolean;
        showError: boolean;
        showPaused: boolean;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings;
    }

    export interface IProgressRing {
        isActive: boolean;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings;
    }

    export interface IRadioButton {
        groupName: string;
    }

    export interface IRichEditBox {
        add_TextChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_TextChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        acceptsReturn: boolean;
        document: Windows.UI.Text.ITextDocument;
        inputScope: Windows.UI.Xaml.Input.InputScope;
        isReadOnly: boolean;
        isSpellCheckEnabled: boolean;
        isTextPredictionEnabled: boolean;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ontextchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IRichTextBlock {
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        select(start: Windows.UI.Xaml.Documents.TextPointer, end: Windows.UI.Xaml.Documents.TextPointer): void;
        getPositionFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Documents.TextPointer;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        blocks: Windows.UI.Xaml.Documents.BlockCollection;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        hasOverflowContent: boolean;
        isTextSelectionEnabled: boolean;
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        overflowContentTarget: Windows.UI.Xaml.Controls.RichTextBlockOverflow;
        padding: Windows.UI.Xaml.Thickness;
        selectedText: string;
        selectionEnd: Windows.UI.Xaml.Documents.TextPointer;
        selectionStart: Windows.UI.Xaml.Documents.TextPointer;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textIndent: number;
        textTrimming: Windows.UI.Xaml.TextTrimming;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IRichTextBlockOverflow {
        getPositionFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Documents.TextPointer;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentSource: Windows.UI.Xaml.Controls.RichTextBlock;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        hasOverflowContent: boolean;
        overflowContentTarget: Windows.UI.Xaml.Controls.RichTextBlockOverflow;
        padding: Windows.UI.Xaml.Thickness;
    }

    export interface IRowDefinition {
        actualHeight: number;
        height: Windows.UI.Xaml.GridLength;
        maxHeight: number;
        minHeight: number;
    }

    export interface IScrollContentPresenter {
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
    }

    export interface IScrollViewer {
        add_ViewChanged(value: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ViewChanged(token: Windows.Foundation.EventRegistrationToken): void;
        scrollToHorizontalOffset(offset: number): void;
        scrollToVerticalOffset(offset: number): void;
        zoomToFactor(factor: number): void;
        invalidateScrollInfo(): void;
        bringIntoViewOnFocusChange: boolean;
        computedHorizontalScrollBarVisibility: Windows.UI.Xaml.Visibility;
        computedVerticalScrollBarVisibility: Windows.UI.Xaml.Visibility;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        horizontalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility;
        horizontalScrollMode: Windows.UI.Xaml.Controls.ScrollMode;
        horizontalSnapPointsAlignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
        horizontalSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        isDeferredScrollingEnabled: boolean;
        isHorizontalRailEnabled: boolean;
        isHorizontalScrollChainingEnabled: boolean;
        isScrollInertiaEnabled: boolean;
        isVerticalRailEnabled: boolean;
        isVerticalScrollChainingEnabled: boolean;
        isZoomChainingEnabled: boolean;
        isZoomInertiaEnabled: boolean;
        maxZoomFactor: number;
        minZoomFactor: number;
        scrollableHeight: number;
        scrollableWidth: number;
        verticalOffset: number;
        verticalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility;
        verticalScrollMode: Windows.UI.Xaml.Controls.ScrollMode;
        verticalSnapPointsAlignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
        verticalSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        viewportHeight: number;
        viewportWidth: number;
        zoomFactor: number;
        zoomMode: Windows.UI.Xaml.Controls.ZoomMode;
        zoomSnapPoints: Windows.Foundation.Collections.IVector<number>;
        zoomSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "viewchanged", listener: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): void;
        removeEventListener(eventName: "viewchanged", listener: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): void;
        onviewchanged: (ev: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>) => void;

    }

    export interface IScrollViewerViewChangedEventArgs {
        isIntermediate: boolean;
    }

    export interface ISelectionChangedEventArgs {
        addedItems: Windows.Foundation.Collections.IVector<any>;
        removedItems: Windows.Foundation.Collections.IVector<any>;
    }

    export interface ISemanticZoom {
        add_ViewChangeStarted(value: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ViewChangeStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ViewChangeCompleted(value: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ViewChangeCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        toggleActiveView(): void;
        canChangeViews: boolean;
        isZoomOutButtonEnabled: boolean;
        isZoomedInViewActive: boolean;
        zoomedInView: Windows.UI.Xaml.Controls.ISemanticZoomInformation;
        zoomedOutView: Windows.UI.Xaml.Controls.ISemanticZoomInformation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "viewchangecompleted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        removeEventListener(eventName: "viewchangecompleted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        onviewchangecompleted: (ev: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler) => void;
        addEventListener(eventName: "viewchangestarted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        removeEventListener(eventName: "viewchangestarted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        onviewchangestarted: (ev: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler) => void;

    }

    export interface ISemanticZoomInformation {
        initializeViewChange(): void;
        completeViewChange(): void;
        makeVisible(item: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        startViewChangeFrom(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        startViewChangeTo(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        completeViewChangeFrom(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        completeViewChangeTo(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        isActiveView: boolean;
        isZoomedInView: boolean;
        semanticZoomOwner: Windows.UI.Xaml.Controls.SemanticZoom;
    }

    export interface ISemanticZoomLocation {
        bounds: Windows.Foundation.Rect;
        item: any;
    }

    export interface ISemanticZoomViewChangedEventArgs {
        destinationItem: Windows.UI.Xaml.Controls.SemanticZoomLocation;
        isSourceZoomedInView: boolean;
        sourceItem: Windows.UI.Xaml.Controls.SemanticZoomLocation;
    }

    export interface ISlider {
        intermediateValue: number;
        isDirectionReversed: boolean;
        isThumbToolTipEnabled: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        snapsTo: Windows.UI.Xaml.Controls.Primitives.SliderSnapsTo;
        stepFrequency: number;
        thumbToolTipValueConverter: Windows.UI.Xaml.Data.IValueConverter;
        tickFrequency: number;
        tickPlacement: Windows.UI.Xaml.Controls.Primitives.TickPlacement;
    }

    export interface IStackPanel {
        areScrollSnapPointsRegular: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
    }

    export interface IStyleSelector {
        selectStyle(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Style;
    }

    export interface IStyleSelectorOverrides {
        selectStyleCore(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Style;
    }

    export interface ISwapChainBackgroundPanel {
    }

    export class ItemClickEventArgs implements Windows.UI.Xaml.Controls.IItemClickEventArgs {
        constructor();
        clickedItem: any;
    }

    export interface ItemClickEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ItemCollection implements Windows.Foundation.Collections.IObservableVector<any>, Windows.Foundation.Collections.IVector<any>, Windows.Foundation.Collections.IIterable<any> {
        add_VectorChanged(vhnd: Windows.Foundation.Collections.VectorChangedEventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VectorChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getAt(index: number): any;
        getView(): Windows.Foundation.Collections.IVectorView<any>;
        indexOf(value: any): ItemCollection_indexOf_OUT;
        setAt(index: number, value: any): void;
        insertAt(index: number, value: any): void;
        removeAt(index: number): void;
        append(value: any): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): ItemCollection_getMany_OUT;
        replaceAll(items: any[]): void;
        first(): Windows.Foundation.Collections.IIterator<any>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<any>): void;
        removeEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<any>): void;
        onvectorchanged: (ev: Windows.Foundation.Collections.VectorChangedEventHandler<any>) => void;

    }

    interface ItemCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ItemCollection_getMany_OUT {
        __returnValue: number;
        items: any[];
    }

    export class ItemContainerGenerator implements Windows.UI.Xaml.Controls.IItemContainerGenerator {
        add_ItemsChanged(value: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ItemsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        itemFromContainer(container: Windows.UI.Xaml.DependencyObject): any;
        containerFromItem(item: any): Windows.UI.Xaml.DependencyObject;
        indexFromContainer(container: Windows.UI.Xaml.DependencyObject): number;
        containerFromIndex(index: number): Windows.UI.Xaml.DependencyObject;
        getItemContainerGeneratorForPanel(panel: Windows.UI.Xaml.Controls.Panel): Windows.UI.Xaml.Controls.ItemContainerGenerator;
        startAt(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, direction: Windows.UI.Xaml.Controls.Primitives.GeneratorDirection, allowStartAtRealizedItem: boolean): void;
        stop(): void;
        generateNext(): ItemContainerGenerator_generateNext_OUT;
        prepareItemContainer(container: Windows.UI.Xaml.DependencyObject): void;
        removeAll(): void;
        remove(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, count: number): void;
        generatorPositionFromIndex(itemIndex: number): Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
        indexFromGeneratorPosition(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition): number;
        recycle(position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition, count: number): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "itemschanged", listener: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): void;
        removeEventListener(eventName: "itemschanged", listener: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler): void;
        onitemschanged: (ev: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventHandler) => void;

    }

    interface ItemContainerGenerator_generateNext_OUT {
        __returnValue: Windows.UI.Xaml.DependencyObject;
        isNewlyRealized: boolean;
    }

    export class ItemsControl implements Windows.UI.Xaml.Controls.IItemsControl, Windows.UI.Xaml.Controls.IItemsControlOverrides {
        constructor();
        isItemItsOwnContainerOverride(item: any): boolean;
        getContainerForItemOverride(): Windows.UI.Xaml.DependencyObject;
        clearContainerForItemOverride(element: Windows.UI.Xaml.DependencyObject, item: any): void;
        prepareContainerForItemOverride(element: Windows.UI.Xaml.DependencyObject, item: any): void;
        onItemsChanged(e: any): void;
        onItemContainerStyleChanged(oldItemContainerStyle: Windows.UI.Xaml.Style, newItemContainerStyle: Windows.UI.Xaml.Style): void;
        onItemContainerStyleSelectorChanged(oldItemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector, newItemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector): void;
        onItemTemplateChanged(oldItemTemplate: Windows.UI.Xaml.DataTemplate, newItemTemplate: Windows.UI.Xaml.DataTemplate): void;
        onItemTemplateSelectorChanged(oldItemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector, newItemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector): void;
        onGroupStyleSelectorChanged(oldGroupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector, newGroupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector): void;
        static getItemsOwner(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ItemsControl;
        static itemsControlFromItemContainer(container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ItemsControl;
        displayMemberPath: string;
        groupStyle: Windows.Foundation.Collections.IObservableVector<Windows.UI.Xaml.Controls.GroupStyle>;
        groupStyleSelector: Windows.UI.Xaml.Controls.GroupStyleSelector;
        isGrouping: boolean;
        itemContainerGenerator: Windows.UI.Xaml.Controls.ItemContainerGenerator;
        itemContainerStyle: Windows.UI.Xaml.Style;
        itemContainerStyleSelector: Windows.UI.Xaml.Controls.StyleSelector;
        itemContainerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        itemTemplate: Windows.UI.Xaml.DataTemplate;
        itemTemplateSelector: Windows.UI.Xaml.Controls.DataTemplateSelector;
        items: Windows.UI.Xaml.Controls.ItemCollection;
        itemsPanel: Windows.UI.Xaml.Controls.ItemsPanelTemplate;
        itemsSource: any;
        static displayMemberPathProperty: Windows.UI.Xaml.DependencyProperty;
        static groupStyleSelectorProperty: Windows.UI.Xaml.DependencyProperty;
        static isGroupingProperty: Windows.UI.Xaml.DependencyProperty;
        static itemContainerStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static itemContainerStyleSelectorProperty: Windows.UI.Xaml.DependencyProperty;
        static itemContainerTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static itemTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static itemTemplateSelectorProperty: Windows.UI.Xaml.DependencyProperty;
        static itemsPanelProperty: Windows.UI.Xaml.DependencyProperty;
        static itemsSourceProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ItemsPanelTemplate implements Windows.UI.Xaml.Controls.IItemsPanelTemplate {
        constructor();
    }

    export class ItemsPresenter implements Windows.UI.Xaml.Controls.IItemsPresenter, Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo {
        constructor();
        add_HorizontalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_HorizontalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VerticalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VerticalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getIrregularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): Windows.Foundation.Collections.IVectorView<number>;
        getRegularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): ItemsPresenter_getRegularSnapPoints_OUT;
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        padding: Windows.UI.Xaml.Thickness;
        areHorizontalSnapPointsRegular: boolean;
        areVerticalSnapPointsRegular: boolean;
        static headerProperty: Windows.UI.Xaml.DependencyProperty;
        static headerTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static headerTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onhorizontalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onverticalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    interface ItemsPresenter_getRegularSnapPoints_OUT {
        __returnValue: number;
        offset: number;
    }

    export interface ITextBlock {
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        select(start: Windows.UI.Xaml.Documents.TextPointer, end: Windows.UI.Xaml.Documents.TextPointer): void;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
        isTextSelectionEnabled: boolean;
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        padding: Windows.UI.Xaml.Thickness;
        selectedText: string;
        selectionEnd: Windows.UI.Xaml.Documents.TextPointer;
        selectionStart: Windows.UI.Xaml.Documents.TextPointer;
        text: string;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textTrimming: Windows.UI.Xaml.TextTrimming;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface ITextBox {
        add_TextChanged(value: Windows.UI.Xaml.Controls.TextChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_TextChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        select(start: number, length: number): void;
        selectAll(): void;
        getRectFromCharacterIndex(charIndex: number, trailingEdge: boolean): Windows.Foundation.Rect;
        acceptsReturn: boolean;
        inputScope: Windows.UI.Xaml.Input.InputScope;
        isReadOnly: boolean;
        isSpellCheckEnabled: boolean;
        isTextPredictionEnabled: boolean;
        maxLength: number;
        selectedText: string;
        selectionLength: number;
        selectionStart: number;
        text: string;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.Controls.TextChangedEventHandler): void;
        removeEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.Controls.TextChangedEventHandler): void;
        ontextchanged: (ev: Windows.UI.Xaml.Controls.TextChangedEventHandler) => void;

    }

    export interface ITextChangedEventArgs {
    }

    export interface IToggleSwitch {
        add_Toggled(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Toggled(token: Windows.Foundation.EventRegistrationToken): void;
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        isOn: boolean;
        offContent: any;
        offContentTemplate: Windows.UI.Xaml.DataTemplate;
        onContent: any;
        onContentTemplate: Windows.UI.Xaml.DataTemplate;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "toggled", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "toggled", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ontoggled: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IToggleSwitchOverrides {
        onToggled(): void;
        onOnContentChanged(oldContent: any, newContent: any): void;
        onOffContentChanged(oldContent: any, newContent: any): void;
        onHeaderChanged(oldContent: any, newContent: any): void;
    }

    export interface IToolTip {
        add_Closed(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        add_Opened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        horizontalOffset: number;
        isOpen: boolean;
        placement: Windows.UI.Xaml.Controls.Primitives.PlacementMode;
        placementTarget: Windows.UI.Xaml.UIElement;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings;
        verticalOffset: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "closed", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onclosed: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "opened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "opened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IToolTipService {
    }

    export interface IUserControl {
        content: Windows.UI.Xaml.UIElement;
    }

    export interface IVariableSizedWrapGrid {
        horizontalChildrenAlignment: Windows.UI.Xaml.HorizontalAlignment;
        itemHeight: number;
        itemWidth: number;
        maximumRowsOrColumns: number;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        verticalChildrenAlignment: Windows.UI.Xaml.VerticalAlignment;
    }

    export interface IViewbox {
        child: Windows.UI.Xaml.UIElement;
        stretch: Windows.UI.Xaml.Media.Stretch;
        stretchDirection: Windows.UI.Xaml.Controls.StretchDirection;
    }

    export interface IVirtualizingPanel {
        itemContainerGenerator: Windows.UI.Xaml.Controls.ItemContainerGenerator;
    }

    export interface IVirtualizingPanelOverrides {
        onItemsChanged(sender: any, args: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs): void;
        onClearChildren(): void;
        bringIndexIntoView(index: number): void;
    }

    export interface IVirtualizingPanelProtected {
        addInternalChild(child: Windows.UI.Xaml.UIElement): void;
        insertInternalChild(index: number, child: Windows.UI.Xaml.UIElement): void;
        removeInternalChildRange(index: number, range: number): void;
    }

    export interface IVirtualizingStackPanel {
        add_CleanUpVirtualizedItemEvent(value: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CleanUpVirtualizedItemEvent(token: Windows.Foundation.EventRegistrationToken): void;
        areScrollSnapPointsRegular: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "cleanupvirtualizeditemevent", listener: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): void;
        removeEventListener(eventName: "cleanupvirtualizeditemevent", listener: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): void;
        oncleanupvirtualizeditemevent: (ev: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler) => void;

    }

    export interface IVirtualizingStackPanelOverrides {
        onCleanUpVirtualizedItem(e: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventArgs): void;
    }

    export interface IWebView {
        add_LoadCompleted(value: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LoadCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ScriptNotify(value: Windows.UI.Xaml.Controls.NotifyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ScriptNotify(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationFailed(value: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationFailed(token: Windows.Foundation.EventRegistrationToken): void;
        invokeScript(scriptName: string, arguments: string[]): string;
        navigate(source: Windows.Foundation.Uri): void;
        navigateToString(text: string): void;
        allowedScriptNotifyUris: Windows.Foundation.Collections.IVector<Windows.Foundation.Uri>;
        dataTransferPackage: Windows.ApplicationModel.DataTransfer.DataPackage;
        source: Windows.Foundation.Uri;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "loadcompleted", listener: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): void;
        removeEventListener(eventName: "loadcompleted", listener: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): void;
        onloadcompleted: (ev: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler) => void;
        addEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): void;
        removeEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): void;
        onnavigationfailed: (ev: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler) => void;
        addEventListener(eventName: "scriptnotify", listener: Windows.UI.Xaml.Controls.NotifyEventHandler): void;
        removeEventListener(eventName: "scriptnotify", listener: Windows.UI.Xaml.Controls.NotifyEventHandler): void;
        onscriptnotify: (ev: Windows.UI.Xaml.Controls.NotifyEventHandler) => void;

    }

    export interface IWebViewBrush {
        redraw(): void;
        setSource(source: Windows.UI.Xaml.Controls.WebView): void;
        sourceName: string;
    }

    export interface IWebViewNavigationFailedEventArgs {
        uri: Windows.Foundation.Uri;
        webErrorStatus: Windows.Web.WebErrorStatus;
    }

    export interface IWrapGrid {
        horizontalChildrenAlignment: Windows.UI.Xaml.HorizontalAlignment;
        itemHeight: number;
        itemWidth: number;
        maximumRowsOrColumns: number;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        verticalChildrenAlignment: Windows.UI.Xaml.VerticalAlignment;
    }

    export class ListBox implements Windows.UI.Xaml.Controls.IListBox {
        constructor();
        scrollIntoView(item: any): void;
        selectAll(): void;
        selectedItems: Windows.Foundation.Collections.IVector<any>;
        selectionMode: Windows.UI.Xaml.Controls.SelectionMode;
        static selectionModeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ListBoxItem implements Windows.UI.Xaml.Controls.IListBoxItem {
        constructor();
    }

    export class ListView implements Windows.UI.Xaml.Controls.IListView {
        constructor();
    }

    export class ListViewBase implements Windows.UI.Xaml.Controls.IListViewBase, Windows.UI.Xaml.Controls.ISemanticZoomInformation {
        constructor();
        add_ItemClick(value: Windows.UI.Xaml.Controls.ItemClickEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ItemClick(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragItemsStarting(value: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragItemsStarting(token: Windows.Foundation.EventRegistrationToken): void;
        scrollIntoView(item: any): void;
        selectAll(): void;
        loadMoreItemsAsync(): Windows.Foundation.IAsyncOperation<Windows.UI.Xaml.Data.LoadMoreItemsResult>;
        scrollIntoView(item: any, alignment: Windows.UI.Xaml.Controls.ScrollIntoViewAlignment): void;
        initializeViewChange(): void;
        completeViewChange(): void;
        makeVisible(item: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        startViewChangeFrom(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        startViewChangeTo(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        completeViewChangeFrom(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        completeViewChangeTo(source: Windows.UI.Xaml.Controls.SemanticZoomLocation, destination: Windows.UI.Xaml.Controls.SemanticZoomLocation): void;
        canDragItems: boolean;
        canReorderItems: boolean;
        dataFetchSize: number;
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        headerTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        incrementalLoadingThreshold: number;
        incrementalLoadingTrigger: Windows.UI.Xaml.Controls.IncrementalLoadingTrigger;
        isItemClickEnabled: boolean;
        isSwipeEnabled: boolean;
        selectedItems: Windows.Foundation.Collections.IVector<any>;
        selectionMode: Windows.UI.Xaml.Controls.ListViewSelectionMode;
        isActiveView: boolean;
        isZoomedInView: boolean;
        semanticZoomOwner: Windows.UI.Xaml.Controls.SemanticZoom;
        static canDragItemsProperty: Windows.UI.Xaml.DependencyProperty;
        static canReorderItemsProperty: Windows.UI.Xaml.DependencyProperty;
        static dataFetchSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static headerProperty: Windows.UI.Xaml.DependencyProperty;
        static headerTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static headerTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static incrementalLoadingThresholdProperty: Windows.UI.Xaml.DependencyProperty;
        static incrementalLoadingTriggerProperty: Windows.UI.Xaml.DependencyProperty;
        static isActiveViewProperty: Windows.UI.Xaml.DependencyProperty;
        static isItemClickEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isSwipeEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isZoomedInViewProperty: Windows.UI.Xaml.DependencyProperty;
        static selectionModeProperty: Windows.UI.Xaml.DependencyProperty;
        static semanticZoomOwnerProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dragitemsstarting", listener: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): void;
        removeEventListener(eventName: "dragitemsstarting", listener: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler): void;
        ondragitemsstarting: (ev: Windows.UI.Xaml.Controls.DragItemsStartingEventHandler) => void;
        addEventListener(eventName: "itemclick", listener: Windows.UI.Xaml.Controls.ItemClickEventHandler): void;
        removeEventListener(eventName: "itemclick", listener: Windows.UI.Xaml.Controls.ItemClickEventHandler): void;
        onitemclick: (ev: Windows.UI.Xaml.Controls.ItemClickEventHandler) => void;

    }

    export class ListViewItem implements Windows.UI.Xaml.Controls.IListViewItem {
        constructor();
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ListViewItemTemplateSettings;
    }

    enum ListViewSelectionMode {
        none,
        single,
        multiple,
        extended
    }

    export class MediaElement implements Windows.UI.Xaml.Controls.IMediaElement {
        constructor();
        add_MediaOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaOpened(token: Windows.Foundation.EventRegistrationToken): void;
        add_MediaEnded(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaEnded(token: Windows.Foundation.EventRegistrationToken): void;
        add_MediaFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MediaFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_DownloadProgressChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DownloadProgressChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_BufferingProgressChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_BufferingProgressChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentStateChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentStateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_MarkerReached(value: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_MarkerReached(token: Windows.Foundation.EventRegistrationToken): void;
        add_RateChanged(value: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_RateChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VolumeChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_VolumeChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SeekCompleted(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SeekCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        stop(): void;
        play(): void;
        pause(): void;
        canPlayType(type: string): Windows.UI.Xaml.Media.MediaCanPlayResponse;
        setSource(stream: Windows.Storage.Streams.IRandomAccessStream, mimeType: string): void;
        getAudioStreamLanguage(index: Windows.Foundation.IReference<number>): string;
        addAudioEffect(effectID: string, effectOptional: boolean, effectConfiguration: Windows.Foundation.Collections.IPropertySet): void;
        addVideoEffect(effectID: string, effectOptional: boolean, effectConfiguration: Windows.Foundation.Collections.IPropertySet): void;
        removeAllEffects(): void;
        actualStereo3DVideoPackingMode: Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
        aspectRatioHeight: number;
        aspectRatioWidth: number;
        audioCategory: Windows.UI.Xaml.Media.AudioCategory;
        audioDeviceType: Windows.UI.Xaml.Media.AudioDeviceType;
        audioStreamCount: number;
        audioStreamIndex: Windows.Foundation.IReference<number>;
        autoPlay: boolean;
        balance: number;
        bufferingProgress: number;
        canPause: boolean;
        canSeek: boolean;
        currentState: Windows.UI.Xaml.Media.MediaElementState;
        defaultPlaybackRate: number;
        downloadProgress: number;
        downloadProgressOffset: number;
        isAudioOnly: boolean;
        isLooping: boolean;
        isMuted: boolean;
        isStereo3DVideo: boolean;
        markers: Windows.UI.Xaml.Media.TimelineMarkerCollection;
        naturalDuration: Windows.UI.Xaml.Duration;
        naturalVideoHeight: number;
        naturalVideoWidth: number;
        playToSource: Windows.Media.PlayTo.PlayToSource;
        playbackRate: number;
        position: Windows.Foundation.TimeSpan;
        posterSource: Windows.UI.Xaml.Media.ImageSource;
        protectionManager: Windows.Media.Protection.MediaProtectionManager;
        realTimePlayback: boolean;
        source: Windows.Foundation.Uri;
        stereo3DVideoPackingMode: Windows.UI.Xaml.Media.Stereo3DVideoPackingMode;
        stereo3DVideoRenderMode: Windows.UI.Xaml.Media.Stereo3DVideoRenderMode;
        volume: number;
        static actualStereo3DVideoPackingModeProperty: Windows.UI.Xaml.DependencyProperty;
        static aspectRatioHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static aspectRatioWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static audioCategoryProperty: Windows.UI.Xaml.DependencyProperty;
        static audioDeviceTypeProperty: Windows.UI.Xaml.DependencyProperty;
        static audioStreamCountProperty: Windows.UI.Xaml.DependencyProperty;
        static audioStreamIndexProperty: Windows.UI.Xaml.DependencyProperty;
        static autoPlayProperty: Windows.UI.Xaml.DependencyProperty;
        static balanceProperty: Windows.UI.Xaml.DependencyProperty;
        static bufferingProgressProperty: Windows.UI.Xaml.DependencyProperty;
        static canPauseProperty: Windows.UI.Xaml.DependencyProperty;
        static canSeekProperty: Windows.UI.Xaml.DependencyProperty;
        static currentStateProperty: Windows.UI.Xaml.DependencyProperty;
        static defaultPlaybackRateProperty: Windows.UI.Xaml.DependencyProperty;
        static downloadProgressOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static downloadProgressProperty: Windows.UI.Xaml.DependencyProperty;
        static isAudioOnlyProperty: Windows.UI.Xaml.DependencyProperty;
        static isLoopingProperty: Windows.UI.Xaml.DependencyProperty;
        static isMutedProperty: Windows.UI.Xaml.DependencyProperty;
        static isStereo3DVideoProperty: Windows.UI.Xaml.DependencyProperty;
        static naturalDurationProperty: Windows.UI.Xaml.DependencyProperty;
        static naturalVideoHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static naturalVideoWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static playToSourceProperty: Windows.UI.Xaml.DependencyProperty;
        static playbackRateProperty: Windows.UI.Xaml.DependencyProperty;
        static positionProperty: Windows.UI.Xaml.DependencyProperty;
        static posterSourceProperty: Windows.UI.Xaml.DependencyProperty;
        static protectionManagerProperty: Windows.UI.Xaml.DependencyProperty;
        static realTimePlaybackProperty: Windows.UI.Xaml.DependencyProperty;
        static sourceProperty: Windows.UI.Xaml.DependencyProperty;
        static stereo3DVideoPackingModeProperty: Windows.UI.Xaml.DependencyProperty;
        static stereo3DVideoRenderModeProperty: Windows.UI.Xaml.DependencyProperty;
        static volumeProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "bufferingprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "bufferingprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onbufferingprogresschanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "currentstatechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        oncurrentstatechanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "downloadprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "downloadprogresschanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ondownloadprogresschanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "markerreached", listener: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): void;
        removeEventListener(eventName: "markerreached", listener: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler): void;
        onmarkerreached: (ev: Windows.UI.Xaml.Media.TimelineMarkerRoutedEventHandler) => void;
        addEventListener(eventName: "mediaended", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "mediaended", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onmediaended: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "mediafailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "mediafailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onmediafailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "mediaopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "mediaopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onmediaopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "ratechanged", listener: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): void;
        removeEventListener(eventName: "ratechanged", listener: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler): void;
        onratechanged: (ev: Windows.UI.Xaml.Media.RateChangedRoutedEventHandler) => void;
        addEventListener(eventName: "seekcompleted", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "seekcompleted", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onseekcompleted: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "volumechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "volumechanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onvolumechanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class NotifyEventArgs implements Windows.UI.Xaml.Controls.INotifyEventArgs {
        value: string;
    }

    export interface NotifyEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum Orientation {
        vertical,
        horizontal
    }

    export class Page implements Windows.UI.Xaml.Controls.IPage, Windows.UI.Xaml.Controls.IPageOverrides {
        constructor();
        onNavigatedFrom(e: Windows.UI.Xaml.Navigation.NavigationEventArgs): void;
        onNavigatedTo(e: Windows.UI.Xaml.Navigation.NavigationEventArgs): void;
        onNavigatingFrom(e: Windows.UI.Xaml.Navigation.NavigatingCancelEventArgs): void;
        bottomAppBar: Windows.UI.Xaml.Controls.AppBar;
        frame: Windows.UI.Xaml.Controls.Frame;
        navigationCacheMode: Windows.UI.Xaml.Navigation.NavigationCacheMode;
        topAppBar: Windows.UI.Xaml.Controls.AppBar;
        static bottomAppBarProperty: Windows.UI.Xaml.DependencyProperty;
        static frameProperty: Windows.UI.Xaml.DependencyProperty;
        static topAppBarProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Panel implements Windows.UI.Xaml.Controls.IPanel {
        constructor();
        background: Windows.UI.Xaml.Media.Brush;
        children: Windows.UI.Xaml.Controls.UIElementCollection;
        childrenTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        isItemsHost: boolean;
        static backgroundProperty: Windows.UI.Xaml.DependencyProperty;
        static childrenTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static isItemsHostProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PasswordBox implements Windows.UI.Xaml.Controls.IPasswordBox {
        constructor();
        add_PasswordChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PasswordChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        isPasswordRevealButtonEnabled: boolean;
        maxLength: number;
        password: string;
        passwordChar: string;
        static isPasswordRevealButtonEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static maxLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static passwordCharProperty: Windows.UI.Xaml.DependencyProperty;
        static passwordProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "passwordchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "passwordchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onpasswordchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class ProgressBar implements Windows.UI.Xaml.Controls.IProgressBar {
        constructor();
        isIndeterminate: boolean;
        showError: boolean;
        showPaused: boolean;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ProgressBarTemplateSettings;
        static isIndeterminateProperty: Windows.UI.Xaml.DependencyProperty;
        static showErrorProperty: Windows.UI.Xaml.DependencyProperty;
        static showPausedProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ProgressRing implements Windows.UI.Xaml.Controls.IProgressRing {
        constructor();
        isActive: boolean;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ProgressRingTemplateSettings;
        static isActiveProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RadioButton implements Windows.UI.Xaml.Controls.IRadioButton {
        constructor();
        groupName: string;
        static groupNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RichEditBox implements Windows.UI.Xaml.Controls.IRichEditBox {
        constructor();
        add_TextChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_TextChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        acceptsReturn: boolean;
        document: Windows.UI.Text.ITextDocument;
        inputScope: Windows.UI.Xaml.Input.InputScope;
        isReadOnly: boolean;
        isSpellCheckEnabled: boolean;
        isTextPredictionEnabled: boolean;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        static acceptsReturnProperty: Windows.UI.Xaml.DependencyProperty;
        static inputScopeProperty: Windows.UI.Xaml.DependencyProperty;
        static isReadOnlyProperty: Windows.UI.Xaml.DependencyProperty;
        static isSpellCheckEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isTextPredictionEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static textAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static textWrappingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ontextchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class RichTextBlock implements Windows.UI.Xaml.Controls.IRichTextBlock {
        constructor();
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        select(start: Windows.UI.Xaml.Documents.TextPointer, end: Windows.UI.Xaml.Documents.TextPointer): void;
        getPositionFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Documents.TextPointer;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        blocks: Windows.UI.Xaml.Documents.BlockCollection;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        hasOverflowContent: boolean;
        isTextSelectionEnabled: boolean;
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        overflowContentTarget: Windows.UI.Xaml.Controls.RichTextBlockOverflow;
        padding: Windows.UI.Xaml.Thickness;
        selectedText: string;
        selectionEnd: Windows.UI.Xaml.Documents.TextPointer;
        selectionStart: Windows.UI.Xaml.Documents.TextPointer;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textIndent: number;
        textTrimming: Windows.UI.Xaml.TextTrimming;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        static characterSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static fontFamilyProperty: Windows.UI.Xaml.DependencyProperty;
        static fontSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStretchProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static fontWeightProperty: Windows.UI.Xaml.DependencyProperty;
        static foregroundProperty: Windows.UI.Xaml.DependencyProperty;
        static hasOverflowContentProperty: Windows.UI.Xaml.DependencyProperty;
        static isTextSelectionEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static lineHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static lineStackingStrategyProperty: Windows.UI.Xaml.DependencyProperty;
        static overflowContentTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedTextProperty: Windows.UI.Xaml.DependencyProperty;
        static textAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static textIndentProperty: Windows.UI.Xaml.DependencyProperty;
        static textTrimmingProperty: Windows.UI.Xaml.DependencyProperty;
        static textWrappingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class RichTextBlockOverflow implements Windows.UI.Xaml.Controls.IRichTextBlockOverflow {
        constructor();
        getPositionFromPoint(point: Windows.Foundation.Point): Windows.UI.Xaml.Documents.TextPointer;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentSource: Windows.UI.Xaml.Controls.RichTextBlock;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        hasOverflowContent: boolean;
        overflowContentTarget: Windows.UI.Xaml.Controls.RichTextBlockOverflow;
        padding: Windows.UI.Xaml.Thickness;
        static hasOverflowContentProperty: Windows.UI.Xaml.DependencyProperty;
        static overflowContentTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RowDefinition implements Windows.UI.Xaml.Controls.IRowDefinition {
        constructor();
        actualHeight: number;
        height: Windows.UI.Xaml.GridLength;
        maxHeight: number;
        minHeight: number;
        static heightProperty: Windows.UI.Xaml.DependencyProperty;
        static maxHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static minHeightProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RowDefinitionCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Controls.RowDefinition>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Controls.RowDefinition> {
        getAt(index: number): Windows.UI.Xaml.Controls.RowDefinition;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Controls.RowDefinition>;
        indexOf(value: Windows.UI.Xaml.Controls.RowDefinition): RowDefinitionCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Controls.RowDefinition): void;
        insertAt(index: number, value: Windows.UI.Xaml.Controls.RowDefinition): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Controls.RowDefinition): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): RowDefinitionCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Controls.RowDefinition[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Controls.RowDefinition>;
        size: number;
    }

    interface RowDefinitionCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface RowDefinitionCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Controls.RowDefinition[];
    }

    enum ScrollBarVisibility {
        disabled,
        auto,
        hidden,
        visible
    }

    export class ScrollContentPresenter implements Windows.UI.Xaml.Controls.IScrollContentPresenter {
        constructor();
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
    }

    enum ScrollIntoViewAlignment {
        default,
        leading
    }

    enum ScrollMode {
        disabled,
        enabled,
        auto
    }

    export class ScrollViewer implements Windows.UI.Xaml.Controls.IScrollViewer {
        constructor();
        add_ViewChanged(value: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): Windows.Foundation.EventRegistrationToken;
        remove_ViewChanged(token: Windows.Foundation.EventRegistrationToken): void;
        scrollToHorizontalOffset(offset: number): void;
        scrollToVerticalOffset(offset: number): void;
        zoomToFactor(factor: number): void;
        invalidateScrollInfo(): void;
        static getHorizontalScrollBarVisibility(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ScrollBarVisibility;
        static setHorizontalScrollBarVisibility(element: Windows.UI.Xaml.DependencyObject, horizontalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility): void;
        static getVerticalScrollBarVisibility(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ScrollBarVisibility;
        static setVerticalScrollBarVisibility(element: Windows.UI.Xaml.DependencyObject, verticalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility): void;
        static getIsHorizontalRailEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsHorizontalRailEnabled(element: Windows.UI.Xaml.DependencyObject, isHorizontalRailEnabled: boolean): void;
        static getIsVerticalRailEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsVerticalRailEnabled(element: Windows.UI.Xaml.DependencyObject, isVerticalRailEnabled: boolean): void;
        static getIsHorizontalScrollChainingEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsHorizontalScrollChainingEnabled(element: Windows.UI.Xaml.DependencyObject, isHorizontalScrollChainingEnabled: boolean): void;
        static getIsVerticalScrollChainingEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsVerticalScrollChainingEnabled(element: Windows.UI.Xaml.DependencyObject, isVerticalScrollChainingEnabled: boolean): void;
        static getIsZoomChainingEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsZoomChainingEnabled(element: Windows.UI.Xaml.DependencyObject, isZoomChainingEnabled: boolean): void;
        static getIsScrollInertiaEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsScrollInertiaEnabled(element: Windows.UI.Xaml.DependencyObject, isScrollInertiaEnabled: boolean): void;
        static getIsZoomInertiaEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsZoomInertiaEnabled(element: Windows.UI.Xaml.DependencyObject, isZoomInertiaEnabled: boolean): void;
        static getHorizontalScrollMode(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ScrollMode;
        static setHorizontalScrollMode(element: Windows.UI.Xaml.DependencyObject, horizontalScrollMode: Windows.UI.Xaml.Controls.ScrollMode): void;
        static getVerticalScrollMode(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ScrollMode;
        static setVerticalScrollMode(element: Windows.UI.Xaml.DependencyObject, verticalScrollMode: Windows.UI.Xaml.Controls.ScrollMode): void;
        static getZoomMode(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.ZoomMode;
        static setZoomMode(element: Windows.UI.Xaml.DependencyObject, zoomMode: Windows.UI.Xaml.Controls.ZoomMode): void;
        static getIsDeferredScrollingEnabled(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setIsDeferredScrollingEnabled(element: Windows.UI.Xaml.DependencyObject, isDeferredScrollingEnabled: boolean): void;
        static getBringIntoViewOnFocusChange(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setBringIntoViewOnFocusChange(element: Windows.UI.Xaml.DependencyObject, bringIntoViewOnFocusChange: boolean): void;
        bringIntoViewOnFocusChange: boolean;
        computedHorizontalScrollBarVisibility: Windows.UI.Xaml.Visibility;
        computedVerticalScrollBarVisibility: Windows.UI.Xaml.Visibility;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        horizontalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility;
        horizontalScrollMode: Windows.UI.Xaml.Controls.ScrollMode;
        horizontalSnapPointsAlignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
        horizontalSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        isDeferredScrollingEnabled: boolean;
        isHorizontalRailEnabled: boolean;
        isHorizontalScrollChainingEnabled: boolean;
        isScrollInertiaEnabled: boolean;
        isVerticalRailEnabled: boolean;
        isVerticalScrollChainingEnabled: boolean;
        isZoomChainingEnabled: boolean;
        isZoomInertiaEnabled: boolean;
        maxZoomFactor: number;
        minZoomFactor: number;
        scrollableHeight: number;
        scrollableWidth: number;
        verticalOffset: number;
        verticalScrollBarVisibility: Windows.UI.Xaml.Controls.ScrollBarVisibility;
        verticalScrollMode: Windows.UI.Xaml.Controls.ScrollMode;
        verticalSnapPointsAlignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment;
        verticalSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        viewportHeight: number;
        viewportWidth: number;
        zoomFactor: number;
        zoomMode: Windows.UI.Xaml.Controls.ZoomMode;
        zoomSnapPoints: Windows.Foundation.Collections.IVector<number>;
        zoomSnapPointsType: Windows.UI.Xaml.Controls.SnapPointsType;
        static bringIntoViewOnFocusChangeProperty: Windows.UI.Xaml.DependencyProperty;
        static computedHorizontalScrollBarVisibilityProperty: Windows.UI.Xaml.DependencyProperty;
        static computedVerticalScrollBarVisibilityProperty: Windows.UI.Xaml.DependencyProperty;
        static extentHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static extentWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalScrollBarVisibilityProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalScrollModeProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalSnapPointsAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalSnapPointsTypeProperty: Windows.UI.Xaml.DependencyProperty;
        static isDeferredScrollingEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isHorizontalRailEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isHorizontalScrollChainingEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isScrollInertiaEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isVerticalRailEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isVerticalScrollChainingEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isZoomChainingEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isZoomInertiaEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static maxZoomFactorProperty: Windows.UI.Xaml.DependencyProperty;
        static minZoomFactorProperty: Windows.UI.Xaml.DependencyProperty;
        static scrollableHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static scrollableWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalScrollBarVisibilityProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalScrollModeProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalSnapPointsAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalSnapPointsTypeProperty: Windows.UI.Xaml.DependencyProperty;
        static viewportHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static viewportWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomFactorProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomModeProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomSnapPointsProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomSnapPointsTypeProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "viewchanged", listener: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): void;
        removeEventListener(eventName: "viewchanged", listener: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>): void;
        onviewchanged: (ev: Windows.Foundation.EventHandler<Windows.UI.Xaml.Controls.ScrollViewerViewChangedEventArgs>) => void;

    }

    export class ScrollViewerViewChangedEventArgs implements Windows.UI.Xaml.Controls.IScrollViewerViewChangedEventArgs {
        constructor();
        isIntermediate: boolean;
    }

    export class SelectionChangedEventArgs implements Windows.UI.Xaml.Controls.ISelectionChangedEventArgs {
        constructor(removedItems: Windows.Foundation.Collections.IVector<any>, addedItems: Windows.Foundation.Collections.IVector<any>);
        addedItems: Windows.Foundation.Collections.IVector<any>;
        removedItems: Windows.Foundation.Collections.IVector<any>;
    }

    export interface SelectionChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum SelectionMode {
        single,
        multiple,
        extended
    }

    export class SemanticZoom implements Windows.UI.Xaml.Controls.ISemanticZoom {
        constructor();
        add_ViewChangeStarted(value: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ViewChangeStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ViewChangeCompleted(value: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ViewChangeCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        toggleActiveView(): void;
        canChangeViews: boolean;
        isZoomOutButtonEnabled: boolean;
        isZoomedInViewActive: boolean;
        zoomedInView: Windows.UI.Xaml.Controls.ISemanticZoomInformation;
        zoomedOutView: Windows.UI.Xaml.Controls.ISemanticZoomInformation;
        static canChangeViewsProperty: Windows.UI.Xaml.DependencyProperty;
        static isZoomOutButtonEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isZoomedInViewActiveProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomedInViewProperty: Windows.UI.Xaml.DependencyProperty;
        static zoomedOutViewProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "viewchangecompleted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        removeEventListener(eventName: "viewchangecompleted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        onviewchangecompleted: (ev: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler) => void;
        addEventListener(eventName: "viewchangestarted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        removeEventListener(eventName: "viewchangestarted", listener: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler): void;
        onviewchangestarted: (ev: Windows.UI.Xaml.Controls.SemanticZoomViewChangedEventHandler) => void;

    }

    export class SemanticZoomLocation implements Windows.UI.Xaml.Controls.ISemanticZoomLocation {
        constructor();
        bounds: Windows.Foundation.Rect;
        item: any;
    }

    export class SemanticZoomViewChangedEventArgs implements Windows.UI.Xaml.Controls.ISemanticZoomViewChangedEventArgs {
        constructor();
        destinationItem: Windows.UI.Xaml.Controls.SemanticZoomLocation;
        isSourceZoomedInView: boolean;
        sourceItem: Windows.UI.Xaml.Controls.SemanticZoomLocation;
    }

    export interface SemanticZoomViewChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class Slider implements Windows.UI.Xaml.Controls.ISlider {
        constructor();
        intermediateValue: number;
        isDirectionReversed: boolean;
        isThumbToolTipEnabled: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        snapsTo: Windows.UI.Xaml.Controls.Primitives.SliderSnapsTo;
        stepFrequency: number;
        thumbToolTipValueConverter: Windows.UI.Xaml.Data.IValueConverter;
        tickFrequency: number;
        tickPlacement: Windows.UI.Xaml.Controls.Primitives.TickPlacement;
        static intermediateValueProperty: Windows.UI.Xaml.DependencyProperty;
        static isDirectionReversedProperty: Windows.UI.Xaml.DependencyProperty;
        static isThumbToolTipEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        static snapsToProperty: Windows.UI.Xaml.DependencyProperty;
        static stepFrequencyProperty: Windows.UI.Xaml.DependencyProperty;
        static thumbToolTipValueConverterProperty: Windows.UI.Xaml.DependencyProperty;
        static tickFrequencyProperty: Windows.UI.Xaml.DependencyProperty;
        static tickPlacementProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum SnapPointsType {
        none,
        optional,
        mandatory,
        optionalSingle,
        mandatorySingle
    }

    export class StackPanel implements Windows.UI.Xaml.Controls.IStackPanel, Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo {
        constructor();
        add_HorizontalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_HorizontalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VerticalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VerticalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getIrregularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): Windows.Foundation.Collections.IVectorView<number>;
        getRegularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): StackPanel_getRegularSnapPoints_OUT;
        areScrollSnapPointsRegular: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        areHorizontalSnapPointsRegular: boolean;
        areVerticalSnapPointsRegular: boolean;
        static areScrollSnapPointsRegularProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onhorizontalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onverticalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    interface StackPanel_getRegularSnapPoints_OUT {
        __returnValue: number;
        offset: number;
    }

    enum StretchDirection {
        upOnly,
        downOnly,
        both
    }

    export class StyleSelector implements Windows.UI.Xaml.Controls.IStyleSelector, Windows.UI.Xaml.Controls.IStyleSelectorOverrides {
        constructor();
        selectStyle(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Style;
        selectStyleCore(item: any, container: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Style;
    }

    export class SwapChainBackgroundPanel implements Windows.UI.Xaml.Controls.ISwapChainBackgroundPanel {
        constructor();
    }

    export class TextBlock implements Windows.UI.Xaml.Controls.ITextBlock {
        constructor();
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        selectAll(): void;
        select(start: Windows.UI.Xaml.Documents.TextPointer, end: Windows.UI.Xaml.Documents.TextPointer): void;
        focus(value: Windows.UI.Xaml.FocusState): boolean;
        baselineOffset: number;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
        isTextSelectionEnabled: boolean;
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        padding: Windows.UI.Xaml.Thickness;
        selectedText: string;
        selectionEnd: Windows.UI.Xaml.Documents.TextPointer;
        selectionStart: Windows.UI.Xaml.Documents.TextPointer;
        text: string;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textTrimming: Windows.UI.Xaml.TextTrimming;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        static characterSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static fontFamilyProperty: Windows.UI.Xaml.DependencyProperty;
        static fontSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStretchProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static fontWeightProperty: Windows.UI.Xaml.DependencyProperty;
        static foregroundProperty: Windows.UI.Xaml.DependencyProperty;
        static isTextSelectionEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static lineHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static lineStackingStrategyProperty: Windows.UI.Xaml.DependencyProperty;
        static paddingProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedTextProperty: Windows.UI.Xaml.DependencyProperty;
        static textAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static textProperty: Windows.UI.Xaml.DependencyProperty;
        static textTrimmingProperty: Windows.UI.Xaml.DependencyProperty;
        static textWrappingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class TextBox implements Windows.UI.Xaml.Controls.ITextBox {
        constructor();
        add_TextChanged(value: Windows.UI.Xaml.Controls.TextChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_TextChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_SelectionChanged(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_ContextMenuOpening(value: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ContextMenuOpening(token: Windows.Foundation.EventRegistrationToken): void;
        select(start: number, length: number): void;
        selectAll(): void;
        getRectFromCharacterIndex(charIndex: number, trailingEdge: boolean): Windows.Foundation.Rect;
        acceptsReturn: boolean;
        inputScope: Windows.UI.Xaml.Input.InputScope;
        isReadOnly: boolean;
        isSpellCheckEnabled: boolean;
        isTextPredictionEnabled: boolean;
        maxLength: number;
        selectedText: string;
        selectionLength: number;
        selectionStart: number;
        text: string;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        textWrapping: Windows.UI.Xaml.TextWrapping;
        static acceptsReturnProperty: Windows.UI.Xaml.DependencyProperty;
        static inputScopeProperty: Windows.UI.Xaml.DependencyProperty;
        static isReadOnlyProperty: Windows.UI.Xaml.DependencyProperty;
        static isSpellCheckEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isTextPredictionEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static maxLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static textAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static textProperty: Windows.UI.Xaml.DependencyProperty;
        static textWrappingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        removeEventListener(eventName: "contextmenuopening", listener: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler): void;
        oncontextmenuopening: (ev: Windows.UI.Xaml.Controls.ContextMenuOpeningEventHandler) => void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.Controls.TextChangedEventHandler): void;
        removeEventListener(eventName: "textchanged", listener: Windows.UI.Xaml.Controls.TextChangedEventHandler): void;
        ontextchanged: (ev: Windows.UI.Xaml.Controls.TextChangedEventHandler) => void;

    }

    export class TextChangedEventArgs implements Windows.UI.Xaml.Controls.ITextChangedEventArgs {
    }

    export interface TextChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ToggleSwitch implements Windows.UI.Xaml.Controls.IToggleSwitch, Windows.UI.Xaml.Controls.IToggleSwitchOverrides {
        constructor();
        add_Toggled(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Toggled(token: Windows.Foundation.EventRegistrationToken): void;
        onToggled(): void;
        onOnContentChanged(oldContent: any, newContent: any): void;
        onOffContentChanged(oldContent: any, newContent: any): void;
        onHeaderChanged(oldContent: any, newContent: any): void;
        header: any;
        headerTemplate: Windows.UI.Xaml.DataTemplate;
        isOn: boolean;
        offContent: any;
        offContentTemplate: Windows.UI.Xaml.DataTemplate;
        onContent: any;
        onContentTemplate: Windows.UI.Xaml.DataTemplate;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ToggleSwitchTemplateSettings;
        static headerProperty: Windows.UI.Xaml.DependencyProperty;
        static headerTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static isOnProperty: Windows.UI.Xaml.DependencyProperty;
        static offContentProperty: Windows.UI.Xaml.DependencyProperty;
        static offContentTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        static onContentProperty: Windows.UI.Xaml.DependencyProperty;
        static onContentTemplateProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "toggled", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "toggled", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        ontoggled: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class ToolTip implements Windows.UI.Xaml.Controls.IToolTip {
        constructor();
        add_Closed(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        add_Opened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        horizontalOffset: number;
        isOpen: boolean;
        placement: Windows.UI.Xaml.Controls.Primitives.PlacementMode;
        placementTarget: Windows.UI.Xaml.UIElement;
        templateSettings: Windows.UI.Xaml.Controls.Primitives.ToolTipTemplateSettings;
        verticalOffset: number;
        static horizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static isOpenProperty: Windows.UI.Xaml.DependencyProperty;
        static placementProperty: Windows.UI.Xaml.DependencyProperty;
        static placementTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "closed", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onclosed: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "opened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "opened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class ToolTipService implements Windows.UI.Xaml.Controls.IToolTipService {
        static getPlacement(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.Primitives.PlacementMode;
        static setPlacement(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.Controls.Primitives.PlacementMode): void;
        static getPlacementTarget(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.UIElement;
        static setPlacementTarget(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.UIElement): void;
        static getToolTip(element: Windows.UI.Xaml.DependencyObject): any;
        static setToolTip(element: Windows.UI.Xaml.DependencyObject, value: any): void;
        static placementProperty: Windows.UI.Xaml.DependencyProperty;
        static placementTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static toolTipProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class UIElementCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.UIElement>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.UIElement> {
        getAt(index: number): Windows.UI.Xaml.UIElement;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.UIElement>;
        indexOf(value: Windows.UI.Xaml.UIElement): UIElementCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.UIElement): void;
        insertAt(index: number, value: Windows.UI.Xaml.UIElement): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.UIElement): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): UIElementCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.UIElement[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.UIElement>;
        size: number;
    }

    interface UIElementCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface UIElementCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.UIElement[];
    }

    export class UserControl implements Windows.UI.Xaml.Controls.IUserControl {
        constructor();
        content: Windows.UI.Xaml.UIElement;
        static contentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class VariableSizedWrapGrid implements Windows.UI.Xaml.Controls.IVariableSizedWrapGrid {
        constructor();
        static getRowSpan(element: Windows.UI.Xaml.UIElement): number;
        static setRowSpan(element: Windows.UI.Xaml.UIElement, value: number): void;
        static getColumnSpan(element: Windows.UI.Xaml.UIElement): number;
        static setColumnSpan(element: Windows.UI.Xaml.UIElement, value: number): void;
        horizontalChildrenAlignment: Windows.UI.Xaml.HorizontalAlignment;
        itemHeight: number;
        itemWidth: number;
        maximumRowsOrColumns: number;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        verticalChildrenAlignment: Windows.UI.Xaml.VerticalAlignment;
        static columnSpanProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalChildrenAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static itemHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static itemWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static maximumRowsOrColumnsProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        static rowSpanProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalChildrenAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Viewbox implements Windows.UI.Xaml.Controls.IViewbox {
        constructor();
        child: Windows.UI.Xaml.UIElement;
        stretch: Windows.UI.Xaml.Media.Stretch;
        stretchDirection: Windows.UI.Xaml.Controls.StretchDirection;
        static stretchDirectionProperty: Windows.UI.Xaml.DependencyProperty;
        static stretchProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum VirtualizationMode {
        standard,
        recycling
    }

    export class VirtualizingPanel implements Windows.UI.Xaml.Controls.IVirtualizingPanel, Windows.UI.Xaml.Controls.IVirtualizingPanelOverrides, Windows.UI.Xaml.Controls.IVirtualizingPanelProtected {
        onItemsChanged(sender: any, args: Windows.UI.Xaml.Controls.Primitives.ItemsChangedEventArgs): void;
        onClearChildren(): void;
        bringIndexIntoView(index: number): void;
        addInternalChild(child: Windows.UI.Xaml.UIElement): void;
        insertInternalChild(index: number, child: Windows.UI.Xaml.UIElement): void;
        removeInternalChildRange(index: number, range: number): void;
        itemContainerGenerator: Windows.UI.Xaml.Controls.ItemContainerGenerator;
    }

    export class VirtualizingStackPanel implements Windows.UI.Xaml.Controls.IVirtualizingStackPanel, Windows.UI.Xaml.Controls.IVirtualizingStackPanelOverrides {
        constructor();
        add_CleanUpVirtualizedItemEvent(value: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CleanUpVirtualizedItemEvent(token: Windows.Foundation.EventRegistrationToken): void;
        onCleanUpVirtualizedItem(e: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventArgs): void;
        static getVirtualizationMode(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.Controls.VirtualizationMode;
        static setVirtualizationMode(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.Controls.VirtualizationMode): void;
        static getIsVirtualizing(o: Windows.UI.Xaml.DependencyObject): boolean;
        areScrollSnapPointsRegular: boolean;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        static areScrollSnapPointsRegularProperty: Windows.UI.Xaml.DependencyProperty;
        static isVirtualizingProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        static virtualizationModeProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "cleanupvirtualizeditemevent", listener: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): void;
        removeEventListener(eventName: "cleanupvirtualizeditemevent", listener: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler): void;
        oncleanupvirtualizeditemevent: (ev: Windows.UI.Xaml.Controls.CleanUpVirtualizedItemEventHandler) => void;

    }

    export class WebView implements Windows.UI.Xaml.Controls.IWebView {
        constructor();
        add_LoadCompleted(value: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_LoadCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        add_ScriptNotify(value: Windows.UI.Xaml.Controls.NotifyEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ScriptNotify(token: Windows.Foundation.EventRegistrationToken): void;
        add_NavigationFailed(value: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_NavigationFailed(token: Windows.Foundation.EventRegistrationToken): void;
        invokeScript(scriptName: string, arguments: string[]): string;
        navigate(source: Windows.Foundation.Uri): void;
        navigateToString(text: string): void;
        allowedScriptNotifyUris: Windows.Foundation.Collections.IVector<Windows.Foundation.Uri>;
        dataTransferPackage: Windows.ApplicationModel.DataTransfer.DataPackage;
        source: Windows.Foundation.Uri;
        static allowedScriptNotifyUrisProperty: Windows.UI.Xaml.DependencyProperty;
        static anyScriptNotifyUri: Windows.Foundation.Collections.IVector<Windows.Foundation.Uri>;
        static dataTransferPackageProperty: Windows.UI.Xaml.DependencyProperty;
        static sourceProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "loadcompleted", listener: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): void;
        removeEventListener(eventName: "loadcompleted", listener: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler): void;
        onloadcompleted: (ev: Windows.UI.Xaml.Navigation.LoadCompletedEventHandler) => void;
        addEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): void;
        removeEventListener(eventName: "navigationfailed", listener: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler): void;
        onnavigationfailed: (ev: Windows.UI.Xaml.Controls.WebViewNavigationFailedEventHandler) => void;
        addEventListener(eventName: "scriptnotify", listener: Windows.UI.Xaml.Controls.NotifyEventHandler): void;
        removeEventListener(eventName: "scriptnotify", listener: Windows.UI.Xaml.Controls.NotifyEventHandler): void;
        onscriptnotify: (ev: Windows.UI.Xaml.Controls.NotifyEventHandler) => void;

    }

    export class WebViewBrush implements Windows.UI.Xaml.Controls.IWebViewBrush {
        constructor();
        redraw(): void;
        setSource(source: Windows.UI.Xaml.Controls.WebView): void;
        sourceName: string;
        static sourceNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class WebViewNavigationFailedEventArgs implements Windows.UI.Xaml.Controls.IWebViewNavigationFailedEventArgs {
        uri: Windows.Foundation.Uri;
        webErrorStatus: Windows.Web.WebErrorStatus;
    }

    export interface WebViewNavigationFailedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class WrapGrid implements Windows.UI.Xaml.Controls.IWrapGrid {
        constructor();
        horizontalChildrenAlignment: Windows.UI.Xaml.HorizontalAlignment;
        itemHeight: number;
        itemWidth: number;
        maximumRowsOrColumns: number;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        verticalChildrenAlignment: Windows.UI.Xaml.VerticalAlignment;
        static horizontalChildrenAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static itemHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static itemWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static maximumRowsOrColumnsProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalChildrenAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum ZoomMode {
        disabled,
        enabled
    }

}
declare module Windows.UI.Xaml.Controls.Primitives {

    enum AnimationDirection {
        left,
        top,
        right,
        bottom
    }

    export class ButtonBase implements Windows.UI.Xaml.Controls.Primitives.IButtonBase {
        constructor();
        add_Click(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Click(token: Windows.Foundation.EventRegistrationToken): void;
        clickMode: Windows.UI.Xaml.Controls.ClickMode;
        command: Windows.UI.Xaml.Input.ICommand;
        commandParameter: any;
        isPointerOver: boolean;
        isPressed: boolean;
        static clickModeProperty: Windows.UI.Xaml.DependencyProperty;
        static commandParameterProperty: Windows.UI.Xaml.DependencyProperty;
        static commandProperty: Windows.UI.Xaml.DependencyProperty;
        static isPointerOverProperty: Windows.UI.Xaml.DependencyProperty;
        static isPressedProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "click", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "click", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onclick: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class CarouselPanel implements Windows.UI.Xaml.Controls.Primitives.ICarouselPanel, Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo {
        constructor();
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        add_HorizontalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_HorizontalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VerticalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VerticalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getIrregularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): Windows.Foundation.Collections.IVectorView<number>;
        getRegularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): CarouselPanel_getRegularSnapPoints_OUT;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
        areHorizontalSnapPointsRegular: boolean;
        areVerticalSnapPointsRegular: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onhorizontalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onverticalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    interface CarouselPanel_getRegularSnapPoints_OUT {
        __returnValue: number;
        offset: number;
    }

    export class ComboBoxTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IComboBoxTemplateSettings {
        dropDownClosedHeight: number;
        dropDownOffset: number;
        dropDownOpenedHeight: number;
        selectedItemDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
    }

    enum ComponentResourceLocation {
        application,
        nested
    }

    export class DragCompletedEventArgs implements Windows.UI.Xaml.Controls.Primitives.IDragCompletedEventArgs {
        constructor(horizontalChange: number, verticalChange: number, canceled: boolean);
        canceled: boolean;
        horizontalChange: number;
        verticalChange: number;
    }

    export interface DragCompletedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class DragDeltaEventArgs implements Windows.UI.Xaml.Controls.Primitives.IDragDeltaEventArgs {
        constructor(horizontalChange: number, verticalChange: number);
        horizontalChange: number;
        verticalChange: number;
    }

    export interface DragDeltaEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class DragStartedEventArgs implements Windows.UI.Xaml.Controls.Primitives.IDragStartedEventArgs {
        constructor(horizontalOffset: number, verticalOffset: number);
        horizontalOffset: number;
        verticalOffset: number;
    }

    export interface DragStartedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum EdgeTransitionLocation {
        left,
        top,
        right,
        bottom
    }

    enum GeneratorDirection {
        forward,
        backward
    }

    export class GeneratorPosition {
        index: number;
        offset: number;
    }

    export class GeneratorPositionHelper implements Windows.UI.Xaml.Controls.Primitives.IGeneratorPositionHelper {
        static fromIndexAndOffset(index: number, offset: number): Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
    }

    export class GridViewItemTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IGridViewItemTemplateSettings {
        dragItemsCount: number;
    }

    export interface IButtonBase {
        add_Click(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Click(token: Windows.Foundation.EventRegistrationToken): void;
        clickMode: Windows.UI.Xaml.Controls.ClickMode;
        command: Windows.UI.Xaml.Input.ICommand;
        commandParameter: any;
        isPointerOver: boolean;
        isPressed: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "click", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "click", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onclick: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface ICarouselPanel {
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
    }

    export interface IComboBoxTemplateSettings {
        dropDownClosedHeight: number;
        dropDownOffset: number;
        dropDownOpenedHeight: number;
        selectedItemDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
    }

    export interface IDragCompletedEventArgs {
        canceled: boolean;
        horizontalChange: number;
        verticalChange: number;
    }

    export interface IDragDeltaEventArgs {
        horizontalChange: number;
        verticalChange: number;
    }

    export interface IDragStartedEventArgs {
        horizontalOffset: number;
        verticalOffset: number;
    }

    export interface IGeneratorPositionHelper {
    }

    export interface IGridViewItemTemplateSettings {
        dragItemsCount: number;
    }

    export interface IItemsChangedEventArgs {
        action: number;
        itemCount: number;
        itemUICount: number;
        oldPosition: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
        position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
    }

    export interface ILayoutInformation {
    }

    export interface IListViewItemTemplateSettings {
        dragItemsCount: number;
    }

    export interface IOrientedVirtualizingPanel {
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
    }

    export interface IPopup {
        add_Opened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        child: Windows.UI.Xaml.UIElement;
        childTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        horizontalOffset: number;
        isLightDismissEnabled: boolean;
        isOpen: boolean;
        verticalOffset: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        onclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        onopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface IProgressBarTemplateSettings {
        containerAnimationEndPosition: number;
        containerAnimationStartPosition: number;
        ellipseAnimationEndPosition: number;
        ellipseAnimationWellPosition: number;
        ellipseDiameter: number;
        ellipseOffset: number;
        indicatorLengthDelta: number;
    }

    export interface IProgressRingTemplateSettings {
        ellipseDiameter: number;
        ellipseOffset: Windows.UI.Xaml.Thickness;
        maxSideLength: number;
    }

    export interface IRangeBase {
        add_ValueChanged(value: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ValueChanged(token: Windows.Foundation.EventRegistrationToken): void;
        largeChange: number;
        maximum: number;
        minimum: number;
        smallChange: number;
        value: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "valuechanged", listener: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): void;
        removeEventListener(eventName: "valuechanged", listener: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): void;
        onvaluechanged: (ev: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler) => void;

    }

    export interface IRangeBaseOverrides {
        onMinimumChanged(oldMinimum: number, newMinimum: number): void;
        onMaximumChanged(oldMaximum: number, newMaximum: number): void;
        onValueChanged(oldValue: number, newValue: number): void;
    }

    export interface IRangeBaseValueChangedEventArgs {
        newValue: number;
        oldValue: number;
    }

    export interface IRepeatButton {
        delay: number;
        interval: number;
    }

    export interface IScrollBar {
        add_Scroll(value: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Scroll(token: Windows.Foundation.EventRegistrationToken): void;
        indicatorMode: Windows.UI.Xaml.Controls.Primitives.ScrollingIndicatorMode;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        viewportSize: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "scroll", listener: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): void;
        removeEventListener(eventName: "scroll", listener: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): void;
        onscroll: (ev: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler) => void;

    }

    export interface IScrollEventArgs {
        newValue: number;
        scrollEventType: Windows.UI.Xaml.Controls.Primitives.ScrollEventType;
    }

    export interface IScrollSnapPointsInfo {
        add_HorizontalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_HorizontalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VerticalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VerticalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getIrregularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): Windows.Foundation.Collections.IVectorView<number>;
        getRegularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): IScrollSnapPointsInfo_getRegularSnapPoints_OUT;
        areHorizontalSnapPointsRegular: boolean;
        areVerticalSnapPointsRegular: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onhorizontalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onverticalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    interface IScrollSnapPointsInfo_getRegularSnapPoints_OUT {
        __returnValue: number;
        offset: number;
    }

    export interface ISelector {
        add_SelectionChanged(value: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        isSynchronizedWithCurrentItem: Windows.Foundation.IReference<boolean>;
        selectedIndex: number;
        selectedItem: any;
        selectedValue: any;
        selectedValuePath: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.Controls.SelectionChangedEventHandler) => void;

    }

    export interface ISelectorItem {
        isSelected: boolean;
    }

    export class ItemsChangedEventArgs implements Windows.UI.Xaml.Controls.Primitives.IItemsChangedEventArgs {
        action: number;
        itemCount: number;
        itemUICount: number;
        oldPosition: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
        position: Windows.UI.Xaml.Controls.Primitives.GeneratorPosition;
    }

    export interface ItemsChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IThumb {
        add_DragStarted(value: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragDelta(value: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragDelta(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragCompleted(value: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        cancelDrag(): void;
        isDragging: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dragcompleted", listener: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): void;
        removeEventListener(eventName: "dragcompleted", listener: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): void;
        ondragcompleted: (ev: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler) => void;
        addEventListener(eventName: "dragdelta", listener: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): void;
        removeEventListener(eventName: "dragdelta", listener: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): void;
        ondragdelta: (ev: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler) => void;
        addEventListener(eventName: "dragstarted", listener: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): void;
        removeEventListener(eventName: "dragstarted", listener: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): void;
        ondragstarted: (ev: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler) => void;

    }

    export interface ITickBar {
        fill: Windows.UI.Xaml.Media.Brush;
    }

    export interface IToggleButton {
        add_Checked(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Checked(token: Windows.Foundation.EventRegistrationToken): void;
        add_Unchecked(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Unchecked(token: Windows.Foundation.EventRegistrationToken): void;
        add_Indeterminate(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Indeterminate(token: Windows.Foundation.EventRegistrationToken): void;
        isChecked: Windows.Foundation.IReference<boolean>;
        isThreeState: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "checked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "checked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onchecked: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "indeterminate", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "indeterminate", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onindeterminate: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "unchecked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "unchecked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onunchecked: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IToggleButtonOverrides {
        onToggle(): void;
    }

    export interface IToggleSwitchTemplateSettings {
        curtainCurrentToOffOffset: number;
        curtainCurrentToOnOffset: number;
        curtainOffToOnOffset: number;
        curtainOnToOffOffset: number;
        knobCurrentToOffOffset: number;
        knobCurrentToOnOffset: number;
        knobOffToOnOffset: number;
        knobOnToOffOffset: number;
    }

    export interface IToolTipTemplateSettings {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
    }

    export class LayoutInformation implements Windows.UI.Xaml.Controls.Primitives.ILayoutInformation {
        static getLayoutExceptionElement(dispatcher: any): Windows.UI.Xaml.UIElement;
        static getLayoutSlot(element: Windows.UI.Xaml.FrameworkElement): Windows.Foundation.Rect;
    }

    export class ListViewItemTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IListViewItemTemplateSettings {
        dragItemsCount: number;
    }

    export class OrientedVirtualizingPanel implements Windows.UI.Xaml.Controls.Primitives.IOrientedVirtualizingPanel, Windows.UI.Xaml.Controls.Primitives.IScrollSnapPointsInfo {
        lineUp(): void;
        lineDown(): void;
        lineLeft(): void;
        lineRight(): void;
        pageUp(): void;
        pageDown(): void;
        pageLeft(): void;
        pageRight(): void;
        mouseWheelUp(): void;
        mouseWheelDown(): void;
        mouseWheelLeft(): void;
        mouseWheelRight(): void;
        setHorizontalOffset(offset: number): void;
        setVerticalOffset(offset: number): void;
        makeVisible(visual: Windows.UI.Xaml.UIElement, rectangle: Windows.Foundation.Rect): Windows.Foundation.Rect;
        add_HorizontalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_HorizontalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_VerticalSnapPointsChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_VerticalSnapPointsChanged(token: Windows.Foundation.EventRegistrationToken): void;
        getIrregularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): Windows.Foundation.Collections.IVectorView<number>;
        getRegularSnapPoints(orientation: Windows.UI.Xaml.Controls.Orientation, alignment: Windows.UI.Xaml.Controls.Primitives.SnapPointsAlignment): OrientedVirtualizingPanel_getRegularSnapPoints_OUT;
        canHorizontallyScroll: boolean;
        canVerticallyScroll: boolean;
        extentHeight: number;
        extentWidth: number;
        horizontalOffset: number;
        scrollOwner: any;
        verticalOffset: number;
        viewportHeight: number;
        viewportWidth: number;
        areHorizontalSnapPointsRegular: boolean;
        areVerticalSnapPointsRegular: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "horizontalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onhorizontalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "verticalsnappointschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onverticalsnappointschanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    interface OrientedVirtualizingPanel_getRegularSnapPoints_OUT {
        __returnValue: number;
        offset: number;
    }

    enum PlacementMode {
        bottom,
        right,
        mouse,
        left,
        top
    }

    export class Popup implements Windows.UI.Xaml.Controls.Primitives.IPopup {
        constructor();
        add_Opened(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Opened(token: Windows.Foundation.EventRegistrationToken): void;
        add_Closed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Closed(token: Windows.Foundation.EventRegistrationToken): void;
        child: Windows.UI.Xaml.UIElement;
        childTransitions: Windows.UI.Xaml.Media.Animation.TransitionCollection;
        horizontalOffset: number;
        isLightDismissEnabled: boolean;
        isOpen: boolean;
        verticalOffset: number;
        static childProperty: Windows.UI.Xaml.DependencyProperty;
        static childTransitionsProperty: Windows.UI.Xaml.DependencyProperty;
        static horizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static isLightDismissEnabledProperty: Windows.UI.Xaml.DependencyProperty;
        static isOpenProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.EventHandler<any>): void;
        onclosed: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "opened", listener: Windows.Foundation.EventHandler<any>): void;
        onopened: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class ProgressBarTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IProgressBarTemplateSettings {
        containerAnimationEndPosition: number;
        containerAnimationStartPosition: number;
        ellipseAnimationEndPosition: number;
        ellipseAnimationWellPosition: number;
        ellipseDiameter: number;
        ellipseOffset: number;
        indicatorLengthDelta: number;
    }

    export class ProgressRingTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IProgressRingTemplateSettings {
        ellipseDiameter: number;
        ellipseOffset: Windows.UI.Xaml.Thickness;
        maxSideLength: number;
    }

    export class RangeBase implements Windows.UI.Xaml.Controls.Primitives.IRangeBase, Windows.UI.Xaml.Controls.Primitives.IRangeBaseOverrides {
        constructor();
        add_ValueChanged(value: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ValueChanged(token: Windows.Foundation.EventRegistrationToken): void;
        onMinimumChanged(oldMinimum: number, newMinimum: number): void;
        onMaximumChanged(oldMaximum: number, newMaximum: number): void;
        onValueChanged(oldValue: number, newValue: number): void;
        largeChange: number;
        maximum: number;
        minimum: number;
        smallChange: number;
        value: number;
        static largeChangeProperty: Windows.UI.Xaml.DependencyProperty;
        static maximumProperty: Windows.UI.Xaml.DependencyProperty;
        static minimumProperty: Windows.UI.Xaml.DependencyProperty;
        static smallChangeProperty: Windows.UI.Xaml.DependencyProperty;
        static valueProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "valuechanged", listener: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): void;
        removeEventListener(eventName: "valuechanged", listener: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler): void;
        onvaluechanged: (ev: Windows.UI.Xaml.Controls.Primitives.RangeBaseValueChangedEventHandler) => void;

    }

    export class RangeBaseValueChangedEventArgs implements Windows.UI.Xaml.Controls.Primitives.IRangeBaseValueChangedEventArgs {
        newValue: number;
        oldValue: number;
    }

    export interface RangeBaseValueChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class RepeatButton implements Windows.UI.Xaml.Controls.Primitives.IRepeatButton {
        constructor();
        delay: number;
        interval: number;
        static delayProperty: Windows.UI.Xaml.DependencyProperty;
        static intervalProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ScrollBar implements Windows.UI.Xaml.Controls.Primitives.IScrollBar {
        constructor();
        add_Scroll(value: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Scroll(token: Windows.Foundation.EventRegistrationToken): void;
        indicatorMode: Windows.UI.Xaml.Controls.Primitives.ScrollingIndicatorMode;
        orientation: Windows.UI.Xaml.Controls.Orientation;
        viewportSize: number;
        static indicatorModeProperty: Windows.UI.Xaml.DependencyProperty;
        static orientationProperty: Windows.UI.Xaml.DependencyProperty;
        static viewportSizeProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "scroll", listener: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): void;
        removeEventListener(eventName: "scroll", listener: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler): void;
        onscroll: (ev: Windows.UI.Xaml.Controls.Primitives.ScrollEventHandler) => void;

    }

    export class ScrollEventArgs implements Windows.UI.Xaml.Controls.Primitives.IScrollEventArgs {
        constructor();
        newValue: number;
        scrollEventType: Windows.UI.Xaml.Controls.Primitives.ScrollEventType;
    }

    export interface ScrollEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum ScrollEventType {
        smallDecrement,
        smallIncrement,
        largeDecrement,
        largeIncrement,
        thumbPosition,
        thumbTrack,
        first,
        last,
        endScroll
    }

    enum ScrollingIndicatorMode {
        none,
        touchIndicator,
        mouseIndicator
    }

    export class Selector implements Windows.UI.Xaml.Controls.Primitives.ISelector {
        add_SelectionChanged(value: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_SelectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getIsSelectionActive(element: Windows.UI.Xaml.DependencyObject): boolean;
        isSynchronizedWithCurrentItem: Windows.Foundation.IReference<boolean>;
        selectedIndex: number;
        selectedItem: any;
        selectedValue: any;
        selectedValuePath: string;
        static isSynchronizedWithCurrentItemProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedIndexProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedItemProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedValuePathProperty: Windows.UI.Xaml.DependencyProperty;
        static selectedValueProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): void;
        removeEventListener(eventName: "selectionchanged", listener: Windows.UI.Xaml.Controls.SelectionChangedEventHandler): void;
        onselectionchanged: (ev: Windows.UI.Xaml.Controls.SelectionChangedEventHandler) => void;

    }

    export class SelectorItem implements Windows.UI.Xaml.Controls.Primitives.ISelectorItem {
        constructor();
        isSelected: boolean;
        static isSelectedProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum SliderSnapsTo {
        stepValues,
        ticks
    }

    enum SnapPointsAlignment {
        near,
        center,
        far
    }

    export class Thumb implements Windows.UI.Xaml.Controls.Primitives.IThumb {
        constructor();
        add_DragStarted(value: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragStarted(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragDelta(value: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragDelta(token: Windows.Foundation.EventRegistrationToken): void;
        add_DragCompleted(value: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DragCompleted(token: Windows.Foundation.EventRegistrationToken): void;
        cancelDrag(): void;
        isDragging: boolean;
        static isDraggingProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "dragcompleted", listener: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): void;
        removeEventListener(eventName: "dragcompleted", listener: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler): void;
        ondragcompleted: (ev: Windows.UI.Xaml.Controls.Primitives.DragCompletedEventHandler) => void;
        addEventListener(eventName: "dragdelta", listener: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): void;
        removeEventListener(eventName: "dragdelta", listener: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler): void;
        ondragdelta: (ev: Windows.UI.Xaml.Controls.Primitives.DragDeltaEventHandler) => void;
        addEventListener(eventName: "dragstarted", listener: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): void;
        removeEventListener(eventName: "dragstarted", listener: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler): void;
        ondragstarted: (ev: Windows.UI.Xaml.Controls.Primitives.DragStartedEventHandler) => void;

    }

    export class TickBar implements Windows.UI.Xaml.Controls.Primitives.ITickBar {
        constructor();
        fill: Windows.UI.Xaml.Media.Brush;
        static fillProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum TickPlacement {
        none,
        topLeft,
        bottomRight,
        outside,
        inline
    }

    export class ToggleButton implements Windows.UI.Xaml.Controls.Primitives.IToggleButton, Windows.UI.Xaml.Controls.Primitives.IToggleButtonOverrides {
        constructor();
        add_Checked(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Checked(token: Windows.Foundation.EventRegistrationToken): void;
        add_Unchecked(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Unchecked(token: Windows.Foundation.EventRegistrationToken): void;
        add_Indeterminate(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Indeterminate(token: Windows.Foundation.EventRegistrationToken): void;
        onToggle(): void;
        isChecked: Windows.Foundation.IReference<boolean>;
        isThreeState: boolean;
        static isCheckedProperty: Windows.UI.Xaml.DependencyProperty;
        static isThreeStateProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "checked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "checked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onchecked: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "indeterminate", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "indeterminate", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onindeterminate: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;
        addEventListener(eventName: "unchecked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "unchecked", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onunchecked: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class ToggleSwitchTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IToggleSwitchTemplateSettings {
        curtainCurrentToOffOffset: number;
        curtainCurrentToOnOffset: number;
        curtainOffToOnOffset: number;
        curtainOnToOffOffset: number;
        knobCurrentToOffOffset: number;
        knobCurrentToOnOffset: number;
        knobOffToOnOffset: number;
        knobOnToOffOffset: number;
    }

    export class ToolTipTemplateSettings implements Windows.UI.Xaml.Controls.Primitives.IToolTipTemplateSettings {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
    }

}
declare module Windows.UI.Xaml.Data {

    export class BindableAttribute {
        constructor();
    }

    export class Binding implements Windows.UI.Xaml.Data.IBinding {
        constructor();
        converter: Windows.UI.Xaml.Data.IValueConverter;
        converterLanguage: string;
        converterParameter: any;
        elementName: string;
        mode: Windows.UI.Xaml.Data.BindingMode;
        path: Windows.UI.Xaml.PropertyPath;
        relativeSource: Windows.UI.Xaml.Data.RelativeSource;
        source: any;
    }

    export class BindingBase implements Windows.UI.Xaml.Data.IBindingBase {
        constructor();
    }

    enum BindingMode {
        oneWay,
        oneTime,
        twoWay
    }

    export class BindingOperations implements Windows.UI.Xaml.Data.IBindingOperations {
        static setBinding(target: Windows.UI.Xaml.DependencyObject, dp: Windows.UI.Xaml.DependencyProperty, binding: Windows.UI.Xaml.Data.BindingBase): void;
    }

    export class CollectionViewSource implements Windows.UI.Xaml.Data.ICollectionViewSource {
        constructor();
        isSourceGrouped: boolean;
        itemsPath: Windows.UI.Xaml.PropertyPath;
        source: any;
        view: Windows.UI.Xaml.Data.ICollectionView;
        static isSourceGroupedProperty: Windows.UI.Xaml.DependencyProperty;
        static itemsPathProperty: Windows.UI.Xaml.DependencyProperty;
        static sourceProperty: Windows.UI.Xaml.DependencyProperty;
        static viewProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CurrentChangingEventArgs implements Windows.UI.Xaml.Data.ICurrentChangingEventArgs {
        constructor();
        constructor(isCancelable: boolean);
        cancel: boolean;
        isCancelable: boolean;
    }

    export interface CurrentChangingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IBinding {
        converter: Windows.UI.Xaml.Data.IValueConverter;
        converterLanguage: string;
        converterParameter: any;
        elementName: string;
        mode: Windows.UI.Xaml.Data.BindingMode;
        path: Windows.UI.Xaml.PropertyPath;
        relativeSource: Windows.UI.Xaml.Data.RelativeSource;
        source: any;
    }

    export interface IBindingBase {
    }

    export interface IBindingOperations {
    }

    export interface ICollectionView extends Windows.Foundation.Collections.IObservableVector<any>, Windows.Foundation.Collections.IVector<any>, Windows.Foundation.Collections.IIterable<any> {
        add_CurrentChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_CurrentChanged(token: Windows.Foundation.EventRegistrationToken): void;
        add_CurrentChanging(value: Windows.UI.Xaml.Data.CurrentChangingEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CurrentChanging(token: Windows.Foundation.EventRegistrationToken): void;
        moveCurrentTo(item: any): boolean;
        moveCurrentToPosition(index: number): boolean;
        moveCurrentToFirst(): boolean;
        moveCurrentToLast(): boolean;
        moveCurrentToNext(): boolean;
        moveCurrentToPrevious(): boolean;
        loadMoreItemsAsync(count: number): Windows.Foundation.IAsyncOperation<Windows.UI.Xaml.Data.LoadMoreItemsResult>;
        collectionGroups: Windows.Foundation.Collections.IObservableVector<any>;
        currentItem: any;
        currentPosition: number;
        hasMoreItems: boolean;
        isCurrentAfterLast: boolean;
        isCurrentBeforeFirst: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "currentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "currentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        oncurrentchanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "currentchanging", listener: Windows.UI.Xaml.Data.CurrentChangingEventHandler): void;
        removeEventListener(eventName: "currentchanging", listener: Windows.UI.Xaml.Data.CurrentChangingEventHandler): void;
        oncurrentchanging: (ev: Windows.UI.Xaml.Data.CurrentChangingEventHandler) => void;

    }

    export interface ICollectionViewFactory {
        createView(): Windows.UI.Xaml.Data.ICollectionView;
    }

    export interface ICollectionViewGroup {
        group: any;
        groupItems: Windows.Foundation.Collections.IObservableVector<any>;
    }

    export interface ICollectionViewSource {
        isSourceGrouped: boolean;
        itemsPath: Windows.UI.Xaml.PropertyPath;
        source: any;
        view: Windows.UI.Xaml.Data.ICollectionView;
    }

    export interface ICurrentChangingEventArgs {
        cancel: boolean;
        isCancelable: boolean;
    }

    export interface ICustomProperty {
        getValue(target: any): any;
        setValue(target: any, value: any): void;
        getIndexedValue(target: any, index: any): any;
        setIndexedValue(target: any, value: any, index: any): void;
        canRead: boolean;
        canWrite: boolean;
        name: string;
        type: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface ICustomPropertyProvider {
        getCustomProperty(name: string): Windows.UI.Xaml.Data.ICustomProperty;
        getIndexedProperty(name: string, type: Windows.UI.Xaml.Interop.TypeName): Windows.UI.Xaml.Data.ICustomProperty;
        getStringRepresentation(): string;
        type: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface INotifyPropertyChanged {
        add_PropertyChanged(value: Windows.UI.Xaml.Data.PropertyChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_PropertyChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "propertychanged", listener: Windows.UI.Xaml.Data.PropertyChangedEventHandler): void;
        removeEventListener(eventName: "propertychanged", listener: Windows.UI.Xaml.Data.PropertyChangedEventHandler): void;
        onpropertychanged: (ev: Windows.UI.Xaml.Data.PropertyChangedEventHandler) => void;

    }

    export interface IPropertyChangedEventArgs {
        propertyName: string;
    }

    export interface IRelativeSource {
        mode: Windows.UI.Xaml.Data.RelativeSourceMode;
    }

    export interface ISupportIncrementalLoading {
        loadMoreItemsAsync(count: number): Windows.Foundation.IAsyncOperation<Windows.UI.Xaml.Data.LoadMoreItemsResult>;
        hasMoreItems: boolean;
    }

    export interface IValueConverter {
        convert(value: any, targetType: Windows.UI.Xaml.Interop.TypeName, parameter: any, language: string): any;
        convertBack(value: any, targetType: Windows.UI.Xaml.Interop.TypeName, parameter: any, language: string): any;
    }

    export class LoadMoreItemsResult {
        count: number;
    }

    export class PropertyChangedEventArgs implements Windows.UI.Xaml.Data.IPropertyChangedEventArgs {
        constructor(name: string);
        propertyName: string;
    }

    export interface PropertyChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class RelativeSource implements Windows.UI.Xaml.Data.IRelativeSource {
        constructor();
        mode: Windows.UI.Xaml.Data.RelativeSourceMode;
    }

    enum RelativeSourceMode {
        none,
        templatedParent,
        self
    }

}
declare module Windows.UI.Xaml.Documents {

    export class Block implements Windows.UI.Xaml.Documents.IBlock {
        constructor();
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        margin: Windows.UI.Xaml.Thickness;
        textAlignment: Windows.UI.Xaml.TextAlignment;
        static lineHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static lineStackingStrategyProperty: Windows.UI.Xaml.DependencyProperty;
        static marginProperty: Windows.UI.Xaml.DependencyProperty;
        static textAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class BlockCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Documents.Block>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Documents.Block> {
        getAt(index: number): Windows.UI.Xaml.Documents.Block;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Documents.Block>;
        indexOf(value: Windows.UI.Xaml.Documents.Block): BlockCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Documents.Block): void;
        insertAt(index: number, value: Windows.UI.Xaml.Documents.Block): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Documents.Block): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): BlockCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Documents.Block[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Documents.Block>;
        size: number;
    }

    interface BlockCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface BlockCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Documents.Block[];
    }

    export class Bold implements Windows.UI.Xaml.Documents.IBold {
        constructor();
    }

    export class Glyphs implements Windows.UI.Xaml.Documents.IGlyphs {
        constructor();
        fill: Windows.UI.Xaml.Media.Brush;
        fontRenderingEmSize: number;
        fontUri: Windows.Foundation.Uri;
        indices: string;
        originX: number;
        originY: number;
        styleSimulations: Windows.UI.Xaml.Media.StyleSimulations;
        unicodeString: string;
        static fillProperty: Windows.UI.Xaml.DependencyProperty;
        static fontRenderingEmSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontUriProperty: Windows.UI.Xaml.DependencyProperty;
        static indicesProperty: Windows.UI.Xaml.DependencyProperty;
        static originXProperty: Windows.UI.Xaml.DependencyProperty;
        static originYProperty: Windows.UI.Xaml.DependencyProperty;
        static styleSimulationsProperty: Windows.UI.Xaml.DependencyProperty;
        static unicodeStringProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export interface IBlock {
        lineHeight: number;
        lineStackingStrategy: Windows.UI.Xaml.LineStackingStrategy;
        margin: Windows.UI.Xaml.Thickness;
        textAlignment: Windows.UI.Xaml.TextAlignment;
    }

    export interface IBold {
    }

    export interface IGlyphs {
        fill: Windows.UI.Xaml.Media.Brush;
        fontRenderingEmSize: number;
        fontUri: Windows.Foundation.Uri;
        indices: string;
        originX: number;
        originY: number;
        styleSimulations: Windows.UI.Xaml.Media.StyleSimulations;
        unicodeString: string;
    }

    export interface IInline {
    }

    export interface IInlineUIContainer {
        child: Windows.UI.Xaml.UIElement;
    }

    export interface IItalic {
    }

    export interface ILineBreak {
    }

    export class Inline implements Windows.UI.Xaml.Documents.IInline {
        constructor();
    }

    export class InlineCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Documents.Inline>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Documents.Inline> {
        getAt(index: number): Windows.UI.Xaml.Documents.Inline;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Documents.Inline>;
        indexOf(value: Windows.UI.Xaml.Documents.Inline): InlineCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Documents.Inline): void;
        insertAt(index: number, value: Windows.UI.Xaml.Documents.Inline): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Documents.Inline): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): InlineCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Documents.Inline[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Documents.Inline>;
        size: number;
    }

    interface InlineCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface InlineCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Documents.Inline[];
    }

    export class InlineUIContainer implements Windows.UI.Xaml.Documents.IInlineUIContainer {
        constructor();
        child: Windows.UI.Xaml.UIElement;
    }

    export interface IParagraph {
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
        textIndent: number;
    }

    export interface IRun {
        flowDirection: Windows.UI.Xaml.FlowDirection;
        text: string;
    }

    export interface ISpan {
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
    }

    export class Italic implements Windows.UI.Xaml.Documents.IItalic {
        constructor();
    }

    export interface ITextElement {
        findName(name: string): any;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        elementEnd: Windows.UI.Xaml.Documents.TextPointer;
        elementStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        language: string;
        name: string;
    }

    export interface ITextElementOverrides {
        onDisconnectVisualChildren(): void;
    }

    export interface ITextPointer {
        getCharacterRect(direction: Windows.UI.Xaml.Documents.LogicalDirection): Windows.Foundation.Rect;
        getPositionAtOffset(offset: number, direction: Windows.UI.Xaml.Documents.LogicalDirection): Windows.UI.Xaml.Documents.TextPointer;
        logicalDirection: Windows.UI.Xaml.Documents.LogicalDirection;
        offset: number;
        parent: Windows.UI.Xaml.DependencyObject;
        visualParent: Windows.UI.Xaml.FrameworkElement;
    }

    export interface ITypography {
    }

    export interface IUnderline {
    }

    export class LineBreak implements Windows.UI.Xaml.Documents.ILineBreak {
        constructor();
    }

    enum LogicalDirection {
        backward,
        forward
    }

    export class Paragraph implements Windows.UI.Xaml.Documents.IParagraph {
        constructor();
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
        textIndent: number;
        static textIndentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Run implements Windows.UI.Xaml.Documents.IRun {
        constructor();
        flowDirection: Windows.UI.Xaml.FlowDirection;
        text: string;
        static flowDirectionProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Span implements Windows.UI.Xaml.Documents.ISpan {
        constructor();
        inlines: Windows.UI.Xaml.Documents.InlineCollection;
    }

    export class TextElement implements Windows.UI.Xaml.Documents.ITextElement, Windows.UI.Xaml.Documents.ITextElementOverrides {
        findName(name: string): any;
        onDisconnectVisualChildren(): void;
        characterSpacing: number;
        contentEnd: Windows.UI.Xaml.Documents.TextPointer;
        contentStart: Windows.UI.Xaml.Documents.TextPointer;
        elementEnd: Windows.UI.Xaml.Documents.TextPointer;
        elementStart: Windows.UI.Xaml.Documents.TextPointer;
        fontFamily: Windows.UI.Xaml.Media.FontFamily;
        fontSize: number;
        fontStretch: Windows.UI.Text.FontStretch;
        fontStyle: Windows.UI.Text.FontStyle;
        fontWeight: Windows.UI.Text.FontWeight;
        foreground: Windows.UI.Xaml.Media.Brush;
        language: string;
        name: string;
        static characterSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static fontFamilyProperty: Windows.UI.Xaml.DependencyProperty;
        static fontSizeProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStretchProperty: Windows.UI.Xaml.DependencyProperty;
        static fontStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static fontWeightProperty: Windows.UI.Xaml.DependencyProperty;
        static foregroundProperty: Windows.UI.Xaml.DependencyProperty;
        static languageProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class TextPointer implements Windows.UI.Xaml.Documents.ITextPointer {
        getCharacterRect(direction: Windows.UI.Xaml.Documents.LogicalDirection): Windows.Foundation.Rect;
        getPositionAtOffset(offset: number, direction: Windows.UI.Xaml.Documents.LogicalDirection): Windows.UI.Xaml.Documents.TextPointer;
        logicalDirection: Windows.UI.Xaml.Documents.LogicalDirection;
        offset: number;
        parent: Windows.UI.Xaml.DependencyObject;
        visualParent: Windows.UI.Xaml.FrameworkElement;
    }

    export class Typography implements Windows.UI.Xaml.Documents.ITypography {
        static getAnnotationAlternates(element: Windows.UI.Xaml.DependencyObject): number;
        static setAnnotationAlternates(element: Windows.UI.Xaml.DependencyObject, value: number): void;
        static getEastAsianExpertForms(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setEastAsianExpertForms(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getEastAsianLanguage(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontEastAsianLanguage;
        static setEastAsianLanguage(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontEastAsianLanguage): void;
        static getEastAsianWidths(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontEastAsianWidths;
        static setEastAsianWidths(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontEastAsianWidths): void;
        static getStandardLigatures(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStandardLigatures(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getContextualLigatures(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setContextualLigatures(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getDiscretionaryLigatures(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setDiscretionaryLigatures(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getHistoricalLigatures(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setHistoricalLigatures(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStandardSwashes(element: Windows.UI.Xaml.DependencyObject): number;
        static setStandardSwashes(element: Windows.UI.Xaml.DependencyObject, value: number): void;
        static getContextualSwashes(element: Windows.UI.Xaml.DependencyObject): number;
        static setContextualSwashes(element: Windows.UI.Xaml.DependencyObject, value: number): void;
        static getContextualAlternates(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setContextualAlternates(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticAlternates(element: Windows.UI.Xaml.DependencyObject): number;
        static setStylisticAlternates(element: Windows.UI.Xaml.DependencyObject, value: number): void;
        static getStylisticSet1(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet1(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet2(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet2(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet3(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet3(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet4(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet4(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet5(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet5(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet6(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet6(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet7(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet7(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet8(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet8(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet9(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet9(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet10(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet10(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet11(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet11(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet12(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet12(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet13(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet13(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet14(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet14(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet15(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet15(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet16(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet16(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet17(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet17(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet18(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet18(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet19(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet19(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getStylisticSet20(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setStylisticSet20(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getCapitals(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontCapitals;
        static setCapitals(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontCapitals): void;
        static getCapitalSpacing(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setCapitalSpacing(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getKerning(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setKerning(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getCaseSensitiveForms(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setCaseSensitiveForms(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getHistoricalForms(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setHistoricalForms(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getFraction(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontFraction;
        static setFraction(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontFraction): void;
        static getNumeralStyle(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontNumeralStyle;
        static setNumeralStyle(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontNumeralStyle): void;
        static getNumeralAlignment(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontNumeralAlignment;
        static setNumeralAlignment(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontNumeralAlignment): void;
        static getSlashedZero(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setSlashedZero(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getMathematicalGreek(element: Windows.UI.Xaml.DependencyObject): boolean;
        static setMathematicalGreek(element: Windows.UI.Xaml.DependencyObject, value: boolean): void;
        static getVariants(element: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.FontVariants;
        static setVariants(element: Windows.UI.Xaml.DependencyObject, value: Windows.UI.Xaml.FontVariants): void;
        static annotationAlternatesProperty: Windows.UI.Xaml.DependencyProperty;
        static capitalSpacingProperty: Windows.UI.Xaml.DependencyProperty;
        static capitalsProperty: Windows.UI.Xaml.DependencyProperty;
        static caseSensitiveFormsProperty: Windows.UI.Xaml.DependencyProperty;
        static contextualAlternatesProperty: Windows.UI.Xaml.DependencyProperty;
        static contextualLigaturesProperty: Windows.UI.Xaml.DependencyProperty;
        static contextualSwashesProperty: Windows.UI.Xaml.DependencyProperty;
        static discretionaryLigaturesProperty: Windows.UI.Xaml.DependencyProperty;
        static eastAsianExpertFormsProperty: Windows.UI.Xaml.DependencyProperty;
        static eastAsianLanguageProperty: Windows.UI.Xaml.DependencyProperty;
        static eastAsianWidthsProperty: Windows.UI.Xaml.DependencyProperty;
        static fractionProperty: Windows.UI.Xaml.DependencyProperty;
        static historicalFormsProperty: Windows.UI.Xaml.DependencyProperty;
        static historicalLigaturesProperty: Windows.UI.Xaml.DependencyProperty;
        static kerningProperty: Windows.UI.Xaml.DependencyProperty;
        static mathematicalGreekProperty: Windows.UI.Xaml.DependencyProperty;
        static numeralAlignmentProperty: Windows.UI.Xaml.DependencyProperty;
        static numeralStyleProperty: Windows.UI.Xaml.DependencyProperty;
        static slashedZeroProperty: Windows.UI.Xaml.DependencyProperty;
        static standardLigaturesProperty: Windows.UI.Xaml.DependencyProperty;
        static standardSwashesProperty: Windows.UI.Xaml.DependencyProperty;
        static stylisticAlternatesProperty: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet10Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet11Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet12Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet13Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet14Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet15Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet16Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet17Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet18Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet19Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet1Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet20Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet2Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet3Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet4Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet5Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet6Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet7Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet8Property: Windows.UI.Xaml.DependencyProperty;
        static stylisticSet9Property: Windows.UI.Xaml.DependencyProperty;
        static variantsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Underline implements Windows.UI.Xaml.Documents.IUnderline {
        constructor();
    }

}
declare module Windows.UI.Xaml.Hosting {

    export interface IXamlUIPresenter {
        setSize(width: number, height: number): void;
        render(): void;
        present(): void;
        rootElement: Windows.UI.Xaml.UIElement;
        themeKey: string;
        themeResourcesXaml: string;
    }

    export interface IXamlUIPresenterHost {
        resolveFileResource(path: string): string;
    }

    export class XamlUIPresenter implements Windows.UI.Xaml.Hosting.IXamlUIPresenter {
        setSize(width: number, height: number): void;
        render(): void;
        present(): void;
        static setHost(host: Windows.UI.Xaml.Hosting.IXamlUIPresenterHost): void;
        static notifyWindowSizeChanged(): void;
        rootElement: Windows.UI.Xaml.UIElement;
        themeKey: string;
        themeResourcesXaml: string;
        static completeTimelinesAutomatically: boolean;
    }

}
declare module Windows.UI.Xaml.Input {

    export interface DoubleTappedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class DoubleTappedRoutedEventArgs implements Windows.UI.Xaml.Input.IDoubleTappedRoutedEventArgs {
        constructor();
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export class FocusManager implements Windows.UI.Xaml.Input.IFocusManager {
        static getFocusedElement(): any;
    }

    export interface HoldingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class HoldingRoutedEventArgs implements Windows.UI.Xaml.Input.IHoldingRoutedEventArgs {
        constructor();
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export interface ICommand {
        add_CanExecuteChanged(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_CanExecuteChanged(token: Windows.Foundation.EventRegistrationToken): void;
        canExecute(parameter: any): boolean;
        execute(parameter: any): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "canexecutechanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "canexecutechanged", listener: Windows.Foundation.EventHandler<any>): void;
        oncanexecutechanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface IDoubleTappedRoutedEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export interface IFocusManager {
    }

    export interface IHoldingRoutedEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        holdingState: Windows.UI.Input.HoldingState;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export interface IInertiaExpansionBehavior {
        desiredDeceleration: number;
        desiredExpansion: number;
    }

    export interface IInertiaRotationBehavior {
        desiredDeceleration: number;
        desiredRotation: number;
    }

    export interface IInertiaTranslationBehavior {
        desiredDeceleration: number;
        desiredDisplacement: number;
    }

    export interface IInputScope {
        names: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Input.InputScopeName>;
    }

    export interface IInputScopeName {
        nameValue: Windows.UI.Xaml.Input.InputScopeNameValue;
    }

    export interface IKeyRoutedEventArgs {
        handled: boolean;
        key: Windows.System.VirtualKey;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
    }

    export interface IManipulationCompletedRoutedEventArgs {
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        isInertial: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationDeltaRoutedEventArgs {
        complete(): void;
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        isInertial: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationInertiaStartingRoutedEventArgs {
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        expansionBehavior: Windows.UI.Xaml.Input.InertiaExpansionBehavior;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        rotationBehavior: Windows.UI.Xaml.Input.InertiaRotationBehavior;
        translationBehavior: Windows.UI.Xaml.Input.InertiaTranslationBehavior;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface IManipulationPivot {
        center: Windows.Foundation.Point;
        radius: number;
    }

    export interface IManipulationStartedRoutedEventArgs {
        complete(): void;
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface IManipulationStartingRoutedEventArgs {
        container: Windows.UI.Xaml.UIElement;
        handled: boolean;
        mode: Windows.UI.Xaml.Input.ManipulationModes;
        pivot: Windows.UI.Xaml.Input.ManipulationPivot;
    }

    export class InertiaExpansionBehavior implements Windows.UI.Xaml.Input.IInertiaExpansionBehavior {
        desiredDeceleration: number;
        desiredExpansion: number;
    }

    export class InertiaRotationBehavior implements Windows.UI.Xaml.Input.IInertiaRotationBehavior {
        desiredDeceleration: number;
        desiredRotation: number;
    }

    export class InertiaTranslationBehavior implements Windows.UI.Xaml.Input.IInertiaTranslationBehavior {
        desiredDeceleration: number;
        desiredDisplacement: number;
    }

    export class InputScope implements Windows.UI.Xaml.Input.IInputScope {
        constructor();
        names: Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Input.InputScopeName>;
    }

    export class InputScopeName implements Windows.UI.Xaml.Input.IInputScopeName {
        constructor();
        constructor(nameValue: Windows.UI.Xaml.Input.InputScopeNameValue);
        nameValue: Windows.UI.Xaml.Input.InputScopeNameValue;
    }

    enum InputScopeNameValue {
        default,
        url,
        emailSmtpAddress,
        number,
        telephoneNumber,
        numberFullWidth,
        alphanumericHalfWidth,
        alphanumericFullWidth,
        hiragana,
        katakanaHalfWidth,
        katakanaFullWidth,
        hanja,
        hangulHalfWidth,
        hangulFullWidth,
        search,
        chineseHalfWidth,
        chineseFullWidth,
        nativeScript
    }

    export interface IPointer {
        isInContact: boolean;
        isInRange: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        pointerId: number;
    }

    export interface IPointerRoutedEventArgs {
        getCurrentPoint(relativeTo: Windows.UI.Xaml.UIElement): Windows.UI.Input.PointerPoint;
        getIntermediatePoints(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        handled: boolean;
        keyModifiers: Windows.System.VirtualKeyModifiers;
        pointer: Windows.UI.Xaml.Input.Pointer;
    }

    export interface IRightTappedRoutedEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export interface ITappedRoutedEventArgs {
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    enum KeyboardNavigationMode {
        local,
        cycle,
        once
    }

    export interface KeyEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class KeyRoutedEventArgs implements Windows.UI.Xaml.Input.IKeyRoutedEventArgs {
        handled: boolean;
        key: Windows.System.VirtualKey;
        keyStatus: Windows.UI.Core.CorePhysicalKeyStatus;
    }

    export interface ManipulationCompletedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ManipulationCompletedRoutedEventArgs implements Windows.UI.Xaml.Input.IManipulationCompletedRoutedEventArgs {
        constructor();
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        isInertial: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface ManipulationDeltaEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ManipulationDeltaRoutedEventArgs implements Windows.UI.Xaml.Input.IManipulationDeltaRoutedEventArgs {
        constructor();
        complete(): void;
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        isInertial: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    export interface ManipulationInertiaStartingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ManipulationInertiaStartingRoutedEventArgs implements Windows.UI.Xaml.Input.IManipulationInertiaStartingRoutedEventArgs {
        constructor();
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        delta: Windows.UI.Input.ManipulationDelta;
        expansionBehavior: Windows.UI.Xaml.Input.InertiaExpansionBehavior;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        rotationBehavior: Windows.UI.Xaml.Input.InertiaRotationBehavior;
        translationBehavior: Windows.UI.Xaml.Input.InertiaTranslationBehavior;
        velocities: Windows.UI.Input.ManipulationVelocities;
    }

    enum ManipulationModes {
        none,
        translateX,
        translateY,
        translateRailsX,
        translateRailsY,
        rotate,
        scale,
        translateInertia,
        rotateInertia,
        scaleInertia,
        all,
        system
    }

    export class ManipulationPivot implements Windows.UI.Xaml.Input.IManipulationPivot {
        constructor();
        constructor(center: Windows.Foundation.Point, radius: number);
        center: Windows.Foundation.Point;
        radius: number;
    }

    export interface ManipulationStartedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ManipulationStartedRoutedEventArgs implements Windows.UI.Xaml.Input.IManipulationStartedRoutedEventArgs {
        constructor();
        complete(): void;
        container: Windows.UI.Xaml.UIElement;
        cumulative: Windows.UI.Input.ManipulationDelta;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        position: Windows.Foundation.Point;
    }

    export interface ManipulationStartingEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class ManipulationStartingRoutedEventArgs implements Windows.UI.Xaml.Input.IManipulationStartingRoutedEventArgs {
        constructor();
        container: Windows.UI.Xaml.UIElement;
        handled: boolean;
        mode: Windows.UI.Xaml.Input.ManipulationModes;
        pivot: Windows.UI.Xaml.Input.ManipulationPivot;
    }

    export class Pointer implements Windows.UI.Xaml.Input.IPointer {
        isInContact: boolean;
        isInRange: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
        pointerId: number;
    }

    export interface PointerEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class PointerRoutedEventArgs implements Windows.UI.Xaml.Input.IPointerRoutedEventArgs {
        getCurrentPoint(relativeTo: Windows.UI.Xaml.UIElement): Windows.UI.Input.PointerPoint;
        getIntermediatePoints(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Collections.IVector<Windows.UI.Input.PointerPoint>;
        handled: boolean;
        keyModifiers: Windows.System.VirtualKeyModifiers;
        pointer: Windows.UI.Xaml.Input.Pointer;
    }

    export interface RightTappedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class RightTappedRoutedEventArgs implements Windows.UI.Xaml.Input.IRightTappedRoutedEventArgs {
        constructor();
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

    export interface TappedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class TappedRoutedEventArgs implements Windows.UI.Xaml.Input.ITappedRoutedEventArgs {
        constructor();
        getPosition(relativeTo: Windows.UI.Xaml.UIElement): Windows.Foundation.Point;
        handled: boolean;
        pointerDeviceType: Windows.Devices.Input.PointerDeviceType;
    }

}
declare module Windows.UI.Xaml.Interop {

    export interface BindableVectorChangedEventHandler {
        target: Windows.UI.Xaml.Interop.IBindableObservableVector;
        detail: any[];
        type: string;
    }

    export interface IBindableIterable {
        first(): Windows.UI.Xaml.Interop.IBindableIterator;
    }

    export interface IBindableIterator {
        moveNext(): boolean;
        current: any;
        hasCurrent: boolean;
    }

    export interface IBindableObservableVector extends Windows.UI.Xaml.Interop.IBindableVector, Windows.UI.Xaml.Interop.IBindableIterable {
        add_VectorChanged(value: Windows.UI.Xaml.Interop.BindableVectorChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_VectorChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "vectorchanged", listener: Windows.UI.Xaml.Interop.BindableVectorChangedEventHandler): void;
        removeEventListener(eventName: "vectorchanged", listener: Windows.UI.Xaml.Interop.BindableVectorChangedEventHandler): void;
        onvectorchanged: (ev: Windows.UI.Xaml.Interop.BindableVectorChangedEventHandler) => void;

    }

    export interface IBindableVector extends Windows.UI.Xaml.Interop.IBindableIterable {
        getAt(index: number): any;
        getView(): Windows.UI.Xaml.Interop.IBindableVectorView;
        indexOf(value: any): IBindableVector_indexOf_OUT;
        setAt(index: number, value: any): void;
        insertAt(index: number, value: any): void;
        removeAt(index: number): void;
        append(value: any): void;
        removeAtEnd(): void;
        clear(): void;
        size: number;
    }

    interface IBindableVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    export interface IBindableVectorView extends Windows.UI.Xaml.Interop.IBindableIterable {
        getAt(index: number): any;
        indexOf(value: any): IBindableVectorView_indexOf_OUT;
        size: number;
    }

    interface IBindableVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    export interface INotifyCollectionChanged {
        add_CollectionChanged(value: Windows.UI.Xaml.Interop.NotifyCollectionChangedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_CollectionChanged(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "collectionchanged", listener: Windows.UI.Xaml.Interop.NotifyCollectionChangedEventHandler): void;
        removeEventListener(eventName: "collectionchanged", listener: Windows.UI.Xaml.Interop.NotifyCollectionChangedEventHandler): void;
        oncollectionchanged: (ev: Windows.UI.Xaml.Interop.NotifyCollectionChangedEventHandler) => void;

    }

    export interface INotifyCollectionChangedEventArgs {
        action: Windows.UI.Xaml.Interop.NotifyCollectionChangedAction;
        newItems: Windows.UI.Xaml.Interop.IBindableVector;
        newStartingIndex: number;
        oldItems: Windows.UI.Xaml.Interop.IBindableVector;
        oldStartingIndex: number;
    }

    enum NotifyCollectionChangedAction {
        add,
        remove,
        replace,
        move,
        reset
    }

    export class NotifyCollectionChangedEventArgs implements Windows.UI.Xaml.Interop.INotifyCollectionChangedEventArgs {
        constructor(action: Windows.UI.Xaml.Interop.NotifyCollectionChangedAction, newItems: Windows.UI.Xaml.Interop.IBindableVector, oldItems: Windows.UI.Xaml.Interop.IBindableVector, newIndex: number, oldIndex: number);
        action: Windows.UI.Xaml.Interop.NotifyCollectionChangedAction;
        newItems: Windows.UI.Xaml.Interop.IBindableVector;
        newStartingIndex: number;
        oldItems: Windows.UI.Xaml.Interop.IBindableVector;
        oldStartingIndex: number;
    }

    export interface NotifyCollectionChangedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum TypeKind {
        primitive,
        metadata,
        custom
    }

    export class TypeName {
        name: string;
        kind: Windows.UI.Xaml.Interop.TypeKind;
    }

}
declare module Windows.UI.Xaml.Markup {

    export class ContentPropertyAttribute {
        constructor();
        name: string;
    }

    export interface IComponentConnector {
        connect(connectionId: number, target: any): void;
    }

    export interface IXamlMember {
        getValue(instance: any): any;
        setValue(instance: any, value: any): void;
        isAttachable: boolean;
        isDependencyProperty: boolean;
        isReadOnly: boolean;
        name: string;
        targetType: Windows.UI.Xaml.Markup.IXamlType;
        type: Windows.UI.Xaml.Markup.IXamlType;
    }

    export interface IXamlMetadataProvider {
        getXamlType(type: Windows.UI.Xaml.Interop.TypeName): Windows.UI.Xaml.Markup.IXamlType;
        getXamlType(fullName: string): Windows.UI.Xaml.Markup.IXamlType;
        getXmlnsDefinitions(): Windows.UI.Xaml.Markup.XmlnsDefinition[];
    }

    export interface IXamlReader {
    }

    export interface IXamlType {
        activateInstance(): any;
        createFromString(value: string): any;
        getMember(name: string): Windows.UI.Xaml.Markup.IXamlMember;
        addToVector(instance: any, value: any): void;
        addToMap(instance: any, key: any, value: any): void;
        runInitializer(): void;
        baseType: Windows.UI.Xaml.Markup.IXamlType;
        contentProperty: Windows.UI.Xaml.Markup.IXamlMember;
        fullName: string;
        isArray: boolean;
        isBindable: boolean;
        isCollection: boolean;
        isConstructible: boolean;
        isDictionary: boolean;
        isMarkupExtension: boolean;
        itemType: Windows.UI.Xaml.Markup.IXamlType;
        keyType: Windows.UI.Xaml.Markup.IXamlType;
        underlyingType: Windows.UI.Xaml.Interop.TypeName;
    }

    export class XamlReader implements Windows.UI.Xaml.Markup.IXamlReader {
        static load(xaml: string): any;
        static loadWithInitialTemplateValidation(xaml: string): any;
    }

    export class XmlnsDefinition {
        xmlNamespace: string;
        namespace: string;
    }

}
declare module Windows.UI.Xaml.Media {

    enum AlignmentX {
        left,
        center,
        right
    }

    enum AlignmentY {
        top,
        center,
        bottom
    }

    export class ArcSegment implements Windows.UI.Xaml.Media.IArcSegment {
        constructor();
        isLargeArc: boolean;
        point: Windows.Foundation.Point;
        rotationAngle: number;
        size: Windows.Foundation.Size;
        sweepDirection: Windows.UI.Xaml.Media.SweepDirection;
        static isLargeArcProperty: Windows.UI.Xaml.DependencyProperty;
        static pointProperty: Windows.UI.Xaml.DependencyProperty;
        static rotationAngleProperty: Windows.UI.Xaml.DependencyProperty;
        static sizeProperty: Windows.UI.Xaml.DependencyProperty;
        static sweepDirectionProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum AudioCategory {
        other,
        foregroundOnlyMedia,
        backgroundCapableMedia,
        communications,
        alerts,
        soundEffects,
        gameEffects,
        gameMedia
    }

    enum AudioDeviceType {
        console,
        multimedia,
        communications
    }

    export class BezierSegment implements Windows.UI.Xaml.Media.IBezierSegment {
        constructor();
        point1: Windows.Foundation.Point;
        point2: Windows.Foundation.Point;
        point3: Windows.Foundation.Point;
        static point1Property: Windows.UI.Xaml.DependencyProperty;
        static point2Property: Windows.UI.Xaml.DependencyProperty;
        static point3Property: Windows.UI.Xaml.DependencyProperty;
    }

    export class BitmapCache implements Windows.UI.Xaml.Media.IBitmapCache {
        constructor();
    }

    export class Brush implements Windows.UI.Xaml.Media.IBrush {
        constructor();
        opacity: number;
        relativeTransform: Windows.UI.Xaml.Media.Transform;
        transform: Windows.UI.Xaml.Media.Transform;
        static opacityProperty: Windows.UI.Xaml.DependencyProperty;
        static relativeTransformProperty: Windows.UI.Xaml.DependencyProperty;
        static transformProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum BrushMappingMode {
        absolute,
        relativeToBoundingBox
    }

    export class CacheMode implements Windows.UI.Xaml.Media.ICacheMode {
        constructor();
    }

    enum ColorInterpolationMode {
        scRgbLinearInterpolation,
        sRgbLinearInterpolation
    }

    export class CompositeTransform implements Windows.UI.Xaml.Media.ICompositeTransform {
        constructor();
        centerX: number;
        centerY: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        skewX: number;
        skewY: number;
        translateX: number;
        translateY: number;
        static centerXProperty: Windows.UI.Xaml.DependencyProperty;
        static centerYProperty: Windows.UI.Xaml.DependencyProperty;
        static rotationProperty: Windows.UI.Xaml.DependencyProperty;
        static scaleXProperty: Windows.UI.Xaml.DependencyProperty;
        static scaleYProperty: Windows.UI.Xaml.DependencyProperty;
        static skewXProperty: Windows.UI.Xaml.DependencyProperty;
        static skewYProperty: Windows.UI.Xaml.DependencyProperty;
        static translateXProperty: Windows.UI.Xaml.DependencyProperty;
        static translateYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CompositionTarget implements Windows.UI.Xaml.Media.ICompositionTarget {
        static add_Rendering(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_Rendering(token: Windows.Foundation.EventRegistrationToken): void;
        static add_SurfaceContentsLost(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_SurfaceContentsLost(token: Windows.Foundation.EventRegistrationToken): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "rendering", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "rendering", listener: Windows.Foundation.EventHandler<any>): void;
        onrendering: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "surfacecontentslost", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "surfacecontentslost", listener: Windows.Foundation.EventHandler<any>): void;
        onsurfacecontentslost: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class DoubleCollection implements Windows.Foundation.Collections.IVector<number>, Windows.Foundation.Collections.IIterable<number> {
        constructor();
        getAt(index: number): number;
        getView(): Windows.Foundation.Collections.IVectorView<number>;
        indexOf(value: number): DoubleCollection_indexOf_OUT;
        setAt(index: number, value: number): void;
        insertAt(index: number, value: number): void;
        removeAt(index: number): void;
        append(value: number): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): DoubleCollection_getMany_OUT;
        replaceAll(items: number[]): void;
        first(): Windows.Foundation.Collections.IIterator<number>;
        size: number;
    }

    interface DoubleCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface DoubleCollection_getMany_OUT {
        __returnValue: number;
        items: number[];
    }

    export class EllipseGeometry implements Windows.UI.Xaml.Media.IEllipseGeometry {
        constructor();
        center: Windows.Foundation.Point;
        radiusX: number;
        radiusY: number;
        static centerProperty: Windows.UI.Xaml.DependencyProperty;
        static radiusXProperty: Windows.UI.Xaml.DependencyProperty;
        static radiusYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum FillRule {
        evenOdd,
        nonzero
    }

    export class FontFamily implements Windows.UI.Xaml.Media.IFontFamily {
        constructor(familyName: string);
        source: string;
    }

    export class GeneralTransform implements Windows.UI.Xaml.Media.IGeneralTransform, Windows.UI.Xaml.Media.IGeneralTransformOverrides {
        constructor();
        transformPoint(point: Windows.Foundation.Point): Windows.Foundation.Point;
        tryTransform(inPoint: Windows.Foundation.Point): GeneralTransform_tryTransform_OUT;
        transformBounds(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        tryTransformCore(inPoint: Windows.Foundation.Point): GeneralTransform_tryTransformCore_OUT;
        transformBoundsCore(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        inverse: Windows.UI.Xaml.Media.GeneralTransform;
        inverseCore: Windows.UI.Xaml.Media.GeneralTransform;
    }

    interface GeneralTransform_tryTransform_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    interface GeneralTransform_tryTransformCore_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    export class Geometry implements Windows.UI.Xaml.Media.IGeometry {
        bounds: Windows.Foundation.Rect;
        transform: Windows.UI.Xaml.Media.Transform;
        static empty: Windows.UI.Xaml.Media.Geometry;
        static standardFlatteningTolerance: number;
        static transformProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class GeometryCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Geometry>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Geometry> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Geometry;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Geometry>;
        indexOf(value: Windows.UI.Xaml.Media.Geometry): GeometryCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Geometry): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Geometry): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Geometry): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): GeometryCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Geometry[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Geometry>;
        size: number;
    }

    interface GeometryCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface GeometryCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Geometry[];
    }

    export class GeometryGroup implements Windows.UI.Xaml.Media.IGeometryGroup {
        constructor();
        children: Windows.UI.Xaml.Media.GeometryCollection;
        fillRule: Windows.UI.Xaml.Media.FillRule;
        static childrenProperty: Windows.UI.Xaml.DependencyProperty;
        static fillRuleProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class GradientBrush implements Windows.UI.Xaml.Media.IGradientBrush {
        constructor();
        colorInterpolationMode: Windows.UI.Xaml.Media.ColorInterpolationMode;
        gradientStops: Windows.UI.Xaml.Media.GradientStopCollection;
        mappingMode: Windows.UI.Xaml.Media.BrushMappingMode;
        spreadMethod: Windows.UI.Xaml.Media.GradientSpreadMethod;
        static colorInterpolationModeProperty: Windows.UI.Xaml.DependencyProperty;
        static gradientStopsProperty: Windows.UI.Xaml.DependencyProperty;
        static mappingModeProperty: Windows.UI.Xaml.DependencyProperty;
        static spreadMethodProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum GradientSpreadMethod {
        pad,
        reflect,
        repeat
    }

    export class GradientStop implements Windows.UI.Xaml.Media.IGradientStop {
        constructor();
        color: Windows.UI.Color;
        offset: number;
        static colorProperty: Windows.UI.Xaml.DependencyProperty;
        static offsetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class GradientStopCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.GradientStop>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.GradientStop> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.GradientStop;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.GradientStop>;
        indexOf(value: Windows.UI.Xaml.Media.GradientStop): GradientStopCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.GradientStop): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.GradientStop): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.GradientStop): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): GradientStopCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.GradientStop[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.GradientStop>;
        size: number;
    }

    interface GradientStopCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface GradientStopCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.GradientStop[];
    }

    export interface IArcSegment {
        isLargeArc: boolean;
        point: Windows.Foundation.Point;
        rotationAngle: number;
        size: Windows.Foundation.Size;
        sweepDirection: Windows.UI.Xaml.Media.SweepDirection;
    }

    export interface IBezierSegment {
        point1: Windows.Foundation.Point;
        point2: Windows.Foundation.Point;
        point3: Windows.Foundation.Point;
    }

    export interface IBitmapCache {
    }

    export interface IBrush {
        opacity: number;
        relativeTransform: Windows.UI.Xaml.Media.Transform;
        transform: Windows.UI.Xaml.Media.Transform;
    }

    export interface ICacheMode {
    }

    export interface ICompositeTransform {
        centerX: number;
        centerY: number;
        rotation: number;
        scaleX: number;
        scaleY: number;
        skewX: number;
        skewY: number;
        translateX: number;
        translateY: number;
    }

    export interface ICompositionTarget {
    }

    export interface IEllipseGeometry {
        center: Windows.Foundation.Point;
        radiusX: number;
        radiusY: number;
    }

    export interface IFontFamily {
        source: string;
    }

    export interface IGeneralTransform {
        transformPoint(point: Windows.Foundation.Point): Windows.Foundation.Point;
        tryTransform(inPoint: Windows.Foundation.Point): IGeneralTransform_tryTransform_OUT;
        transformBounds(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        inverse: Windows.UI.Xaml.Media.GeneralTransform;
    }

    interface IGeneralTransform_tryTransform_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    export interface IGeneralTransformOverrides {
        tryTransformCore(inPoint: Windows.Foundation.Point): IGeneralTransformOverrides_tryTransformCore_OUT;
        transformBoundsCore(rect: Windows.Foundation.Rect): Windows.Foundation.Rect;
        inverseCore: Windows.UI.Xaml.Media.GeneralTransform;
    }

    interface IGeneralTransformOverrides_tryTransformCore_OUT {
        __returnValue: boolean;
        outPoint: Windows.Foundation.Point;
    }

    export interface IGeometry {
        bounds: Windows.Foundation.Rect;
        transform: Windows.UI.Xaml.Media.Transform;
    }

    export interface IGeometryGroup {
        children: Windows.UI.Xaml.Media.GeometryCollection;
        fillRule: Windows.UI.Xaml.Media.FillRule;
    }

    export interface IGradientBrush {
        colorInterpolationMode: Windows.UI.Xaml.Media.ColorInterpolationMode;
        gradientStops: Windows.UI.Xaml.Media.GradientStopCollection;
        mappingMode: Windows.UI.Xaml.Media.BrushMappingMode;
        spreadMethod: Windows.UI.Xaml.Media.GradientSpreadMethod;
    }

    export interface IGradientStop {
        color: Windows.UI.Color;
        offset: number;
    }

    export interface IImageBrush {
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        imageSource: Windows.UI.Xaml.Media.ImageSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IImageSource {
    }

    export interface ILinearGradientBrush {
        endPoint: Windows.Foundation.Point;
        startPoint: Windows.Foundation.Point;
    }

    export interface ILineGeometry {
        endPoint: Windows.Foundation.Point;
        startPoint: Windows.Foundation.Point;
    }

    export interface ILineSegment {
        point: Windows.Foundation.Point;
    }

    export class ImageBrush implements Windows.UI.Xaml.Media.IImageBrush {
        constructor();
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        imageSource: Windows.UI.Xaml.Media.ImageSource;
        static imageSourceProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class ImageSource implements Windows.UI.Xaml.Media.IImageSource {
    }

    export interface IMatrix3DProjection {
        projectionMatrix: Windows.UI.Xaml.Media.Media3D.Matrix3D;
    }

    export interface IMatrixHelper {
    }

    export interface IMatrixTransform {
        matrix: Windows.UI.Xaml.Media.Matrix;
    }

    export interface IPathFigure {
        isClosed: boolean;
        isFilled: boolean;
        segments: Windows.UI.Xaml.Media.PathSegmentCollection;
        startPoint: Windows.Foundation.Point;
    }

    export interface IPathGeometry {
        figures: Windows.UI.Xaml.Media.PathFigureCollection;
        fillRule: Windows.UI.Xaml.Media.FillRule;
    }

    export interface IPathSegment {
    }

    export interface IPlaneProjection {
        centerOfRotationX: number;
        centerOfRotationY: number;
        centerOfRotationZ: number;
        globalOffsetX: number;
        globalOffsetY: number;
        globalOffsetZ: number;
        localOffsetX: number;
        localOffsetY: number;
        localOffsetZ: number;
        projectionMatrix: Windows.UI.Xaml.Media.Media3D.Matrix3D;
        rotationX: number;
        rotationY: number;
        rotationZ: number;
    }

    export interface IPolyBezierSegment {
        points: Windows.UI.Xaml.Media.PointCollection;
    }

    export interface IPolyLineSegment {
        points: Windows.UI.Xaml.Media.PointCollection;
    }

    export interface IPolyQuadraticBezierSegment {
        points: Windows.UI.Xaml.Media.PointCollection;
    }

    export interface IProjection {
    }

    export interface IQuadraticBezierSegment {
        point1: Windows.Foundation.Point;
        point2: Windows.Foundation.Point;
    }

    export interface IRateChangedRoutedEventArgs {
    }

    export interface IRectangleGeometry {
        rect: Windows.Foundation.Rect;
    }

    export interface IRenderingEventArgs {
        renderingTime: Windows.Foundation.TimeSpan;
    }

    export interface IRotateTransform {
        angle: number;
        centerX: number;
        centerY: number;
    }

    export interface IScaleTransform {
        centerX: number;
        centerY: number;
        scaleX: number;
        scaleY: number;
    }

    export interface ISkewTransform {
        angleX: number;
        angleY: number;
        centerX: number;
        centerY: number;
    }

    export interface ISolidColorBrush {
        color: Windows.UI.Color;
    }

    export interface ITileBrush {
        alignmentX: Windows.UI.Xaml.Media.AlignmentX;
        alignmentY: Windows.UI.Xaml.Media.AlignmentY;
        stretch: Windows.UI.Xaml.Media.Stretch;
    }

    export interface ITimelineMarker {
        text: string;
        time: Windows.Foundation.TimeSpan;
        type: string;
    }

    export interface ITimelineMarkerRoutedEventArgs {
        marker: Windows.UI.Xaml.Media.TimelineMarker;
    }

    export interface ITransform {
    }

    export interface ITransformGroup {
        children: Windows.UI.Xaml.Media.TransformCollection;
        value: Windows.UI.Xaml.Media.Matrix;
    }

    export interface ITranslateTransform {
        x: number;
        y: number;
    }

    export interface IVisualTreeHelper {
    }

    export class LinearGradientBrush implements Windows.UI.Xaml.Media.ILinearGradientBrush {
        constructor();
        constructor(gradientStopCollection: Windows.UI.Xaml.Media.GradientStopCollection, angle: number);
        endPoint: Windows.Foundation.Point;
        startPoint: Windows.Foundation.Point;
        static endPointProperty: Windows.UI.Xaml.DependencyProperty;
        static startPointProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class LineGeometry implements Windows.UI.Xaml.Media.ILineGeometry {
        constructor();
        endPoint: Windows.Foundation.Point;
        startPoint: Windows.Foundation.Point;
        static endPointProperty: Windows.UI.Xaml.DependencyProperty;
        static startPointProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class LineSegment implements Windows.UI.Xaml.Media.ILineSegment {
        constructor();
        point: Windows.Foundation.Point;
        static pointProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Matrix {
        m11: number;
        m12: number;
        m21: number;
        m22: number;
        offsetX: number;
        offsetY: number;
    }

    export class Matrix3DProjection implements Windows.UI.Xaml.Media.IMatrix3DProjection {
        constructor();
        projectionMatrix: Windows.UI.Xaml.Media.Media3D.Matrix3D;
        static projectionMatrixProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class MatrixHelper implements Windows.UI.Xaml.Media.IMatrixHelper {
        static fromElements(m11: number, m12: number, m21: number, m22: number, offsetX: number, offsetY: number): Windows.UI.Xaml.Media.Matrix;
        static getIsIdentity(target: Windows.UI.Xaml.Media.Matrix): boolean;
        static transform(target: Windows.UI.Xaml.Media.Matrix, point: Windows.Foundation.Point): Windows.Foundation.Point;
        static identity: Windows.UI.Xaml.Media.Matrix;
    }

    export class MatrixTransform implements Windows.UI.Xaml.Media.IMatrixTransform {
        constructor();
        matrix: Windows.UI.Xaml.Media.Matrix;
        static matrixProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum MediaCanPlayResponse {
        notSupported,
        maybe,
        probably
    }

    enum MediaElementState {
        closed,
        opening,
        buffering,
        playing,
        paused,
        stopped
    }

    export class PathFigure implements Windows.UI.Xaml.Media.IPathFigure {
        constructor();
        isClosed: boolean;
        isFilled: boolean;
        segments: Windows.UI.Xaml.Media.PathSegmentCollection;
        startPoint: Windows.Foundation.Point;
        static isClosedProperty: Windows.UI.Xaml.DependencyProperty;
        static isFilledProperty: Windows.UI.Xaml.DependencyProperty;
        static segmentsProperty: Windows.UI.Xaml.DependencyProperty;
        static startPointProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PathFigureCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.PathFigure>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.PathFigure> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.PathFigure;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.PathFigure>;
        indexOf(value: Windows.UI.Xaml.Media.PathFigure): PathFigureCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.PathFigure): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.PathFigure): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.PathFigure): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): PathFigureCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.PathFigure[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.PathFigure>;
        size: number;
    }

    interface PathFigureCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PathFigureCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.PathFigure[];
    }

    export class PathGeometry implements Windows.UI.Xaml.Media.IPathGeometry {
        constructor();
        figures: Windows.UI.Xaml.Media.PathFigureCollection;
        fillRule: Windows.UI.Xaml.Media.FillRule;
        static figuresProperty: Windows.UI.Xaml.DependencyProperty;
        static fillRuleProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PathSegment implements Windows.UI.Xaml.Media.IPathSegment {
    }

    export class PathSegmentCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.PathSegment>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.PathSegment> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.PathSegment;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.PathSegment>;
        indexOf(value: Windows.UI.Xaml.Media.PathSegment): PathSegmentCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.PathSegment): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.PathSegment): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.PathSegment): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): PathSegmentCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.PathSegment[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.PathSegment>;
        size: number;
    }

    interface PathSegmentCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PathSegmentCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.PathSegment[];
    }

    enum PenLineCap {
        flat,
        square,
        round,
        triangle
    }

    enum PenLineJoin {
        miter,
        bevel,
        round
    }

    export class PlaneProjection implements Windows.UI.Xaml.Media.IPlaneProjection {
        constructor();
        centerOfRotationX: number;
        centerOfRotationY: number;
        centerOfRotationZ: number;
        globalOffsetX: number;
        globalOffsetY: number;
        globalOffsetZ: number;
        localOffsetX: number;
        localOffsetY: number;
        localOffsetZ: number;
        projectionMatrix: Windows.UI.Xaml.Media.Media3D.Matrix3D;
        rotationX: number;
        rotationY: number;
        rotationZ: number;
        static centerOfRotationXProperty: Windows.UI.Xaml.DependencyProperty;
        static centerOfRotationYProperty: Windows.UI.Xaml.DependencyProperty;
        static centerOfRotationZProperty: Windows.UI.Xaml.DependencyProperty;
        static globalOffsetXProperty: Windows.UI.Xaml.DependencyProperty;
        static globalOffsetYProperty: Windows.UI.Xaml.DependencyProperty;
        static globalOffsetZProperty: Windows.UI.Xaml.DependencyProperty;
        static localOffsetXProperty: Windows.UI.Xaml.DependencyProperty;
        static localOffsetYProperty: Windows.UI.Xaml.DependencyProperty;
        static localOffsetZProperty: Windows.UI.Xaml.DependencyProperty;
        static projectionMatrixProperty: Windows.UI.Xaml.DependencyProperty;
        static rotationXProperty: Windows.UI.Xaml.DependencyProperty;
        static rotationYProperty: Windows.UI.Xaml.DependencyProperty;
        static rotationZProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointCollection implements Windows.Foundation.Collections.IVector<Windows.Foundation.Point>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Point> {
        constructor();
        getAt(index: number): Windows.Foundation.Point;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.Foundation.Point>;
        indexOf(value: Windows.Foundation.Point): PointCollection_indexOf_OUT;
        setAt(index: number, value: Windows.Foundation.Point): void;
        insertAt(index: number, value: Windows.Foundation.Point): void;
        removeAt(index: number): void;
        append(value: Windows.Foundation.Point): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): PointCollection_getMany_OUT;
        replaceAll(items: Windows.Foundation.Point[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Point>;
        size: number;
    }

    interface PointCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PointCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.Point[];
    }

    export class PolyBezierSegment implements Windows.UI.Xaml.Media.IPolyBezierSegment {
        constructor();
        points: Windows.UI.Xaml.Media.PointCollection;
        static pointsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PolyLineSegment implements Windows.UI.Xaml.Media.IPolyLineSegment {
        constructor();
        points: Windows.UI.Xaml.Media.PointCollection;
        static pointsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PolyQuadraticBezierSegment implements Windows.UI.Xaml.Media.IPolyQuadraticBezierSegment {
        constructor();
        points: Windows.UI.Xaml.Media.PointCollection;
        static pointsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Projection implements Windows.UI.Xaml.Media.IProjection {
        constructor();
    }

    export class QuadraticBezierSegment implements Windows.UI.Xaml.Media.IQuadraticBezierSegment {
        constructor();
        point1: Windows.Foundation.Point;
        point2: Windows.Foundation.Point;
        static point1Property: Windows.UI.Xaml.DependencyProperty;
        static point2Property: Windows.UI.Xaml.DependencyProperty;
    }

    export class RateChangedRoutedEventArgs implements Windows.UI.Xaml.Media.IRateChangedRoutedEventArgs {
        constructor();
    }

    export interface RateChangedRoutedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class RectangleGeometry implements Windows.UI.Xaml.Media.IRectangleGeometry {
        constructor();
        rect: Windows.Foundation.Rect;
        static rectProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RenderingEventArgs implements Windows.UI.Xaml.Media.IRenderingEventArgs {
        renderingTime: Windows.Foundation.TimeSpan;
    }

    export class RotateTransform implements Windows.UI.Xaml.Media.IRotateTransform {
        constructor();
        angle: number;
        centerX: number;
        centerY: number;
        static angleProperty: Windows.UI.Xaml.DependencyProperty;
        static centerXProperty: Windows.UI.Xaml.DependencyProperty;
        static centerYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ScaleTransform implements Windows.UI.Xaml.Media.IScaleTransform {
        constructor();
        centerX: number;
        centerY: number;
        scaleX: number;
        scaleY: number;
        static centerXProperty: Windows.UI.Xaml.DependencyProperty;
        static centerYProperty: Windows.UI.Xaml.DependencyProperty;
        static scaleXProperty: Windows.UI.Xaml.DependencyProperty;
        static scaleYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SkewTransform implements Windows.UI.Xaml.Media.ISkewTransform {
        constructor();
        angleX: number;
        angleY: number;
        centerX: number;
        centerY: number;
        static angleXProperty: Windows.UI.Xaml.DependencyProperty;
        static angleYProperty: Windows.UI.Xaml.DependencyProperty;
        static centerXProperty: Windows.UI.Xaml.DependencyProperty;
        static centerYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SolidColorBrush implements Windows.UI.Xaml.Media.ISolidColorBrush {
        constructor();
        constructor(color: Windows.UI.Color);
        color: Windows.UI.Color;
        static colorProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum Stereo3DVideoPackingMode {
        none,
        sideBySide,
        topBottom
    }

    enum Stereo3DVideoRenderMode {
        mono,
        stereo
    }

    enum Stretch {
        none,
        fill,
        uniform,
        uniformToFill
    }

    enum StyleSimulations {
        none,
        boldSimulation,
        italicSimulation,
        boldItalicSimulation
    }

    enum SweepDirection {
        counterclockwise,
        clockwise
    }

    export class TileBrush implements Windows.UI.Xaml.Media.ITileBrush {
        constructor();
        alignmentX: Windows.UI.Xaml.Media.AlignmentX;
        alignmentY: Windows.UI.Xaml.Media.AlignmentY;
        stretch: Windows.UI.Xaml.Media.Stretch;
        static alignmentXProperty: Windows.UI.Xaml.DependencyProperty;
        static alignmentYProperty: Windows.UI.Xaml.DependencyProperty;
        static stretchProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class TimelineMarker implements Windows.UI.Xaml.Media.ITimelineMarker {
        constructor();
        text: string;
        time: Windows.Foundation.TimeSpan;
        type: string;
        static textProperty: Windows.UI.Xaml.DependencyProperty;
        static timeProperty: Windows.UI.Xaml.DependencyProperty;
        static typeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class TimelineMarkerCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.TimelineMarker>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.TimelineMarker> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.TimelineMarker;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.TimelineMarker>;
        indexOf(value: Windows.UI.Xaml.Media.TimelineMarker): TimelineMarkerCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.TimelineMarker): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.TimelineMarker): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.TimelineMarker): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TimelineMarkerCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.TimelineMarker[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.TimelineMarker>;
        size: number;
    }

    interface TimelineMarkerCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TimelineMarkerCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.TimelineMarker[];
    }

    export class TimelineMarkerRoutedEventArgs implements Windows.UI.Xaml.Media.ITimelineMarkerRoutedEventArgs {
        constructor();
        marker: Windows.UI.Xaml.Media.TimelineMarker;
    }

    export interface TimelineMarkerRoutedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class Transform implements Windows.UI.Xaml.Media.ITransform {
    }

    export class TransformCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Transform>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Transform> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Transform;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Transform>;
        indexOf(value: Windows.UI.Xaml.Media.Transform): TransformCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Transform): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Transform): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Transform): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TransformCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Transform[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Transform>;
        size: number;
    }

    interface TransformCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TransformCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Transform[];
    }

    export class TransformGroup implements Windows.UI.Xaml.Media.ITransformGroup {
        constructor();
        children: Windows.UI.Xaml.Media.TransformCollection;
        value: Windows.UI.Xaml.Media.Matrix;
        static childrenProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class TranslateTransform implements Windows.UI.Xaml.Media.ITranslateTransform {
        constructor();
        x: number;
        y: number;
        static xProperty: Windows.UI.Xaml.DependencyProperty;
        static yProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class VisualTreeHelper implements Windows.UI.Xaml.Media.IVisualTreeHelper {
        static findElementsInHostCoordinates(intersectingPoint: Windows.Foundation.Point, subtree: Windows.UI.Xaml.UIElement): Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.UIElement>;
        static findElementsInHostCoordinates(intersectingRect: Windows.Foundation.Rect, subtree: Windows.UI.Xaml.UIElement): Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.UIElement>;
        static findElementsInHostCoordinates(intersectingPoint: Windows.Foundation.Point, subtree: Windows.UI.Xaml.UIElement, includeAllElements: boolean): Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.UIElement>;
        static findElementsInHostCoordinates(intersectingRect: Windows.Foundation.Rect, subtree: Windows.UI.Xaml.UIElement, includeAllElements: boolean): Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.UIElement>;
        static getChild(reference: Windows.UI.Xaml.DependencyObject, childIndex: number): Windows.UI.Xaml.DependencyObject;
        static getChildrenCount(reference: Windows.UI.Xaml.DependencyObject): number;
        static getParent(reference: Windows.UI.Xaml.DependencyObject): Windows.UI.Xaml.DependencyObject;
        static disconnectChildrenRecursive(element: Windows.UI.Xaml.UIElement): void;
    }

}
declare module Windows.UI.Xaml.Media.Animation {

    export class AddDeleteThemeTransition implements Windows.UI.Xaml.Media.Animation.IAddDeleteThemeTransition {
        constructor();
    }

    export class BackEase implements Windows.UI.Xaml.Media.Animation.IBackEase {
        constructor();
        amplitude: number;
        static amplitudeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class BeginStoryboard implements Windows.UI.Xaml.Media.Animation.IBeginStoryboard {
        constructor();
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
        static storyboardProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class BounceEase implements Windows.UI.Xaml.Media.Animation.IBounceEase {
        constructor();
        bounces: number;
        bounciness: number;
        static bouncesProperty: Windows.UI.Xaml.DependencyProperty;
        static bouncinessProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CircleEase implements Windows.UI.Xaml.Media.Animation.ICircleEase {
        constructor();
    }

    enum ClockState {
        active,
        filling,
        stopped
    }

    export class ColorAnimation implements Windows.UI.Xaml.Media.Animation.IColorAnimation {
        constructor();
        by: Windows.Foundation.IReference<Windows.UI.Color>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<Windows.UI.Color>;
        to: Windows.Foundation.IReference<Windows.UI.Color>;
        static byProperty: Windows.UI.Xaml.DependencyProperty;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
        static fromProperty: Windows.UI.Xaml.DependencyProperty;
        static toProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ColorAnimationUsingKeyFrames implements Windows.UI.Xaml.Media.Animation.IColorAnimationUsingKeyFrames {
        constructor();
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ColorKeyFrame implements Windows.UI.Xaml.Media.Animation.IColorKeyFrame {
        constructor();
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: Windows.UI.Color;
        static keyTimeProperty: Windows.UI.Xaml.DependencyProperty;
        static valueProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ColorKeyFrameCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.ColorKeyFrame>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.ColorKeyFrame> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.ColorKeyFrame;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.ColorKeyFrame>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.ColorKeyFrame): ColorKeyFrameCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.ColorKeyFrame): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.ColorKeyFrame): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.ColorKeyFrame): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): ColorKeyFrameCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.ColorKeyFrame[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.ColorKeyFrame>;
        size: number;
    }

    interface ColorKeyFrameCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ColorKeyFrameCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.ColorKeyFrame[];
    }

    export class ConditionallyIndependentlyAnimatableAttribute {
        constructor();
    }

    export class ContentThemeTransition implements Windows.UI.Xaml.Media.Animation.IContentThemeTransition {
        constructor();
        horizontalOffset: number;
        verticalOffset: number;
        static horizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static verticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class CubicEase implements Windows.UI.Xaml.Media.Animation.ICubicEase {
        constructor();
    }

    export class DiscreteColorKeyFrame implements Windows.UI.Xaml.Media.Animation.IDiscreteColorKeyFrame {
        constructor();
    }

    export class DiscreteDoubleKeyFrame implements Windows.UI.Xaml.Media.Animation.IDiscreteDoubleKeyFrame {
        constructor();
    }

    export class DiscreteObjectKeyFrame implements Windows.UI.Xaml.Media.Animation.IDiscreteObjectKeyFrame {
        constructor();
    }

    export class DiscretePointKeyFrame implements Windows.UI.Xaml.Media.Animation.IDiscretePointKeyFrame {
        constructor();
    }

    export class DoubleAnimation implements Windows.UI.Xaml.Media.Animation.IDoubleAnimation {
        constructor();
        by: Windows.Foundation.IReference<number>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<number>;
        to: Windows.Foundation.IReference<number>;
        static byProperty: Windows.UI.Xaml.DependencyProperty;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
        static fromProperty: Windows.UI.Xaml.DependencyProperty;
        static toProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DoubleAnimationUsingKeyFrames implements Windows.UI.Xaml.Media.Animation.IDoubleAnimationUsingKeyFrames {
        constructor();
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DoubleKeyFrame implements Windows.UI.Xaml.Media.Animation.IDoubleKeyFrame {
        constructor();
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: number;
        static keyTimeProperty: Windows.UI.Xaml.DependencyProperty;
        static valueProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DoubleKeyFrameCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.DoubleKeyFrame;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame): DoubleKeyFrameCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): DoubleKeyFrameCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.DoubleKeyFrame>;
        size: number;
    }

    interface DoubleKeyFrameCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface DoubleKeyFrameCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.DoubleKeyFrame[];
    }

    export class DragItemThemeAnimation implements Windows.UI.Xaml.Media.Animation.IDragItemThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DragOverThemeAnimation implements Windows.UI.Xaml.Media.Animation.IDragOverThemeAnimation {
        constructor();
        direction: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        targetName: string;
        toOffset: number;
        static directionProperty: Windows.UI.Xaml.DependencyProperty;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static toOffsetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DropTargetItemThemeAnimation implements Windows.UI.Xaml.Media.Animation.IDropTargetItemThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class EasingColorKeyFrame implements Windows.UI.Xaml.Media.Animation.IEasingColorKeyFrame {
        constructor();
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class EasingDoubleKeyFrame implements Windows.UI.Xaml.Media.Animation.IEasingDoubleKeyFrame {
        constructor();
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class EasingFunctionBase implements Windows.UI.Xaml.Media.Animation.IEasingFunctionBase {
        ease(normalizedTime: number): number;
        easingMode: Windows.UI.Xaml.Media.Animation.EasingMode;
        static easingModeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum EasingMode {
        easeOut,
        easeIn,
        easeInOut
    }

    export class EasingPointKeyFrame implements Windows.UI.Xaml.Media.Animation.IEasingPointKeyFrame {
        constructor();
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class EdgeUIThemeTransition implements Windows.UI.Xaml.Media.Animation.IEdgeUIThemeTransition {
        constructor();
        edge: Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
        static edgeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ElasticEase implements Windows.UI.Xaml.Media.Animation.IElasticEase {
        constructor();
        oscillations: number;
        springiness: number;
        static oscillationsProperty: Windows.UI.Xaml.DependencyProperty;
        static springinessProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class EntranceThemeTransition implements Windows.UI.Xaml.Media.Animation.IEntranceThemeTransition {
        constructor();
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        isStaggeringEnabled: boolean;
        static fromHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static fromVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static isStaggeringEnabledProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ExponentialEase implements Windows.UI.Xaml.Media.Animation.IExponentialEase {
        constructor();
        exponent: number;
        static exponentProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class FadeInThemeAnimation implements Windows.UI.Xaml.Media.Animation.IFadeInThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class FadeOutThemeAnimation implements Windows.UI.Xaml.Media.Animation.IFadeOutThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    enum FillBehavior {
        holdEnd,
        stop
    }

    export interface IAddDeleteThemeTransition {
    }

    export interface IBackEase {
        amplitude: number;
    }

    export interface IBeginStoryboard {
        storyboard: Windows.UI.Xaml.Media.Animation.Storyboard;
    }

    export interface IBounceEase {
        bounces: number;
        bounciness: number;
    }

    export interface ICircleEase {
    }

    export interface IColorAnimation {
        by: Windows.Foundation.IReference<Windows.UI.Color>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<Windows.UI.Color>;
        to: Windows.Foundation.IReference<Windows.UI.Color>;
    }

    export interface IColorAnimationUsingKeyFrames {
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.ColorKeyFrameCollection;
    }

    export interface IColorKeyFrame {
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: Windows.UI.Color;
    }

    export interface IContentThemeTransition {
        horizontalOffset: number;
        verticalOffset: number;
    }

    export interface ICubicEase {
    }

    export interface IDiscreteColorKeyFrame {
    }

    export interface IDiscreteDoubleKeyFrame {
    }

    export interface IDiscreteObjectKeyFrame {
    }

    export interface IDiscretePointKeyFrame {
    }

    export interface IDoubleAnimation {
        by: Windows.Foundation.IReference<number>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<number>;
        to: Windows.Foundation.IReference<number>;
    }

    export interface IDoubleAnimationUsingKeyFrames {
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.DoubleKeyFrameCollection;
    }

    export interface IDoubleKeyFrame {
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: number;
    }

    export interface IDragItemThemeAnimation {
        targetName: string;
    }

    export interface IDragOverThemeAnimation {
        direction: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        targetName: string;
        toOffset: number;
    }

    export interface IDropTargetItemThemeAnimation {
        targetName: string;
    }

    export interface IEasingColorKeyFrame {
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
    }

    export interface IEasingDoubleKeyFrame {
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
    }

    export interface IEasingFunctionBase {
        ease(normalizedTime: number): number;
        easingMode: Windows.UI.Xaml.Media.Animation.EasingMode;
    }

    export interface IEasingPointKeyFrame {
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
    }

    export interface IEdgeUIThemeTransition {
        edge: Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
    }

    export interface IElasticEase {
        oscillations: number;
        springiness: number;
    }

    export interface IEntranceThemeTransition {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        isStaggeringEnabled: boolean;
    }

    export interface IExponentialEase {
        exponent: number;
    }

    export interface IFadeInThemeAnimation {
        targetName: string;
    }

    export interface IFadeOutThemeAnimation {
        targetName: string;
    }

    export interface IKeySpline {
        controlPoint1: Windows.Foundation.Point;
        controlPoint2: Windows.Foundation.Point;
    }

    export interface IKeyTimeHelper {
    }

    export interface ILinearColorKeyFrame {
    }

    export interface ILinearDoubleKeyFrame {
    }

    export interface ILinearPointKeyFrame {
    }

    export class IndependentlyAnimatableAttribute {
        constructor();
    }

    export interface IObjectAnimationUsingKeyFrames {
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection;
    }

    export interface IObjectKeyFrame {
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: any;
    }

    export interface IPaneThemeTransition {
        edge: Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
    }

    export interface IPointAnimation {
        by: Windows.Foundation.IReference<Windows.Foundation.Point>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<Windows.Foundation.Point>;
        to: Windows.Foundation.IReference<Windows.Foundation.Point>;
    }

    export interface IPointAnimationUsingKeyFrames {
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection;
    }

    export interface IPointerDownThemeAnimation {
        targetName: string;
    }

    export interface IPointerUpThemeAnimation {
        targetName: string;
    }

    export interface IPointKeyFrame {
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: Windows.Foundation.Point;
    }

    export interface IPopInThemeAnimation {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
    }

    export interface IPopOutThemeAnimation {
        targetName: string;
    }

    export interface IPopupThemeTransition {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
    }

    export interface IPowerEase {
        power: number;
    }

    export interface IQuadraticEase {
    }

    export interface IQuarticEase {
    }

    export interface IQuinticEase {
    }

    export interface IReorderThemeTransition {
    }

    export interface IRepeatBehaviorHelper {
    }

    export interface IRepositionThemeAnimation {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
    }

    export interface IRepositionThemeTransition {
    }

    export interface ISineEase {
    }

    export interface ISplineColorKeyFrame {
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
    }

    export interface ISplineDoubleKeyFrame {
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
    }

    export interface ISplinePointKeyFrame {
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
    }

    export interface ISplitCloseThemeAnimation {
        closedLength: number;
        closedTarget: Windows.UI.Xaml.DependencyObject;
        closedTargetName: string;
        contentTarget: Windows.UI.Xaml.DependencyObject;
        contentTargetName: string;
        contentTranslationDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        contentTranslationOffset: number;
        offsetFromCenter: number;
        openedLength: number;
        openedTarget: Windows.UI.Xaml.DependencyObject;
        openedTargetName: string;
    }

    export interface ISplitOpenThemeAnimation {
        closedLength: number;
        closedTarget: Windows.UI.Xaml.DependencyObject;
        closedTargetName: string;
        contentTarget: Windows.UI.Xaml.DependencyObject;
        contentTargetName: string;
        contentTranslationDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        contentTranslationOffset: number;
        offsetFromCenter: number;
        openedLength: number;
        openedTarget: Windows.UI.Xaml.DependencyObject;
        openedTargetName: string;
    }

    export interface IStoryboard {
        seek(offset: Windows.Foundation.TimeSpan): void;
        stop(): void;
        begin(): void;
        pause(): void;
        resume(): void;
        getCurrentState(): Windows.UI.Xaml.Media.Animation.ClockState;
        getCurrentTime(): Windows.Foundation.TimeSpan;
        seekAlignedToLastTick(offset: Windows.Foundation.TimeSpan): void;
        skipToFill(): void;
        children: Windows.UI.Xaml.Media.Animation.TimelineCollection;
    }

    export interface ISwipeBackThemeAnimation {
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
    }

    export interface ISwipeHintThemeAnimation {
        targetName: string;
        toHorizontalOffset: number;
        toVerticalOffset: number;
    }

    export interface ITimeline {
        add_Completed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(token: Windows.Foundation.EventRegistrationToken): void;
        autoReverse: boolean;
        beginTime: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
        duration: Windows.UI.Xaml.Duration;
        fillBehavior: Windows.UI.Xaml.Media.Animation.FillBehavior;
        repeatBehavior: Windows.UI.Xaml.Media.Animation.RepeatBehavior;
        speedRatio: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.EventHandler<any>): void;
        oncompleted: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export interface ITransition {
    }

    export class KeySpline implements Windows.UI.Xaml.Media.Animation.IKeySpline {
        constructor();
        controlPoint1: Windows.Foundation.Point;
        controlPoint2: Windows.Foundation.Point;
    }

    export class KeyTime {
        timeSpan: Windows.Foundation.TimeSpan;
    }

    export class KeyTimeHelper implements Windows.UI.Xaml.Media.Animation.IKeyTimeHelper {
        static fromTimeSpan(timeSpan: Windows.Foundation.TimeSpan): Windows.UI.Xaml.Media.Animation.KeyTime;
    }

    export class LinearColorKeyFrame implements Windows.UI.Xaml.Media.Animation.ILinearColorKeyFrame {
        constructor();
    }

    export class LinearDoubleKeyFrame implements Windows.UI.Xaml.Media.Animation.ILinearDoubleKeyFrame {
        constructor();
    }

    export class LinearPointKeyFrame implements Windows.UI.Xaml.Media.Animation.ILinearPointKeyFrame {
        constructor();
    }

    export class ObjectAnimationUsingKeyFrames implements Windows.UI.Xaml.Media.Animation.IObjectAnimationUsingKeyFrames {
        constructor();
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.ObjectKeyFrameCollection;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ObjectKeyFrame implements Windows.UI.Xaml.Media.Animation.IObjectKeyFrame {
        constructor();
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: any;
        static keyTimeProperty: Windows.UI.Xaml.DependencyProperty;
        static valueProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class ObjectKeyFrameCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.ObjectKeyFrame;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame): ObjectKeyFrameCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): ObjectKeyFrameCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.ObjectKeyFrame>;
        size: number;
    }

    interface ObjectKeyFrameCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface ObjectKeyFrameCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.ObjectKeyFrame[];
    }

    export class PaneThemeTransition implements Windows.UI.Xaml.Media.Animation.IPaneThemeTransition {
        constructor();
        edge: Windows.UI.Xaml.Controls.Primitives.EdgeTransitionLocation;
        static edgeProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointAnimation implements Windows.UI.Xaml.Media.Animation.IPointAnimation {
        constructor();
        by: Windows.Foundation.IReference<Windows.Foundation.Point>;
        easingFunction: Windows.UI.Xaml.Media.Animation.EasingFunctionBase;
        enableDependentAnimation: boolean;
        from: Windows.Foundation.IReference<Windows.Foundation.Point>;
        to: Windows.Foundation.IReference<Windows.Foundation.Point>;
        static byProperty: Windows.UI.Xaml.DependencyProperty;
        static easingFunctionProperty: Windows.UI.Xaml.DependencyProperty;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
        static fromProperty: Windows.UI.Xaml.DependencyProperty;
        static toProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointAnimationUsingKeyFrames implements Windows.UI.Xaml.Media.Animation.IPointAnimationUsingKeyFrames {
        constructor();
        enableDependentAnimation: boolean;
        keyFrames: Windows.UI.Xaml.Media.Animation.PointKeyFrameCollection;
        static enableDependentAnimationProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointerDownThemeAnimation implements Windows.UI.Xaml.Media.Animation.IPointerDownThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointerUpThemeAnimation implements Windows.UI.Xaml.Media.Animation.IPointerUpThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointKeyFrame implements Windows.UI.Xaml.Media.Animation.IPointKeyFrame {
        constructor();
        keyTime: Windows.UI.Xaml.Media.Animation.KeyTime;
        value: Windows.Foundation.Point;
        static keyTimeProperty: Windows.UI.Xaml.DependencyProperty;
        static valueProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PointKeyFrameCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.PointKeyFrame>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.PointKeyFrame> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.PointKeyFrame;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.PointKeyFrame>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.PointKeyFrame): PointKeyFrameCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.PointKeyFrame): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.PointKeyFrame): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.PointKeyFrame): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): PointKeyFrameCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.PointKeyFrame[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.PointKeyFrame>;
        size: number;
    }

    interface PointKeyFrameCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface PointKeyFrameCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.PointKeyFrame[];
    }

    export class PopInThemeAnimation implements Windows.UI.Xaml.Media.Animation.IPopInThemeAnimation {
        constructor();
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
        static fromHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static fromVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PopOutThemeAnimation implements Windows.UI.Xaml.Media.Animation.IPopOutThemeAnimation {
        constructor();
        targetName: string;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PopupThemeTransition implements Windows.UI.Xaml.Media.Animation.IPopupThemeTransition {
        constructor();
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        static fromHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static fromVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class PowerEase implements Windows.UI.Xaml.Media.Animation.IPowerEase {
        constructor();
        power: number;
        static powerProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class QuadraticEase implements Windows.UI.Xaml.Media.Animation.IQuadraticEase {
        constructor();
    }

    export class QuarticEase implements Windows.UI.Xaml.Media.Animation.IQuarticEase {
        constructor();
    }

    export class QuinticEase implements Windows.UI.Xaml.Media.Animation.IQuinticEase {
        constructor();
    }

    export class ReorderThemeTransition implements Windows.UI.Xaml.Media.Animation.IReorderThemeTransition {
        constructor();
    }

    export class RepeatBehavior {
        count: number;
        duration: Windows.Foundation.TimeSpan;
        type: Windows.UI.Xaml.Media.Animation.RepeatBehaviorType;
    }

    export class RepeatBehaviorHelper implements Windows.UI.Xaml.Media.Animation.IRepeatBehaviorHelper {
        static fromCount(count: number): Windows.UI.Xaml.Media.Animation.RepeatBehavior;
        static fromDuration(duration: Windows.Foundation.TimeSpan): Windows.UI.Xaml.Media.Animation.RepeatBehavior;
        static getHasCount(target: Windows.UI.Xaml.Media.Animation.RepeatBehavior): boolean;
        static getHasDuration(target: Windows.UI.Xaml.Media.Animation.RepeatBehavior): boolean;
        static equals(target: Windows.UI.Xaml.Media.Animation.RepeatBehavior, value: Windows.UI.Xaml.Media.Animation.RepeatBehavior): boolean;
        static forever: Windows.UI.Xaml.Media.Animation.RepeatBehavior;
    }

    enum RepeatBehaviorType {
        count,
        duration,
        forever
    }

    export class RepositionThemeAnimation implements Windows.UI.Xaml.Media.Animation.IRepositionThemeAnimation {
        constructor();
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
        static fromHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static fromVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class RepositionThemeTransition implements Windows.UI.Xaml.Media.Animation.IRepositionThemeTransition {
        constructor();
    }

    export class SineEase implements Windows.UI.Xaml.Media.Animation.ISineEase {
        constructor();
    }

    export class SplineColorKeyFrame implements Windows.UI.Xaml.Media.Animation.ISplineColorKeyFrame {
        constructor();
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
        static keySplineProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SplineDoubleKeyFrame implements Windows.UI.Xaml.Media.Animation.ISplineDoubleKeyFrame {
        constructor();
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
        static keySplineProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SplinePointKeyFrame implements Windows.UI.Xaml.Media.Animation.ISplinePointKeyFrame {
        constructor();
        keySpline: Windows.UI.Xaml.Media.Animation.KeySpline;
        static keySplineProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SplitCloseThemeAnimation implements Windows.UI.Xaml.Media.Animation.ISplitCloseThemeAnimation {
        constructor();
        closedLength: number;
        closedTarget: Windows.UI.Xaml.DependencyObject;
        closedTargetName: string;
        contentTarget: Windows.UI.Xaml.DependencyObject;
        contentTargetName: string;
        contentTranslationDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        contentTranslationOffset: number;
        offsetFromCenter: number;
        openedLength: number;
        openedTarget: Windows.UI.Xaml.DependencyObject;
        openedTargetName: string;
        static closedLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static closedTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static closedTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTranslationDirectionProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTranslationOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static offsetFromCenterProperty: Windows.UI.Xaml.DependencyProperty;
        static openedLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static openedTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static openedTargetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SplitOpenThemeAnimation implements Windows.UI.Xaml.Media.Animation.ISplitOpenThemeAnimation {
        constructor();
        closedLength: number;
        closedTarget: Windows.UI.Xaml.DependencyObject;
        closedTargetName: string;
        contentTarget: Windows.UI.Xaml.DependencyObject;
        contentTargetName: string;
        contentTranslationDirection: Windows.UI.Xaml.Controls.Primitives.AnimationDirection;
        contentTranslationOffset: number;
        offsetFromCenter: number;
        openedLength: number;
        openedTarget: Windows.UI.Xaml.DependencyObject;
        openedTargetName: string;
        static closedLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static closedTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static closedTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTargetProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTranslationDirectionProperty: Windows.UI.Xaml.DependencyProperty;
        static contentTranslationOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static offsetFromCenterProperty: Windows.UI.Xaml.DependencyProperty;
        static openedLengthProperty: Windows.UI.Xaml.DependencyProperty;
        static openedTargetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static openedTargetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Storyboard implements Windows.UI.Xaml.Media.Animation.IStoryboard {
        constructor();
        seek(offset: Windows.Foundation.TimeSpan): void;
        stop(): void;
        begin(): void;
        pause(): void;
        resume(): void;
        getCurrentState(): Windows.UI.Xaml.Media.Animation.ClockState;
        getCurrentTime(): Windows.Foundation.TimeSpan;
        seekAlignedToLastTick(offset: Windows.Foundation.TimeSpan): void;
        skipToFill(): void;
        static getTargetProperty(element: Windows.UI.Xaml.Media.Animation.Timeline): string;
        static setTargetProperty(element: Windows.UI.Xaml.Media.Animation.Timeline, path: string): void;
        static getTargetName(element: Windows.UI.Xaml.Media.Animation.Timeline): string;
        static setTargetName(element: Windows.UI.Xaml.Media.Animation.Timeline, name: string): void;
        static setTarget(timeline: Windows.UI.Xaml.Media.Animation.Timeline, target: Windows.UI.Xaml.DependencyObject): void;
        children: Windows.UI.Xaml.Media.Animation.TimelineCollection;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static targetPropertyProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SwipeBackThemeAnimation implements Windows.UI.Xaml.Media.Animation.ISwipeBackThemeAnimation {
        constructor();
        fromHorizontalOffset: number;
        fromVerticalOffset: number;
        targetName: string;
        static fromHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static fromVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class SwipeHintThemeAnimation implements Windows.UI.Xaml.Media.Animation.ISwipeHintThemeAnimation {
        constructor();
        targetName: string;
        toHorizontalOffset: number;
        toVerticalOffset: number;
        static targetNameProperty: Windows.UI.Xaml.DependencyProperty;
        static toHorizontalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static toVerticalOffsetProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Timeline implements Windows.UI.Xaml.Media.Animation.ITimeline {
        constructor();
        add_Completed(value: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        remove_Completed(token: Windows.Foundation.EventRegistrationToken): void;
        autoReverse: boolean;
        beginTime: Windows.Foundation.IReference<Windows.Foundation.TimeSpan>;
        duration: Windows.UI.Xaml.Duration;
        fillBehavior: Windows.UI.Xaml.Media.Animation.FillBehavior;
        repeatBehavior: Windows.UI.Xaml.Media.Animation.RepeatBehavior;
        speedRatio: number;
        static allowDependentAnimations: boolean;
        static autoReverseProperty: Windows.UI.Xaml.DependencyProperty;
        static beginTimeProperty: Windows.UI.Xaml.DependencyProperty;
        static durationProperty: Windows.UI.Xaml.DependencyProperty;
        static fillBehaviorProperty: Windows.UI.Xaml.DependencyProperty;
        static repeatBehaviorProperty: Windows.UI.Xaml.DependencyProperty;
        static speedRatioProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "completed", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "completed", listener: Windows.Foundation.EventHandler<any>): void;
        oncompleted: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class TimelineCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.Timeline>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.Timeline> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.Timeline;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.Timeline>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.Timeline): TimelineCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.Timeline): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.Timeline): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.Timeline): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TimelineCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.Timeline[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.Timeline>;
        size: number;
    }

    interface TimelineCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TimelineCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.Timeline[];
    }

    export class Transition implements Windows.UI.Xaml.Media.Animation.ITransition {
    }

    export class TransitionCollection implements Windows.Foundation.Collections.IVector<Windows.UI.Xaml.Media.Animation.Transition>, Windows.Foundation.Collections.IIterable<Windows.UI.Xaml.Media.Animation.Transition> {
        constructor();
        getAt(index: number): Windows.UI.Xaml.Media.Animation.Transition;
        getView(): Windows.Foundation.Collections.IVectorView<Windows.UI.Xaml.Media.Animation.Transition>;
        indexOf(value: Windows.UI.Xaml.Media.Animation.Transition): TransitionCollection_indexOf_OUT;
        setAt(index: number, value: Windows.UI.Xaml.Media.Animation.Transition): void;
        insertAt(index: number, value: Windows.UI.Xaml.Media.Animation.Transition): void;
        removeAt(index: number): void;
        append(value: Windows.UI.Xaml.Media.Animation.Transition): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): TransitionCollection_getMany_OUT;
        replaceAll(items: Windows.UI.Xaml.Media.Animation.Transition[]): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.UI.Xaml.Media.Animation.Transition>;
        size: number;
    }

    interface TransitionCollection_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface TransitionCollection_getMany_OUT {
        __returnValue: number;
        items: Windows.UI.Xaml.Media.Animation.Transition[];
    }

}
declare module Windows.UI.Xaml.Media.Imaging {

    enum BitmapCreateOptions {
        none,
        ignoreImageCache
    }

    export class BitmapImage implements Windows.UI.Xaml.Media.Imaging.IBitmapImage {
        constructor();
        constructor(uriSource: Windows.Foundation.Uri);
        add_DownloadProgress(value: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DownloadProgress(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        createOptions: Windows.UI.Xaml.Media.Imaging.BitmapCreateOptions;
        decodePixelHeight: number;
        decodePixelWidth: number;
        uriSource: Windows.Foundation.Uri;
        static createOptionsProperty: Windows.UI.Xaml.DependencyProperty;
        static decodePixelHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static decodePixelWidthProperty: Windows.UI.Xaml.DependencyProperty;
        static uriSourceProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "downloadprogress", listener: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): void;
        removeEventListener(eventName: "downloadprogress", listener: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): void;
        ondownloadprogress: (ev: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler) => void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export class BitmapSource implements Windows.UI.Xaml.Media.Imaging.IBitmapSource {
        constructor();
        setSource(streamSource: Windows.Storage.Streams.IRandomAccessStream): void;
        setSourceAsync(streamSource: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        pixelHeight: number;
        pixelWidth: number;
        static pixelHeightProperty: Windows.UI.Xaml.DependencyProperty;
        static pixelWidthProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class DownloadProgressEventArgs implements Windows.UI.Xaml.Media.Imaging.IDownloadProgressEventArgs {
        progress: number;
    }

    export interface DownloadProgressEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IBitmapImage {
        add_DownloadProgress(value: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_DownloadProgress(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageOpened(value: Windows.UI.Xaml.RoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageOpened(token: Windows.Foundation.EventRegistrationToken): void;
        add_ImageFailed(value: Windows.UI.Xaml.ExceptionRoutedEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_ImageFailed(token: Windows.Foundation.EventRegistrationToken): void;
        createOptions: Windows.UI.Xaml.Media.Imaging.BitmapCreateOptions;
        decodePixelHeight: number;
        decodePixelWidth: number;
        uriSource: Windows.Foundation.Uri;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "downloadprogress", listener: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): void;
        removeEventListener(eventName: "downloadprogress", listener: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler): void;
        ondownloadprogress: (ev: Windows.UI.Xaml.Media.Imaging.DownloadProgressEventHandler) => void;
        addEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        removeEventListener(eventName: "imagefailed", listener: Windows.UI.Xaml.ExceptionRoutedEventHandler): void;
        onimagefailed: (ev: Windows.UI.Xaml.ExceptionRoutedEventHandler) => void;
        addEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        removeEventListener(eventName: "imageopened", listener: Windows.UI.Xaml.RoutedEventHandler): void;
        onimageopened: (ev: Windows.UI.Xaml.RoutedEventHandler) => void;

    }

    export interface IBitmapSource {
        setSource(streamSource: Windows.Storage.Streams.IRandomAccessStream): void;
        setSourceAsync(streamSource: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        pixelHeight: number;
        pixelWidth: number;
    }

    export interface IDownloadProgressEventArgs {
        progress: number;
    }

    export interface ISurfaceImageSource {
    }

    export interface IVirtualSurfaceImageSource {
    }

    export interface IWriteableBitmap {
        invalidate(): void;
        pixelBuffer: Windows.Storage.Streams.IBuffer;
    }

    export class SurfaceImageSource implements Windows.UI.Xaml.Media.Imaging.ISurfaceImageSource {
        constructor(pixelWidth: number, pixelHeight: number);
        constructor(pixelWidth: number, pixelHeight: number, isOpaque: boolean);
    }

    export class VirtualSurfaceImageSource implements Windows.UI.Xaml.Media.Imaging.IVirtualSurfaceImageSource {
        constructor(pixelWidth: number, pixelHeight: number);
        constructor(pixelWidth: number, pixelHeight: number, isOpaque: boolean);
    }

    export class WriteableBitmap implements Windows.UI.Xaml.Media.Imaging.IWriteableBitmap {
        constructor(pixelWidth: number, pixelHeight: number);
        invalidate(): void;
        pixelBuffer: Windows.Storage.Streams.IBuffer;
    }

}
declare module Windows.UI.Xaml.Media.Media3D {

    export interface IMatrix3DHelper {
    }

    export class Matrix3D {
        m11: number;
        m12: number;
        m13: number;
        m14: number;
        m21: number;
        m22: number;
        m23: number;
        m24: number;
        m31: number;
        m32: number;
        m33: number;
        m34: number;
        offsetX: number;
        offsetY: number;
        offsetZ: number;
        m44: number;
    }

    export class Matrix3DHelper implements Windows.UI.Xaml.Media.Media3D.IMatrix3DHelper {
        static multiply(matrix1: Windows.UI.Xaml.Media.Media3D.Matrix3D, matrix2: Windows.UI.Xaml.Media.Media3D.Matrix3D): Windows.UI.Xaml.Media.Media3D.Matrix3D;
        static fromElements(m11: number, m12: number, m13: number, m14: number, m21: number, m22: number, m23: number, m24: number, m31: number, m32: number, m33: number, m34: number, offsetX: number, offsetY: number, offsetZ: number, m44: number): Windows.UI.Xaml.Media.Media3D.Matrix3D;
        static getHasInverse(target: Windows.UI.Xaml.Media.Media3D.Matrix3D): boolean;
        static getIsIdentity(target: Windows.UI.Xaml.Media.Media3D.Matrix3D): boolean;
        static invert(target: Windows.UI.Xaml.Media.Media3D.Matrix3D): Windows.UI.Xaml.Media.Media3D.Matrix3D;
        static identity: Windows.UI.Xaml.Media.Media3D.Matrix3D;
    }

}
declare module Windows.UI.Xaml.Navigation {

    export interface INavigatingCancelEventArgs {
        cancel: boolean;
        navigationMode: Windows.UI.Xaml.Navigation.NavigationMode;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface INavigationEventArgs {
        content: any;
        navigationMode: Windows.UI.Xaml.Navigation.NavigationMode;
        parameter: any;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
        uri: Windows.Foundation.Uri;
    }

    export interface INavigationFailedEventArgs {
        exception: Windows.Foundation.HResult;
        handled: boolean;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface LoadCompletedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface NavigatedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class NavigatingCancelEventArgs implements Windows.UI.Xaml.Navigation.INavigatingCancelEventArgs {
        cancel: boolean;
        navigationMode: Windows.UI.Xaml.Navigation.NavigationMode;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface NavigatingCancelEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum NavigationCacheMode {
        disabled,
        required,
        enabled
    }

    export class NavigationEventArgs implements Windows.UI.Xaml.Navigation.INavigationEventArgs {
        content: any;
        navigationMode: Windows.UI.Xaml.Navigation.NavigationMode;
        parameter: any;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
        uri: Windows.Foundation.Uri;
    }

    export class NavigationFailedEventArgs implements Windows.UI.Xaml.Navigation.INavigationFailedEventArgs {
        exception: Windows.Foundation.HResult;
        handled: boolean;
        sourcePageType: Windows.UI.Xaml.Interop.TypeName;
    }

    export interface NavigationFailedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum NavigationMode {
        new,
        back,
        forward,
        refresh
    }

    export interface NavigationStoppedEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

}
declare module Windows.UI.Xaml.Printing {

    export class AddPagesEventArgs implements Windows.UI.Xaml.Printing.IAddPagesEventArgs {
        constructor();
        printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions;
    }

    export interface AddPagesEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export class GetPreviewPageEventArgs implements Windows.UI.Xaml.Printing.IGetPreviewPageEventArgs {
        constructor();
        pageNumber: number;
    }

    export interface GetPreviewPageEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface IAddPagesEventArgs {
        printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions;
    }

    export interface IGetPreviewPageEventArgs {
        pageNumber: number;
    }

    export interface IPaginateEventArgs {
        currentPreviewPageNumber: number;
        printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions;
    }

    export interface IPrintDocument {
        add_Paginate(value: Windows.UI.Xaml.Printing.PaginateEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Paginate(token: Windows.Foundation.EventRegistrationToken): void;
        add_GetPreviewPage(value: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_GetPreviewPage(token: Windows.Foundation.EventRegistrationToken): void;
        add_AddPages(value: Windows.UI.Xaml.Printing.AddPagesEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AddPages(token: Windows.Foundation.EventRegistrationToken): void;
        addPage(pageVisual: Windows.UI.Xaml.UIElement): void;
        addPagesComplete(): void;
        setPreviewPageCount(count: number, type: Windows.UI.Xaml.Printing.PreviewPageCountType): void;
        setPreviewPage(pageNumber: number, pageVisual: Windows.UI.Xaml.UIElement): void;
        invalidatePreview(): void;
        documentSource: Windows.Graphics.Printing.IPrintDocumentSource;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "addpages", listener: Windows.UI.Xaml.Printing.AddPagesEventHandler): void;
        removeEventListener(eventName: "addpages", listener: Windows.UI.Xaml.Printing.AddPagesEventHandler): void;
        onaddpages: (ev: Windows.UI.Xaml.Printing.AddPagesEventHandler) => void;
        addEventListener(eventName: "getpreviewpage", listener: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): void;
        removeEventListener(eventName: "getpreviewpage", listener: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): void;
        ongetpreviewpage: (ev: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler) => void;
        addEventListener(eventName: "paginate", listener: Windows.UI.Xaml.Printing.PaginateEventHandler): void;
        removeEventListener(eventName: "paginate", listener: Windows.UI.Xaml.Printing.PaginateEventHandler): void;
        onpaginate: (ev: Windows.UI.Xaml.Printing.PaginateEventHandler) => void;

    }

    export class PaginateEventArgs implements Windows.UI.Xaml.Printing.IPaginateEventArgs {
        constructor();
        currentPreviewPageNumber: number;
        printTaskOptions: Windows.Graphics.Printing.PrintTaskOptions;
    }

    export interface PaginateEventHandler {
        target: any;
        detail: any[];
        type: string;
    }

    enum PreviewPageCountType {
        final,
        intermediate
    }

    export class PrintDocument implements Windows.UI.Xaml.Printing.IPrintDocument {
        constructor();
        add_Paginate(value: Windows.UI.Xaml.Printing.PaginateEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_Paginate(token: Windows.Foundation.EventRegistrationToken): void;
        add_GetPreviewPage(value: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_GetPreviewPage(token: Windows.Foundation.EventRegistrationToken): void;
        add_AddPages(value: Windows.UI.Xaml.Printing.AddPagesEventHandler): Windows.Foundation.EventRegistrationToken;
        remove_AddPages(token: Windows.Foundation.EventRegistrationToken): void;
        addPage(pageVisual: Windows.UI.Xaml.UIElement): void;
        addPagesComplete(): void;
        setPreviewPageCount(count: number, type: Windows.UI.Xaml.Printing.PreviewPageCountType): void;
        setPreviewPage(pageNumber: number, pageVisual: Windows.UI.Xaml.UIElement): void;
        invalidatePreview(): void;
        documentSource: Windows.Graphics.Printing.IPrintDocumentSource;
        static documentSourceProperty: Windows.UI.Xaml.DependencyProperty;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "addpages", listener: Windows.UI.Xaml.Printing.AddPagesEventHandler): void;
        removeEventListener(eventName: "addpages", listener: Windows.UI.Xaml.Printing.AddPagesEventHandler): void;
        onaddpages: (ev: Windows.UI.Xaml.Printing.AddPagesEventHandler) => void;
        addEventListener(eventName: "getpreviewpage", listener: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): void;
        removeEventListener(eventName: "getpreviewpage", listener: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler): void;
        ongetpreviewpage: (ev: Windows.UI.Xaml.Printing.GetPreviewPageEventHandler) => void;
        addEventListener(eventName: "paginate", listener: Windows.UI.Xaml.Printing.PaginateEventHandler): void;
        removeEventListener(eventName: "paginate", listener: Windows.UI.Xaml.Printing.PaginateEventHandler): void;
        onpaginate: (ev: Windows.UI.Xaml.Printing.PaginateEventHandler) => void;

    }

}
declare module Windows.UI.Xaml.Resources {

    export class CustomXamlResourceLoader implements Windows.UI.Xaml.Resources.ICustomXamlResourceLoader, Windows.UI.Xaml.Resources.ICustomXamlResourceLoaderOverrides {
        constructor();
        getResource(resourceId: string, objectType: string, propertyName: string, propertyType: string): any;
        static current: Windows.UI.Xaml.Resources.CustomXamlResourceLoader;
    }

    export interface ICustomXamlResourceLoader {
    }

    export interface ICustomXamlResourceLoaderOverrides {
        getResource(resourceId: string, objectType: string, propertyName: string, propertyType: string): any;
    }

}
declare module Windows.UI.Xaml.Shapes {

    export class Ellipse implements Windows.UI.Xaml.Shapes.IEllipse {
        constructor();
    }

    export interface IEllipse {
    }

    export interface ILine {
        x1: number;
        x2: number;
        y1: number;
        y2: number;
    }

    export interface IPath {
        data: Windows.UI.Xaml.Media.Geometry;
    }

    export interface IPolygon {
        fillRule: Windows.UI.Xaml.Media.FillRule;
        points: Windows.UI.Xaml.Media.PointCollection;
    }

    export interface IPolyline {
        fillRule: Windows.UI.Xaml.Media.FillRule;
        points: Windows.UI.Xaml.Media.PointCollection;
    }

    export interface IRectangle {
        radiusX: number;
        radiusY: number;
    }

    export interface IShape {
        fill: Windows.UI.Xaml.Media.Brush;
        geometryTransform: Windows.UI.Xaml.Media.Transform;
        stretch: Windows.UI.Xaml.Media.Stretch;
        stroke: Windows.UI.Xaml.Media.Brush;
        strokeDashArray: Windows.UI.Xaml.Media.DoubleCollection;
        strokeDashCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeDashOffset: number;
        strokeEndLineCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeLineJoin: Windows.UI.Xaml.Media.PenLineJoin;
        strokeMiterLimit: number;
        strokeStartLineCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeThickness: number;
    }

    export class Line implements Windows.UI.Xaml.Shapes.ILine {
        constructor();
        x1: number;
        x2: number;
        y1: number;
        y2: number;
        static x1Property: Windows.UI.Xaml.DependencyProperty;
        static x2Property: Windows.UI.Xaml.DependencyProperty;
        static y1Property: Windows.UI.Xaml.DependencyProperty;
        static y2Property: Windows.UI.Xaml.DependencyProperty;
    }

    export class Path implements Windows.UI.Xaml.Shapes.IPath {
        constructor();
        data: Windows.UI.Xaml.Media.Geometry;
        static dataProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Polygon implements Windows.UI.Xaml.Shapes.IPolygon {
        constructor();
        fillRule: Windows.UI.Xaml.Media.FillRule;
        points: Windows.UI.Xaml.Media.PointCollection;
        static fillRuleProperty: Windows.UI.Xaml.DependencyProperty;
        static pointsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Polyline implements Windows.UI.Xaml.Shapes.IPolyline {
        constructor();
        fillRule: Windows.UI.Xaml.Media.FillRule;
        points: Windows.UI.Xaml.Media.PointCollection;
        static fillRuleProperty: Windows.UI.Xaml.DependencyProperty;
        static pointsProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Rectangle implements Windows.UI.Xaml.Shapes.IRectangle {
        constructor();
        radiusX: number;
        radiusY: number;
        static radiusXProperty: Windows.UI.Xaml.DependencyProperty;
        static radiusYProperty: Windows.UI.Xaml.DependencyProperty;
    }

    export class Shape implements Windows.UI.Xaml.Shapes.IShape {
        constructor();
        fill: Windows.UI.Xaml.Media.Brush;
        geometryTransform: Windows.UI.Xaml.Media.Transform;
        stretch: Windows.UI.Xaml.Media.Stretch;
        stroke: Windows.UI.Xaml.Media.Brush;
        strokeDashArray: Windows.UI.Xaml.Media.DoubleCollection;
        strokeDashCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeDashOffset: number;
        strokeEndLineCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeLineJoin: Windows.UI.Xaml.Media.PenLineJoin;
        strokeMiterLimit: number;
        strokeStartLineCap: Windows.UI.Xaml.Media.PenLineCap;
        strokeThickness: number;
        static fillProperty: Windows.UI.Xaml.DependencyProperty;
        static stretchProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeDashArrayProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeDashCapProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeDashOffsetProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeEndLineCapProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeLineJoinProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeMiterLimitProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeStartLineCapProperty: Windows.UI.Xaml.DependencyProperty;
        static strokeThicknessProperty: Windows.UI.Xaml.DependencyProperty;
    }

}
declare module Windows.Web.AtomPub {

    export class AtomPubClient implements Windows.Web.AtomPub.IAtomPubClient, Windows.Web.Syndication.ISyndicationClient {
        constructor(serverCredential: Windows.Security.Credentials.PasswordCredential);
        constructor();
        retrieveServiceDocumentAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.AtomPub.ServiceDocument,Windows.Web.Syndication.RetrievalProgress>;
        retrieveMediaResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream,Windows.Web.Syndication.RetrievalProgress>;
        retrieveResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.RetrievalProgress>;
        createResourceAsync(uri: Windows.Foundation.Uri, description: string, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        createMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, description: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        updateMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceAsync(uri: Windows.Foundation.Uri, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        cancelAsyncOperations(): void;
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export interface IAtomPubClient extends Windows.Web.Syndication.ISyndicationClient {
        retrieveServiceDocumentAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.AtomPub.ServiceDocument,Windows.Web.Syndication.RetrievalProgress>;
        retrieveMediaResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Storage.Streams.IInputStream,Windows.Web.Syndication.RetrievalProgress>;
        retrieveResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.RetrievalProgress>;
        createResourceAsync(uri: Windows.Foundation.Uri, description: string, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        createMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, description: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationItem,Windows.Web.Syndication.TransferProgress>;
        updateMediaResourceAsync(uri: Windows.Foundation.Uri, mediaType: string, mediaStream: Windows.Storage.Streams.IInputStream): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceAsync(uri: Windows.Foundation.Uri, item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        updateResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        deleteResourceItemAsync(item: Windows.Web.Syndication.SyndicationItem): Windows.Foundation.IAsyncActionWithProgress<Windows.Web.Syndication.TransferProgress>;
        cancelAsyncOperations(): void;
    }

    export interface IResourceCollection extends Windows.Web.Syndication.ISyndicationNode {
        accepts: Windows.Foundation.Collections.IVectorView<string>;
        categories: Windows.Foundation.Collections.IVectorView<Windows.Web.Syndication.SyndicationCategory>;
        title: Windows.Web.Syndication.ISyndicationText;
        uri: Windows.Foundation.Uri;
    }

    export interface IServiceDocument extends Windows.Web.Syndication.ISyndicationNode {
        workspaces: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.Workspace>;
    }

    export interface IWorkspace extends Windows.Web.Syndication.ISyndicationNode {
        collections: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.ResourceCollection>;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export class ResourceCollection implements Windows.Web.AtomPub.IResourceCollection, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        accepts: Windows.Foundation.Collections.IVectorView<string>;
        categories: Windows.Foundation.Collections.IVectorView<Windows.Web.Syndication.SyndicationCategory>;
        title: Windows.Web.Syndication.ISyndicationText;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class ServiceDocument implements Windows.Web.AtomPub.IServiceDocument, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        workspaces: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.Workspace>;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class Workspace implements Windows.Web.AtomPub.IWorkspace, Windows.Web.Syndication.ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        collections: Windows.Foundation.Collections.IVectorView<Windows.Web.AtomPub.ResourceCollection>;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

}
declare module Windows.Web.Syndication {

    export interface ISyndicationAttribute {
        name: string;
        namespace: string;
        value: string;
    }

    export interface ISyndicationCategory extends Windows.Web.Syndication.ISyndicationNode {
        label: string;
        scheme: string;
        term: string;
    }

    export interface ISyndicationClient {
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export interface ISyndicationContent extends Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode {
        sourceUri: Windows.Foundation.Uri;
    }

    export interface ISyndicationFeed extends Windows.Web.Syndication.ISyndicationNode {
        load(feed: string): void;
        loadFromXml(feedDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        firstUri: Windows.Foundation.Uri;
        generator: Windows.Web.Syndication.SyndicationGenerator;
        iconUri: Windows.Foundation.Uri;
        id: string;
        imageUri: Windows.Foundation.Uri;
        items: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationItem>;
        lastUpdatedTime: Date;
        lastUri: Windows.Foundation.Uri;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        nextUri: Windows.Foundation.Uri;
        previousUri: Windows.Foundation.Uri;
        rights: Windows.Web.Syndication.ISyndicationText;
        sourceFormat: Windows.Web.Syndication.SyndicationFormat;
        subtitle: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export interface ISyndicationGenerator {
        text: string;
        uri: Windows.Foundation.Uri;
        version: string;
    }

    export interface ISyndicationItem extends Windows.Web.Syndication.ISyndicationNode {
        load(item: string): void;
        loadFromXml(itemDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        commentsUri: Windows.Foundation.Uri;
        content: Windows.Web.Syndication.SyndicationContent;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        eTag: string;
        editMediaUri: Windows.Foundation.Uri;
        editUri: Windows.Foundation.Uri;
        id: string;
        itemUri: Windows.Foundation.Uri;
        lastUpdatedTime: Date;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        publishedDate: Date;
        rights: Windows.Web.Syndication.ISyndicationText;
        source: Windows.Web.Syndication.SyndicationFeed;
        summary: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
    }

    export interface ISyndicationLink extends Windows.Web.Syndication.ISyndicationNode {
        length: number;
        mediaType: string;
        relationship: string;
        resourceLanguage: string;
        title: string;
        uri: Windows.Foundation.Uri;
    }

    export interface ISyndicationNode {
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export interface ISyndicationPerson extends Windows.Web.Syndication.ISyndicationNode {
        email: string;
        name: string;
        uri: Windows.Foundation.Uri;
    }

    export interface ISyndicationText extends Windows.Web.Syndication.ISyndicationNode {
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
    }

    export class RetrievalProgress {
        bytesRetrieved: number;
        totalBytesToRetrieve: number;
    }

    export class SyndicationAttribute implements Windows.Web.Syndication.ISyndicationAttribute {
        constructor(attributeName: string, attributeNamespace: string, attributeValue: string);
        constructor();
        name: string;
        namespace: string;
        value: string;
    }

    export class SyndicationCategory implements Windows.Web.Syndication.ISyndicationCategory, Windows.Web.Syndication.ISyndicationNode {
        constructor(term: string);
        constructor(term: string, scheme: string, label: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        label: string;
        scheme: string;
        term: string;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationClient implements Windows.Web.Syndication.ISyndicationClient {
        constructor(serverCredential: Windows.Security.Credentials.PasswordCredential);
        constructor();
        setRequestHeader(name: string, value: string): void;
        retrieveFeedAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperationWithProgress<Windows.Web.Syndication.SyndicationFeed,Windows.Web.Syndication.RetrievalProgress>;
        bypassCacheOnRetrieve: boolean;
        maxResponseBufferSize: number;
        proxyCredential: Windows.Security.Credentials.PasswordCredential;
        serverCredential: Windows.Security.Credentials.PasswordCredential;
        timeout: number;
    }

    export class SyndicationContent implements Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode, Windows.Web.Syndication.ISyndicationContent {
        constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType);
        constructor(sourceUri: Windows.Foundation.Uri);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
        sourceUri: Windows.Foundation.Uri;
    }

    export class SyndicationError {
        static getStatus(hresult: number): Windows.Web.Syndication.SyndicationErrorStatus;
    }

    enum SyndicationErrorStatus {
        unknown,
        missingRequiredElement,
        missingRequiredAttribute,
        invalidXml,
        unexpectedContent,
        unsupportedFormat
    }

    export class SyndicationFeed implements Windows.Web.Syndication.ISyndicationFeed, Windows.Web.Syndication.ISyndicationNode {
        constructor(title: string, subtitle: string, uri: Windows.Foundation.Uri);
        constructor();
        load(feed: string): void;
        loadFromXml(feedDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        firstUri: Windows.Foundation.Uri;
        generator: Windows.Web.Syndication.SyndicationGenerator;
        iconUri: Windows.Foundation.Uri;
        id: string;
        imageUri: Windows.Foundation.Uri;
        items: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationItem>;
        lastUpdatedTime: Date;
        lastUri: Windows.Foundation.Uri;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        nextUri: Windows.Foundation.Uri;
        previousUri: Windows.Foundation.Uri;
        rights: Windows.Web.Syndication.ISyndicationText;
        sourceFormat: Windows.Web.Syndication.SyndicationFormat;
        subtitle: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    enum SyndicationFormat {
        atom10,
        rss20,
        rss10,
        rss092,
        rss091,
        atom03
    }

    export class SyndicationGenerator implements Windows.Web.Syndication.ISyndicationGenerator, Windows.Web.Syndication.ISyndicationNode {
        constructor(text: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        uri: Windows.Foundation.Uri;
        version: string;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationItem implements Windows.Web.Syndication.ISyndicationItem, Windows.Web.Syndication.ISyndicationNode {
        constructor(title: string, content: Windows.Web.Syndication.SyndicationContent, uri: Windows.Foundation.Uri);
        constructor();
        load(item: string): void;
        loadFromXml(itemDocument: Windows.Data.Xml.Dom.XmlDocument): void;
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        authors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        categories: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationCategory>;
        commentsUri: Windows.Foundation.Uri;
        content: Windows.Web.Syndication.SyndicationContent;
        contributors: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationPerson>;
        eTag: string;
        editMediaUri: Windows.Foundation.Uri;
        editUri: Windows.Foundation.Uri;
        id: string;
        itemUri: Windows.Foundation.Uri;
        lastUpdatedTime: Date;
        links: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationLink>;
        publishedDate: Date;
        rights: Windows.Web.Syndication.ISyndicationText;
        source: Windows.Web.Syndication.SyndicationFeed;
        summary: Windows.Web.Syndication.ISyndicationText;
        title: Windows.Web.Syndication.ISyndicationText;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationLink implements Windows.Web.Syndication.ISyndicationLink, Windows.Web.Syndication.ISyndicationNode {
        constructor(uri: Windows.Foundation.Uri);
        constructor(uri: Windows.Foundation.Uri, relationship: string, title: string, mediaType: string, length: number);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        length: number;
        mediaType: string;
        relationship: string;
        resourceLanguage: string;
        title: string;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationNode implements Windows.Web.Syndication.ISyndicationNode {
        constructor(nodeName: string, nodeNamespace: string, nodeValue: string);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationPerson implements Windows.Web.Syndication.ISyndicationPerson, Windows.Web.Syndication.ISyndicationNode {
        constructor(name: string);
        constructor(name: string, email: string, uri: Windows.Foundation.Uri);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        email: string;
        name: string;
        uri: Windows.Foundation.Uri;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    export class SyndicationText implements Windows.Web.Syndication.ISyndicationText, Windows.Web.Syndication.ISyndicationNode {
        constructor(text: string);
        constructor(text: string, type: Windows.Web.Syndication.SyndicationTextType);
        constructor();
        getXmlDocument(format: Windows.Web.Syndication.SyndicationFormat): Windows.Data.Xml.Dom.XmlDocument;
        text: string;
        type: string;
        xml: Windows.Data.Xml.Dom.XmlDocument;
        attributeExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.SyndicationAttribute>;
        baseUri: Windows.Foundation.Uri;
        elementExtensions: Windows.Foundation.Collections.IVector<Windows.Web.Syndication.ISyndicationNode>;
        language: string;
        nodeName: string;
        nodeNamespace: string;
        nodeValue: string;
    }

    enum SyndicationTextType {
        text,
        html,
        xhtml
    }

    export class TransferProgress {
        bytesSent: number;
        totalBytesToSend: number;
        bytesRetrieved: number;
        totalBytesToRetrieve: number;
    }

}
declare module Windows.Web {

    export class WebError {
        static getStatus(hresult: number): Windows.Web.WebErrorStatus;
    }

    enum WebErrorStatus {
        unknown,
        certificateCommonNameIsIncorrect,
        certificateExpired,
        certificateContainsErrors,
        certificateRevoked,
        certificateIsInvalid,
        serverUnreachable,
        timeout,
        errorHttpInvalidServerResponse,
        connectionAborted,
        connectionReset,
        disconnected,
        httpToHttpsOnRedirection,
        httpsToHttpOnRedirection,
        cannotConnect,
        hostNameNotResolved,
        operationCanceled,
        redirectFailed,
        unexpectedStatusCode,
        unexpectedRedirection,
        unexpectedClientError,
        unexpectedServerError,
        multipleChoices,
        movedPermanently,
        found,
        seeOther,
        notModified,
        useProxy,
        temporaryRedirect,
        badRequest,
        unauthorized,
        paymentRequired,
        forbidden,
        notFound,
        methodNotAllowed,
        notAcceptable,
        proxyAuthenticationRequired,
        requestTimeout,
        conflict,
        gone,
        lengthRequired,
        preconditionFailed,
        requestEntityTooLarge,
        requestUriTooLong,
        unsupportedMediaType,
        requestedRangeNotSatisfiable,
        expectationFailed,
        internalServerError,
        notImplemented,
        badGateway,
        serviceUnavailable,
        gatewayTimeout,
        httpVersionNotSupported
    }

}

