//****************************************************************
//  Generated by:  ToTypeScriptD
//  Website:       http://github.com/ToTypeScriptD/ToTypeScriptD
//  Version:       v0.0.0000.0000 SHA1:0000000 - Debug
//  Date:          mm/dd/YYYY H:MM:SS PM
//
//  Assemblies:
//    Windows.Foundation.winmd
//    Windows.System.winmd
//
//****************************************************************



declare module Windows.Foundation {

    export interface AsyncActionCompletedHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    export interface AsyncActionProgressHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncActionWithProgressCompletedHandler<TProgress> {
        target: Windows.Foundation.IAsyncActionWithProgress<TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationCompletedHandler<TResult> {
        target: Windows.Foundation.IAsyncOperation<TResult>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationProgressHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    export interface AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
        target: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>;
        detail: any[];
        type: string;
    }

    enum AsyncStatus {
        started,
        completed,
        canceled,
        error
    }

    export class DateTime {
        universalTime: number;
    }

    export class Deferral implements Windows.Foundation.IDeferral, Windows.Foundation.IClosable {
        constructor(handler: Windows.Foundation.DeferralCompletedHandler);
        complete(): void;
        close(): void;
    }

    export interface DeferralCompletedHandler {
        target: any;
        detail: any[];
        type: string;
    }

    export interface EventHandler<T> {
        target: any;
        detail: any[];
        type: string;
    }

    export class EventRegistrationToken {
        value: number;
    }

    export class FoundationContract {
    }

    export class HResult {
        value: number;
    }

    export interface IAsyncAction extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        completed: Windows.Foundation.AsyncActionCompletedHandler;
    }

    export interface IAsyncActionWithProgress<TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): void;
        progress: Windows.Foundation.AsyncActionProgressHandler<TProgress>;
        completed: Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>;
    }

    export interface IAsyncInfo {
        cancel(): void;
        close(): void;
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
    }

    export interface IAsyncOperation<TResult> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        completed: Windows.Foundation.AsyncOperationCompletedHandler<TResult>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IAsyncOperationWithProgress<TResult, TProgress> extends Windows.Foundation.IAsyncInfo {
        getResults(): TResult;
        progress: Windows.Foundation.AsyncOperationProgressHandler<TResult,TProgress>;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult,TProgress>;

        // Promise Extension
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => ToTypeScriptD.WinRT.IPromise<U>, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => ToTypeScriptD.WinRT.IPromise<U>, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        then<U>(success?: (value: TResult) => U, error?: (error: any) => U, progress?: (progress: any) => void): ToTypeScriptD.WinRT.IPromise<U>;
        done<U>(success?: (value: TResult) => any, error?: (error: any) => any, progress?: (progress: any) => void): void;
    }

    export interface IClosable {
        close(): void;
    }

    export interface IDeferral extends Windows.Foundation.IClosable {
        complete(): void;
    }

    export interface IGetActivationFactory {
        getActivationFactory(activatableClassId: string): any;
    }

    export interface IMemoryBuffer extends Windows.Foundation.IClosable {
        createReference(): Windows.Foundation.IMemoryBufferReference;
    }

    export interface IMemoryBufferReference extends Windows.Foundation.IClosable {
        capacity: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.IMemoryBufferReference,any>): void;
        removeEventListener(eventName: "closed", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.IMemoryBufferReference,any>): void;
        onclosed: (ev: Windows.Foundation.TypedEventHandler<Windows.Foundation.IMemoryBufferReference,any>) => void;

    }

    export interface IPropertyValue {
        getUInt8(): number;
        getInt16(): number;
        getUInt16(): number;
        getInt32(): number;
        getUInt32(): number;
        getInt64(): number;
        getUInt64(): number;
        getSingle(): number;
        getDouble(): number;
        getChar16(): number;
        getBoolean(): boolean;
        getString(): string;
        getGuid(): string;
        getDateTime(): Date;
        getTimeSpan(): Windows.Foundation.TimeSpan;
        getPoint(): Windows.Foundation.Point;
        getSize(): Windows.Foundation.Size;
        getRect(): Windows.Foundation.Rect;
        getUInt8Array(): IPropertyValue_getUInt8Array_OUT_1;
        getInt16Array(): IPropertyValue_getInt16Array_OUT_2;
        getUInt16Array(): IPropertyValue_getUInt16Array_OUT_3;
        getInt32Array(): IPropertyValue_getInt32Array_OUT_4;
        getUInt32Array(): IPropertyValue_getUInt32Array_OUT_5;
        getInt64Array(): IPropertyValue_getInt64Array_OUT_6;
        getUInt64Array(): IPropertyValue_getUInt64Array_OUT_7;
        getSingleArray(): IPropertyValue_getSingleArray_OUT_8;
        getDoubleArray(): IPropertyValue_getDoubleArray_OUT_9;
        getChar16Array(): IPropertyValue_getChar16Array_OUT_10;
        getBooleanArray(): IPropertyValue_getBooleanArray_OUT_11;
        getStringArray(): IPropertyValue_getStringArray_OUT_12;
        getInspectableArray(): IPropertyValue_getInspectableArray_OUT_13;
        getGuidArray(): IPropertyValue_getGuidArray_OUT_14;
        getDateTimeArray(): IPropertyValue_getDateTimeArray_OUT_15;
        getTimeSpanArray(): IPropertyValue_getTimeSpanArray_OUT_16;
        getPointArray(): IPropertyValue_getPointArray_OUT_17;
        getSizeArray(): IPropertyValue_getSizeArray_OUT_18;
        getRectArray(): IPropertyValue_getRectArray_OUT_19;
        isNumericScalar: boolean;
        type: Windows.Foundation.PropertyType;
    }

    interface IPropertyValue_getUInt8Array_OUT_1 {
        value: number[];
    }

    interface IPropertyValue_getInt16Array_OUT_2 {
        value: number[];
    }

    interface IPropertyValue_getUInt16Array_OUT_3 {
        value: number[];
    }

    interface IPropertyValue_getInt32Array_OUT_4 {
        value: number[];
    }

    interface IPropertyValue_getUInt32Array_OUT_5 {
        value: number[];
    }

    interface IPropertyValue_getInt64Array_OUT_6 {
        value: number[];
    }

    interface IPropertyValue_getUInt64Array_OUT_7 {
        value: number[];
    }

    interface IPropertyValue_getSingleArray_OUT_8 {
        value: number[];
    }

    interface IPropertyValue_getDoubleArray_OUT_9 {
        value: number[];
    }

    interface IPropertyValue_getChar16Array_OUT_10 {
        value: number[];
    }

    interface IPropertyValue_getBooleanArray_OUT_11 {
        value: boolean[];
    }

    interface IPropertyValue_getStringArray_OUT_12 {
        value: string[];
    }

    interface IPropertyValue_getInspectableArray_OUT_13 {
        value: any[];
    }

    interface IPropertyValue_getGuidArray_OUT_14 {
        value: string[];
    }

    interface IPropertyValue_getDateTimeArray_OUT_15 {
        value: Date[];
    }

    interface IPropertyValue_getTimeSpanArray_OUT_16 {
        value: Windows.Foundation.TimeSpan[];
    }

    interface IPropertyValue_getPointArray_OUT_17 {
        value: Windows.Foundation.Point[];
    }

    interface IPropertyValue_getSizeArray_OUT_18 {
        value: Windows.Foundation.Size[];
    }

    interface IPropertyValue_getRectArray_OUT_19 {
        value: Windows.Foundation.Rect[];
    }

    export interface IReference<T> extends Windows.Foundation.IPropertyValue {
        value: T;
    }

    export interface IReferenceArray<T> extends Windows.Foundation.IPropertyValue {
        value: T[];
    }

    export interface IStringable {
        toString(): string;
    }

    export interface IUriRuntimeClass {
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
    }

    export interface IUriRuntimeClassWithAbsoluteCanonicalUri {
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export interface IWwwFormUrlDecoderEntry {
        name: string;
        value: string;
    }

    export interface IWwwFormUrlDecoderRuntimeClass extends Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        getFirstValueByName(name: string): string;

        // Array.prototype extensions
        toString(): string;
        toLocaleString(): string;
        concat(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[][]): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        join(seperator: string): string;
        pop(): Windows.Foundation.IWwwFormUrlDecoderEntry;
        push(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): void;
        reverse(): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        shift(): Windows.Foundation.IWwwFormUrlDecoderEntry;
        slice(start: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        slice(start: number, end: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        sort(): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        sort(compareFn: (a: Windows.Foundation.IWwwFormUrlDecoderEntry, b: Windows.Foundation.IWwwFormUrlDecoderEntry) => number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        splice(start: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        splice(start: number, deleteCount: number, ...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        unshift(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): number;
        lastIndexOf(searchElement: Windows.Foundation.IWwwFormUrlDecoderEntry): number;
        lastIndexOf(searchElement: Windows.Foundation.IWwwFormUrlDecoderEntry, fromIndex: number): number;
        every(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
        every(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
        some(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => void ): void;
        forEach(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => void , thisArg: any): void;
        map(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any[];
        map(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        filter(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, initialValue: any): any;
        length: number;
    }

    export class MemoryBuffer implements Windows.Foundation.IMemoryBuffer, Windows.Foundation.IClosable {
        constructor(capacity: number);
        createReference(): Windows.Foundation.IMemoryBufferReference;
        close(): void;
    }

    export class Point {
        x: number;
        y: number;
    }

    enum PropertyType {
        empty,
        uInt8,
        int16,
        uInt16,
        int32,
        uInt32,
        int64,
        uInt64,
        single,
        double,
        char16,
        boolean,
        string,
        inspectable,
        dateTime,
        timeSpan,
        guid,
        point,
        size,
        rect,
        otherType,
        uInt8Array,
        int16Array,
        uInt16Array,
        int32Array,
        uInt32Array,
        int64Array,
        uInt64Array,
        singleArray,
        doubleArray,
        char16Array,
        booleanArray,
        stringArray,
        inspectableArray,
        dateTimeArray,
        timeSpanArray,
        guidArray,
        pointArray,
        sizeArray,
        rectArray,
        otherTypeArray
    }

    export class PropertyValue {
        static createEmpty(): any;
        static createUInt8(value: number): any;
        static createInt16(value: number): any;
        static createUInt16(value: number): any;
        static createInt32(value: number): any;
        static createUInt32(value: number): any;
        static createInt64(value: number): any;
        static createUInt64(value: number): any;
        static createSingle(value: number): any;
        static createDouble(value: number): any;
        static createChar16(value: number): any;
        static createBoolean(value: boolean): any;
        static createString(value: string): any;
        static createInspectable(value: any): any;
        static createGuid(value: string): any;
        static createDateTime(value: Date): any;
        static createTimeSpan(value: Windows.Foundation.TimeSpan): any;
        static createPoint(value: Windows.Foundation.Point): any;
        static createSize(value: Windows.Foundation.Size): any;
        static createRect(value: Windows.Foundation.Rect): any;
        static createUInt8Array(value: any): any;
        static createInt16Array(value: number[]): any;
        static createUInt16Array(value: number[]): any;
        static createInt32Array(value: number[]): any;
        static createUInt32Array(value: number[]): any;
        static createInt64Array(value: number[]): any;
        static createUInt64Array(value: number[]): any;
        static createSingleArray(value: number[]): any;
        static createDoubleArray(value: number[]): any;
        static createChar16Array(value: number[]): any;
        static createBooleanArray(value: boolean[]): any;
        static createStringArray(value: string[]): any;
        static createInspectableArray(value: any[]): any;
        static createGuidArray(value: string[]): any;
        static createDateTimeArray(value: Date[]): any;
        static createTimeSpanArray(value: Windows.Foundation.TimeSpan[]): any;
        static createPointArray(value: Windows.Foundation.Point[]): any;
        static createSizeArray(value: Windows.Foundation.Size[]): any;
        static createRectArray(value: Windows.Foundation.Rect[]): any;
    }

    export class Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class Size {
        width: number;
        height: number;
    }

    export class TimeSpan {
        duration: number;
    }

    export interface TypedEventHandler<TSender, TResult> {
        target: TSender;
        detail: any[];
        type: string;
    }

    export class UniversalApiContract {
    }

    export class Uri implements Windows.Foundation.IUriRuntimeClass, Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri, Windows.Foundation.IStringable {
        constructor(uri: string);
        constructor(baseUri: string, relativeUri: string);
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        toString(): string;
        static unescapeComponent(toUnescape: string): string;
        static escapeComponent(toEscape: string): string;
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export class WwwFormUrlDecoder implements Windows.Foundation.IWwwFormUrlDecoderRuntimeClass, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        constructor(query: string);
        getFirstValueByName(name: string): string;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.IWwwFormUrlDecoderEntry>;
        getAt(index: number): Windows.Foundation.IWwwFormUrlDecoderEntry;
        indexOf(value: Windows.Foundation.IWwwFormUrlDecoderEntry): WwwFormUrlDecoder_indexOf_OUT_20;
        getMany(startIndex: number): WwwFormUrlDecoder_getMany_OUT_21;
        size: number;

        // Array.prototype extensions
        toString(): string;
        toLocaleString(): string;
        concat(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[][]): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        join(seperator: string): string;
        pop(): Windows.Foundation.IWwwFormUrlDecoderEntry;
        push(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): void;
        reverse(): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        shift(): Windows.Foundation.IWwwFormUrlDecoderEntry;
        slice(start: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        slice(start: number, end: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        sort(): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        sort(compareFn: (a: Windows.Foundation.IWwwFormUrlDecoderEntry, b: Windows.Foundation.IWwwFormUrlDecoderEntry) => number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        splice(start: number): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        splice(start: number, deleteCount: number, ...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        unshift(...items: Windows.Foundation.IWwwFormUrlDecoderEntry[]): number;
        lastIndexOf(searchElement: Windows.Foundation.IWwwFormUrlDecoderEntry): number;
        lastIndexOf(searchElement: Windows.Foundation.IWwwFormUrlDecoderEntry, fromIndex: number): number;
        every(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
        every(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): boolean;
        some(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => void ): void;
        forEach(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => void , thisArg: any): void;
        map(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any[];
        map(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        filter(callbackfn: (value: Windows.Foundation.IWwwFormUrlDecoderEntry, index: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => boolean, thisArg: any): Windows.Foundation.IWwwFormUrlDecoderEntry[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: Windows.Foundation.IWwwFormUrlDecoderEntry[]) => any, initialValue: any): any;
        length: number;
    }

    interface WwwFormUrlDecoder_indexOf_OUT_20 {
        __returnValue: boolean;
        index: number;
    }

    interface WwwFormUrlDecoder_getMany_OUT_21 {
        __returnValue: number;
        items: Windows.Foundation.IWwwFormUrlDecoderEntry[];
    }

    export class WwwFormUrlDecoderEntry implements Windows.Foundation.IWwwFormUrlDecoderEntry {
        name: string;
        value: string;
    }

}
declare module Windows.Foundation.Collections {

    enum CollectionChange {
        reset,
        itemInserted,
        itemRemoved,
        itemChanged
    }

    export interface IIterable<T> {
        first(): Windows.Foundation.Collections.IIterator<T>;
    }

    export interface IIterator<T> {
        moveNext(): boolean;
        getMany(): IIterator_getMany_OUT_22<T>;
        current: T;
        hasCurrent: boolean;
    }

    interface IIterator_getMany_OUT_22<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IKeyValuePair<K, V> {
        key: K;
        value: V;
    }

    export interface IMap<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        getView(): Windows.Foundation.Collections.IMapView<K,V>;
        insert(key: K, value: V): boolean;
        remove(key: K): void;
        clear(): void;
        size: number;
    }

    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }

    export interface IMapView<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        lookup(key: K): V;
        hasKey(key: K): boolean;
        split(): IMapView_split_OUT_23<K, V>;
        size: number;
    }

    interface IMapView_split_OUT_23<K, V> {
        first: Windows.Foundation.Collections.IMapView<K,V>;
        second: Windows.Foundation.Collections.IMapView<K,V>;
    }

    export interface IObservableMap<K, V> extends Windows.Foundation.Collections.IMap<K,V> {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<K,V>) => void;

    }

    export interface IObservableVector<T> extends Windows.Foundation.Collections.IVector<T> {
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        removeEventListener(eventName: "vectorchanged", listener: Windows.Foundation.Collections.VectorChangedEventHandler<T>): void;
        onvectorchanged: (ev: Windows.Foundation.Collections.VectorChangedEventHandler<T>) => void;


        // Array.prototype extensions
        toString(): string;
        toLocaleString(): string;
        concat(...items: T[][]): T[];
        join(seperator: string): string;
        pop(): T;
        push(...items: T[]): void;
        reverse(): T[];
        shift(): T;
        slice(start: number): T[];
        slice(start: number, end: number): T[];
        sort(): T[];
        sort(compareFn: (a: T, b: T) => number): T[];
        splice(start: number): T[];
        splice(start: number, deleteCount: number, ...items: T[]): T[];
        unshift(...items: T[]): number;
        lastIndexOf(searchElement: T): number;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void ): void;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void , thisArg: any): void;
        map(callbackfn: (value: T, index: number, array: T[]) => any): any[];
        map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): T[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        length: number;
    }

    export interface IPropertySet extends Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
    }

    export interface IVector<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        getView(): Windows.Foundation.Collections.IVectorView<T>;
        indexOf(value: T): IVector_indexOf_OUT_24<T>;
        setAt(index: number, value: T): void;
        insertAt(index: number, value: T): void;
        removeAt(index: number): void;
        append(value: T): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): IVector_getMany_OUT_25<T>;
        replaceAll(items: T[]): void;
        size: number;

        // Array.prototype extensions
        toString(): string;
        toLocaleString(): string;
        concat(...items: T[][]): T[];
        join(seperator: string): string;
        pop(): T;
        push(...items: T[]): void;
        reverse(): T[];
        shift(): T;
        slice(start: number): T[];
        slice(start: number, end: number): T[];
        sort(): T[];
        sort(compareFn: (a: T, b: T) => number): T[];
        splice(start: number): T[];
        splice(start: number, deleteCount: number, ...items: T[]): T[];
        unshift(...items: T[]): number;
        lastIndexOf(searchElement: T): number;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void ): void;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void , thisArg: any): void;
        map(callbackfn: (value: T, index: number, array: T[]) => any): any[];
        map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): T[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        length: number;
    }

    interface IVector_indexOf_OUT_24<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVector_getMany_OUT_25<T> {
        __returnValue: number;
        items: T[];
    }

    export interface IVectorChangedEventArgs {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        index: number;
    }

    export interface IVectorView<T> extends Windows.Foundation.Collections.IIterable<T> {
        getAt(index: number): T;
        indexOf(value: T): IVectorView_indexOf_OUT_26<T>;
        getMany(startIndex: number): IVectorView_getMany_OUT_27<T>;
        size: number;

        // Array.prototype extensions
        toString(): string;
        toLocaleString(): string;
        concat(...items: T[][]): T[];
        join(seperator: string): string;
        pop(): T;
        push(...items: T[]): void;
        reverse(): T[];
        shift(): T;
        slice(start: number): T[];
        slice(start: number, end: number): T[];
        sort(): T[];
        sort(compareFn: (a: T, b: T) => number): T[];
        splice(start: number): T[];
        splice(start: number, deleteCount: number, ...items: T[]): T[];
        unshift(...items: T[]): number;
        lastIndexOf(searchElement: T): number;
        lastIndexOf(searchElement: T, fromIndex: number): number;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean): boolean;
        some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): boolean;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void ): void;
        forEach(callbackfn: (value: T, index: number, array: T[]) => void , thisArg: any): void;
        map(callbackfn: (value: T, index: number, array: T[]) => any): any[];
        map(callbackfn: (value: T, index: number, array: T[]) => any, thisArg: any): any[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean): T[];
        filter(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg: any): T[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: T[]) => any, initialValue: any): any;
        length: number;
    }

    interface IVectorView_indexOf_OUT_26<T> {
        __returnValue: boolean;
        index: number;
    }

    interface IVectorView_getMany_OUT_27<T> {
        __returnValue: number;
        items: T[];
    }

    export interface MapChangedEventHandler<K, V> {
        target: Windows.Foundation.Collections.IObservableMap<K,V>;
        detail: any[];
        type: string;
    }

    export class PropertySet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export class StringMap implements Windows.Foundation.Collections.IMap<string,string>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,string>>, Windows.Foundation.Collections.IObservableMap<string,string> {
        constructor();
        lookup(key: string): string;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,string>;
        insert(key: string, value: string): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,string>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,string>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,string>) => void;

    }

    export class ValueSet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        constructor();
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        size: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        removeEventListener(eventName: "mapchanged", listener: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): void;
        onmapchanged: (ev: Windows.Foundation.Collections.MapChangedEventHandler<string,any>) => void;

    }

    export interface VectorChangedEventHandler<T> {
        target: Windows.Foundation.Collections.IObservableVector<T>;
        detail: any[];
        type: string;
    }

}
declare module Windows.Foundation.Diagnostics {

    export class AsyncCausalityTracer {
        static traceOperationCreation(traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, operationName: string, relatedContext: number): void;
        static traceOperationCompletion(traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, status: Windows.Foundation.AsyncStatus): void;
        static traceOperationRelation(traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, relation: Windows.Foundation.Diagnostics.CausalityRelation): void;
        static traceSynchronousWorkStart(traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, platformId: string, operationId: number, work: Windows.Foundation.Diagnostics.CausalitySynchronousWork): void;
        static traceSynchronousWorkCompletion(traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel, source: Windows.Foundation.Diagnostics.CausalitySource, work: Windows.Foundation.Diagnostics.CausalitySynchronousWork): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "tracingstatuschanged", listener: Windows.Foundation.EventHandler<Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs>): void;
        removeEventListener(eventName: "tracingstatuschanged", listener: Windows.Foundation.EventHandler<Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs>): void;
        ontracingstatuschanged: (ev: Windows.Foundation.EventHandler<Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs>) => void;

    }

    enum CausalityRelation {
        assignDelegate,
        join,
        choice,
        cancel,
        error
    }

    enum CausalitySource {
        application,
        library,
        system
    }

    enum CausalitySynchronousWork {
        completionNotification,
        progressNotification,
        execution
    }

    enum CausalityTraceLevel {
        required,
        important,
        verbose
    }

    export class ErrorDetails implements Windows.Foundation.Diagnostics.IErrorDetails {
        static createFromHResultAsync(errorCode: number): Windows.Foundation.IAsyncOperation<Windows.Foundation.Diagnostics.ErrorDetails>;
        description: string;
        helpUri: Windows.Foundation.Uri;
        longDescription: string;
    }

    enum ErrorOptions {
        none,
        suppressExceptions,
        forceExceptions,
        useSetErrorInfo,
        suppressSetErrorInfo
    }

    export class FileLoggingSession implements Windows.Foundation.Diagnostics.IFileLoggingSession, Windows.Foundation.IClosable {
        constructor(name: string);
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel): void;
        removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        closeAndSaveToFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        close(): void;
        name: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>): void;
        removeEventListener(eventName: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>): void;
        onlogfilegenerated: (ev: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>) => void;

    }

    export interface IErrorDetails {
        description: string;
        helpUri: Windows.Foundation.Uri;
        longDescription: string;
    }

    export interface IErrorReportingSettings {
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

    export interface IFileLoggingSession extends Windows.Foundation.IClosable {
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel): void;
        removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        closeAndSaveToFileAsync(): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        name: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>): void;
        removeEventListener(eventName: "logfilegenerated", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>): void;
        onlogfilegenerated: (ev: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.IFileLoggingSession,Windows.Foundation.Diagnostics.LogFileGeneratedEventArgs>) => void;

    }

    export interface ILogFileGeneratedEventArgs {
        file: Windows.Storage.StorageFile;
    }

    export interface ILoggingActivity extends Windows.Foundation.IClosable {
        id: string;
        name: string;
    }

    export interface ILoggingActivity2 extends Windows.Foundation.Diagnostics.ILoggingActivity, Windows.Foundation.IClosable, Windows.Foundation.Diagnostics.ILoggingTarget {
        stopActivity(stopEventName: string): void;
        stopActivity(stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
        stopActivity(stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, options: Windows.Foundation.Diagnostics.LoggingOptions): void;
        channel: Windows.Foundation.Diagnostics.LoggingChannel;
    }

    export interface ILoggingChannel extends Windows.Foundation.IClosable {
        logMessage(eventString: string): void;
        logMessage(eventString: string, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        logValuePair(value1: string, value2: number): void;
        logValuePair(value1: string, value2: number, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        enabled: boolean;
        level: Windows.Foundation.Diagnostics.LoggingLevel;
        name: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>): void;
        removeEventListener(eventName: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>): void;
        onloggingenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>) => void;

    }

    export interface ILoggingChannel2 extends Windows.Foundation.Diagnostics.ILoggingChannel, Windows.Foundation.IClosable, Windows.Foundation.Diagnostics.ILoggingTarget {
        id: string;
    }

    export interface ILoggingChannelOptions {
        group: string;
    }

    export interface ILoggingFields {
        clear(): void;
        beginStruct(name: string): void;
        beginStruct(name: string, tags: number): void;
        endStruct(): void;
        addEmpty(name: string): void;
        addEmpty(name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addEmpty(name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt8(name: string, value: number): void;
        addUInt8(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt8(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt8Array(name: string, value: any): void;
        addUInt8Array(name: string, value: any, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt8Array(name: string, value: any, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt16(name: string, value: number): void;
        addInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt16Array(name: string, value: number[]): void;
        addInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt16(name: string, value: number): void;
        addUInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt16Array(name: string, value: number[]): void;
        addUInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt32(name: string, value: number): void;
        addInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt32Array(name: string, value: number[]): void;
        addInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt32(name: string, value: number): void;
        addUInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt32Array(name: string, value: number[]): void;
        addUInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt64(name: string, value: number): void;
        addInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt64Array(name: string, value: number[]): void;
        addInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt64(name: string, value: number): void;
        addUInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt64Array(name: string, value: number[]): void;
        addUInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSingle(name: string, value: number): void;
        addSingle(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSingle(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSingleArray(name: string, value: number[]): void;
        addSingleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSingleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDouble(name: string, value: number): void;
        addDouble(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDouble(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDoubleArray(name: string, value: number[]): void;
        addDoubleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDoubleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addChar16(name: string, value: number): void;
        addChar16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addChar16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addChar16Array(name: string, value: number[]): void;
        addChar16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addChar16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addBoolean(name: string, value: boolean): void;
        addBoolean(name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addBoolean(name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addBooleanArray(name: string, value: boolean[]): void;
        addBooleanArray(name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addBooleanArray(name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addString(name: string, value: string): void;
        addString(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addString(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addStringArray(name: string, value: string[]): void;
        addStringArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addStringArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addGuid(name: string, value: string): void;
        addGuid(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addGuid(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addGuidArray(name: string, value: string[]): void;
        addGuidArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addGuidArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDateTime(name: string, value: Date): void;
        addDateTime(name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDateTime(name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDateTimeArray(name: string, value: Date[]): void;
        addDateTimeArray(name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDateTimeArray(name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[]): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addPoint(name: string, value: Windows.Foundation.Point): void;
        addPoint(name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addPoint(name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addPointArray(name: string, value: Windows.Foundation.Point[]): void;
        addPointArray(name: string, value: Windows.Foundation.Point[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addPointArray(name: string, value: Windows.Foundation.Point[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSize(name: string, value: Windows.Foundation.Size): void;
        addSize(name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSize(name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[]): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addRect(name: string, value: Windows.Foundation.Rect): void;
        addRect(name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addRect(name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[]): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
    }

    export interface ILoggingOptions {
        activityId: string;
        keywords: number;
        opcode: Windows.Foundation.Diagnostics.LoggingOpcode;
        relatedActivityId: string;
        tags: number;
        task: number;
    }

    export interface ILoggingSession extends Windows.Foundation.IClosable {
        saveToFileAsync(folder: Windows.Storage.IStorageFolder, fileName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel): void;
        removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        name: string;
    }

    export interface ILoggingTarget {
        isEnabled(): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel, keywords: number): boolean;
        logEvent(eventName: string): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): void;
        startActivity(startEventName: string): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): Windows.Foundation.Diagnostics.LoggingActivity;
    }

    export interface ITracingStatusChangedEventArgs {
        enabled: boolean;
        traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel;
    }

    export class LogFileGeneratedEventArgs implements Windows.Foundation.Diagnostics.ILogFileGeneratedEventArgs {
        file: Windows.Storage.StorageFile;
    }

    export class LoggingActivity implements Windows.Foundation.Diagnostics.ILoggingActivity, Windows.Foundation.IClosable, Windows.Foundation.Diagnostics.ILoggingActivity2, Windows.Foundation.Diagnostics.ILoggingTarget {
        constructor(activityName: string, loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel);
        constructor(activityName: string, loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, level: Windows.Foundation.Diagnostics.LoggingLevel);
        close(): void;
        stopActivity(stopEventName: string): void;
        stopActivity(stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
        stopActivity(stopEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, options: Windows.Foundation.Diagnostics.LoggingOptions): void;
        isEnabled(): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel, keywords: number): boolean;
        logEvent(eventName: string): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): void;
        startActivity(startEventName: string): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): Windows.Foundation.Diagnostics.LoggingActivity;
        id: string;
        name: string;
        channel: Windows.Foundation.Diagnostics.LoggingChannel;
    }

    export class LoggingChannel implements Windows.Foundation.Diagnostics.ILoggingChannel, Windows.Foundation.IClosable, Windows.Foundation.Diagnostics.ILoggingChannel2, Windows.Foundation.Diagnostics.ILoggingTarget {
        constructor(name: string, options: Windows.Foundation.Diagnostics.LoggingChannelOptions);
        constructor(name: string, options: Windows.Foundation.Diagnostics.LoggingChannelOptions, id: string);
        constructor(name: string);
        logMessage(eventString: string): void;
        logMessage(eventString: string, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        logValuePair(value1: string, value2: number): void;
        logValuePair(value1: string, value2: number, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        close(): void;
        isEnabled(): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel): boolean;
        isEnabled(level: Windows.Foundation.Diagnostics.LoggingLevel, keywords: number): boolean;
        logEvent(eventName: string): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): void;
        logEvent(eventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): void;
        startActivity(startEventName: string): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel): Windows.Foundation.Diagnostics.LoggingActivity;
        startActivity(startEventName: string, fields: Windows.Foundation.Diagnostics.LoggingFields, level: Windows.Foundation.Diagnostics.LoggingLevel, options: Windows.Foundation.Diagnostics.LoggingOptions): Windows.Foundation.Diagnostics.LoggingActivity;
        enabled: boolean;
        level: Windows.Foundation.Diagnostics.LoggingLevel;
        name: string;
        id: string;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>): void;
        removeEventListener(eventName: "loggingenabled", listener: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>): void;
        onloggingenabled: (ev: Windows.Foundation.TypedEventHandler<Windows.Foundation.Diagnostics.ILoggingChannel,any>) => void;

    }

    export class LoggingChannelOptions implements Windows.Foundation.Diagnostics.ILoggingChannelOptions {
        constructor();
        constructor(group: string);
        group: string;
    }

    enum LoggingFieldFormat {
        default,
        hidden,
        string,
        boolean,
        hexadecimal,
        processId,
        threadId,
        port,
        ipv4Address,
        ipv6Address,
        socketAddress,
        xml,
        json,
        win32Error,
        ntStatus,
        hResult,
        fileTime,
        signed,
        unsigned
    }

    export class LoggingFields implements Windows.Foundation.Diagnostics.ILoggingFields {
        constructor();
        clear(): void;
        beginStruct(name: string): void;
        beginStruct(name: string, tags: number): void;
        endStruct(): void;
        addEmpty(name: string): void;
        addEmpty(name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addEmpty(name: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt8(name: string, value: number): void;
        addUInt8(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt8(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt8Array(name: string, value: any): void;
        addUInt8Array(name: string, value: any, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt8Array(name: string, value: any, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt16(name: string, value: number): void;
        addInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt16Array(name: string, value: number[]): void;
        addInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt16(name: string, value: number): void;
        addUInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt16Array(name: string, value: number[]): void;
        addUInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt32(name: string, value: number): void;
        addInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt32Array(name: string, value: number[]): void;
        addInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt32(name: string, value: number): void;
        addUInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt32(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt32Array(name: string, value: number[]): void;
        addUInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt32Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt64(name: string, value: number): void;
        addInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addInt64Array(name: string, value: number[]): void;
        addInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt64(name: string, value: number): void;
        addUInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt64(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addUInt64Array(name: string, value: number[]): void;
        addUInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addUInt64Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSingle(name: string, value: number): void;
        addSingle(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSingle(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSingleArray(name: string, value: number[]): void;
        addSingleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSingleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDouble(name: string, value: number): void;
        addDouble(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDouble(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDoubleArray(name: string, value: number[]): void;
        addDoubleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDoubleArray(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addChar16(name: string, value: number): void;
        addChar16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addChar16(name: string, value: number, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addChar16Array(name: string, value: number[]): void;
        addChar16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addChar16Array(name: string, value: number[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addBoolean(name: string, value: boolean): void;
        addBoolean(name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addBoolean(name: string, value: boolean, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addBooleanArray(name: string, value: boolean[]): void;
        addBooleanArray(name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addBooleanArray(name: string, value: boolean[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addString(name: string, value: string): void;
        addString(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addString(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addStringArray(name: string, value: string[]): void;
        addStringArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addStringArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addGuid(name: string, value: string): void;
        addGuid(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addGuid(name: string, value: string, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addGuidArray(name: string, value: string[]): void;
        addGuidArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addGuidArray(name: string, value: string[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDateTime(name: string, value: Date): void;
        addDateTime(name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDateTime(name: string, value: Date, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addDateTimeArray(name: string, value: Date[]): void;
        addDateTimeArray(name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addDateTimeArray(name: string, value: Date[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addTimeSpan(name: string, value: Windows.Foundation.TimeSpan, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[]): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addTimeSpanArray(name: string, value: Windows.Foundation.TimeSpan[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addPoint(name: string, value: Windows.Foundation.Point): void;
        addPoint(name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addPoint(name: string, value: Windows.Foundation.Point, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addPointArray(name: string, value: Windows.Foundation.Point[]): void;
        addPointArray(name: string, value: Windows.Foundation.Point[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addPointArray(name: string, value: Windows.Foundation.Point[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSize(name: string, value: Windows.Foundation.Size): void;
        addSize(name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSize(name: string, value: Windows.Foundation.Size, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[]): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addSizeArray(name: string, value: Windows.Foundation.Size[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addRect(name: string, value: Windows.Foundation.Rect): void;
        addRect(name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addRect(name: string, value: Windows.Foundation.Rect, format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[]): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat): void;
        addRectArray(name: string, value: Windows.Foundation.Rect[], format: Windows.Foundation.Diagnostics.LoggingFieldFormat, tags: number): void;
    }

    enum LoggingLevel {
        verbose,
        information,
        warning,
        error,
        critical
    }

    enum LoggingOpcode {
        info,
        start,
        stop,
        reply,
        resume,
        suspend,
        send
    }

    export class LoggingOptions implements Windows.Foundation.Diagnostics.ILoggingOptions {
        constructor();
        constructor(keywords: number);
        task: number;
        tags: number;
        relatedActivityId: string;
        opcode: Windows.Foundation.Diagnostics.LoggingOpcode;
        keywords: number;
        activityId: string;
    }

    export class LoggingSession implements Windows.Foundation.Diagnostics.ILoggingSession, Windows.Foundation.IClosable {
        constructor(name: string);
        saveToFileAsync(folder: Windows.Storage.IStorageFolder, fileName: string): Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile>;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        addLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel, maxLevel: Windows.Foundation.Diagnostics.LoggingLevel): void;
        removeLoggingChannel(loggingChannel: Windows.Foundation.Diagnostics.ILoggingChannel): void;
        close(): void;
        name: string;
    }

    export class RuntimeBrokerErrorSettings implements Windows.Foundation.Diagnostics.IErrorReportingSettings {
        constructor();
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

    export class TracingStatusChangedEventArgs implements Windows.Foundation.Diagnostics.ITracingStatusChangedEventArgs {
        enabled: boolean;
        traceLevel: Windows.Foundation.Diagnostics.CausalityTraceLevel;
    }

}
declare module Windows.Foundation.Metadata {

    export class ActivatableAttribute {
        constructor(version: number);
        constructor(version: number, type: string);
        constructor(version: number, platform: Windows.Foundation.Metadata.Platform);
        constructor(type: string /*System.Type?*/, version: number);
        constructor(type: string /*System.Type?*/, version: number, contractName: string);
        constructor(type: string /*System.Type?*/, version: number, platform: Windows.Foundation.Metadata.Platform);
    }

    export class AllowForWebAttribute {
        constructor();
    }

    export class AllowMultipleAttribute {
        constructor();
    }

    export class ApiContractAttribute {
        constructor();
    }

    export class ApiInformation {
        static isTypePresent(typeName: string): boolean;
        static isMethodPresent(typeName: string, methodName: string): boolean;
        static isMethodPresent(typeName: string, methodName: string, inputParameterCount: number): boolean;
        static isEventPresent(typeName: string, eventName: string): boolean;
        static isPropertyPresent(typeName: string, propertyName: string): boolean;
        static isReadOnlyPropertyPresent(typeName: string, propertyName: string): boolean;
        static isWriteablePropertyPresent(typeName: string, propertyName: string): boolean;
        static isEnumNamedValuePresent(enumTypeName: string, valueName: string): boolean;
        static isApiContractPresent(contractName: string, majorVersion: number): boolean;
        static isApiContractPresent(contractName: string, majorVersion: number, minorVersion: number): boolean;
    }

    enum AttributeTargets {
        delegate,
        enum,
        event,
        field,
        interface,
        method,
        parameter,
        property,
        runtimeClass,
        struct,
        interfaceImpl,
        apiContract,
        all
    }

    export class AttributeUsageAttribute {
        constructor(A_0: Windows.Foundation.Metadata.AttributeTargets);
    }

    export class ComposableAttribute {
        constructor(type: string /*System.Type?*/, compositionType: Windows.Foundation.Metadata.CompositionType, version: number);
        constructor(type: string /*System.Type?*/, compositionType: Windows.Foundation.Metadata.CompositionType, version: number, platform: Windows.Foundation.Metadata.Platform);
        constructor(type: string /*System.Type?*/, compositionType: Windows.Foundation.Metadata.CompositionType, version: number, contract: string);
    }

    enum CompositionType {
        protected,
        public
    }

    export class ContractVersionAttribute {
        constructor(version: number);
        constructor(contract: string /*System.Type?*/, version: number);
        constructor(contract: string, version: number);
    }

    export class CreateFromStringAttribute {
        constructor();
        methodName: string;
    }

    export class DefaultAttribute {
        constructor();
    }

    export class DefaultOverloadAttribute {
        constructor();
    }

    export class DeprecatedAttribute {
        constructor(message: string, type: Windows.Foundation.Metadata.DeprecationType, version: number);
        constructor(message: string, type: Windows.Foundation.Metadata.DeprecationType, version: number, platform: Windows.Foundation.Metadata.Platform);
        constructor(message: string, type: Windows.Foundation.Metadata.DeprecationType, version: number, contract: string);
    }

    enum DeprecationType {
        deprecate,
        remove
    }

    export class DualApiPartitionAttribute {
        constructor();
        version: number;
    }

    export class ExclusiveToAttribute {
        constructor(typeName: string /*System.Type?*/);
    }

    export class ExperimentalAttribute {
        constructor();
    }

    enum GCPressureAmount {
        low,
        medium,
        high
    }

    export class GCPressureAttribute {
        constructor();
        amount: Windows.Foundation.Metadata.GCPressureAmount;
    }

    export class GuidAttribute {
        constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number);
    }

    export class HasVariantAttribute {
        constructor();
    }

    export class InternalAttribute {
        constructor();
    }

    export class LengthIsAttribute {
        constructor(indexLengthParameter: number);
    }

    export class MarshalingBehaviorAttribute {
        constructor(behavior: Windows.Foundation.Metadata.MarshalingType);
    }

    enum MarshalingType {
        invalidMarshaling,
        none,
        agile,
        standard
    }

    export class MetadataMarshalAttribute {
        constructor();
    }

    export class MuseAttribute {
        constructor();
        version: number;
    }

    export class OverloadAttribute {
        constructor(method: string);
    }

    export class OverridableAttribute {
        constructor();
    }

    enum Platform {
        windows,
        windowsPhone
    }

    export class PlatformAttribute {
        constructor(platform: Windows.Foundation.Metadata.Platform);
    }

    export class PreviousContractVersionAttribute {
        constructor(contract: string, versionLow: number, versionHigh: number, newContract: string);
        constructor(contract: string, versionLow: number, versionHigh: number);
    }

    export class ProtectedAttribute {
        constructor();
    }

    export class RangeAttribute {
        constructor(minValue: number, maxValue: number);
    }

    export class RemoteAsyncAttribute {
        constructor();
    }

    export class StaticAttribute {
        constructor(type: string /*System.Type?*/, version: number);
        constructor(type: string /*System.Type?*/, version: number, platform: Windows.Foundation.Metadata.Platform);
        constructor(type: string /*System.Type?*/, version: number, contractName: string);
    }

    export class ThreadingAttribute {
        constructor(model: Windows.Foundation.Metadata.ThreadingModel);
    }

    enum ThreadingModel {
        invalidThreading,
        sta,
        mta,
        both
    }

    export class VariantAttribute {
        constructor();
    }

    export class VersionAttribute {
        constructor(version: number);
        constructor(version: number, platform: Windows.Foundation.Metadata.Platform);
    }

    export class WebHostHiddenAttribute {
        constructor();
    }

}
declare module Windows.Foundation.Numerics {

    export class Matrix3x2 {
        m11: number;
        m12: number;
        m21: number;
        m22: number;
        m31: number;
        m32: number;
    }

    export class Matrix4x4 {
        m11: number;
        m12: number;
        m13: number;
        m14: number;
        m21: number;
        m22: number;
        m23: number;
        m24: number;
        m31: number;
        m32: number;
        m33: number;
        m34: number;
        m41: number;
        m42: number;
        m43: number;
        m44: number;
    }

    export class Plane {
        normal: Windows.Foundation.Numerics.Vector3;
        d: number;
    }

    export class Quaternion {
        x: number;
        y: number;
        z: number;
        w: number;
    }

    export class Vector2 {
        x: number;
        y: number;
    }

    export class Vector3 {
        x: number;
        y: number;
        z: number;
    }

    export class Vector4 {
        x: number;
        y: number;
        z: number;
        w: number;
    }

}
declare module Windows.System {

    export class AppMemoryReport implements Windows.System.IAppMemoryReport {
        peakPrivateCommitUsage: number;
        privateCommitUsage: number;
        totalCommitLimit: number;
        totalCommitUsage: number;
    }

    enum AppMemoryUsageLevel {
        low,
        medium,
        high,
        overLimit
    }

    export class AppMemoryUsageLimitChangingEventArgs implements Windows.System.IAppMemoryUsageLimitChangingEventArgs {
        newLimit: number;
        oldLimit: number;
    }

    export class FolderLauncherOptions implements Windows.System.IFolderLauncherOptions, Windows.System.ILauncherViewOptions {
        constructor();
        itemsToSelect: Windows.Foundation.Collections.IVector<Windows.Storage.IStorageItem>;
        desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference;
    }

    export interface IAppMemoryReport {
        peakPrivateCommitUsage: number;
        privateCommitUsage: number;
        totalCommitLimit: number;
        totalCommitUsage: number;
    }

    export interface IAppMemoryUsageLimitChangingEventArgs {
        newLimit: number;
        oldLimit: number;
    }

    export interface IFolderLauncherOptions {
        itemsToSelect: Windows.Foundation.Collections.IVector<Windows.Storage.IStorageItem>;
    }

    export interface ILauncherOptions {
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export interface ILauncherOptions2 {
        neighboringFilesQuery: Windows.Storage.Search.StorageFileQueryResult;
        targetApplicationPackageFamilyName: string;
    }

    export interface ILauncherOptions3 {
        ignoreAppUriHandlers: boolean;
    }

    export interface ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    export interface ILauncherViewOptions {
        desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference;
    }

    export interface ILaunchUriResult {
        result: Windows.Foundation.Collections.ValueSet;
        status: Windows.System.LaunchUriStatus;
    }

    export interface IProcessLauncherOptions {
        standardError: Windows.Storage.Streams.IOutputStream;
        standardInput: Windows.Storage.Streams.IInputStream;
        standardOutput: Windows.Storage.Streams.IOutputStream;
        workingDirectory: string;
    }

    export interface IProcessLauncherResult {
        exitCode: number;
    }

    export interface IProcessMemoryReport {
        privateWorkingSetUsage: number;
        totalWorkingSetUsage: number;
    }

    export interface IProtocolForResultsOperation {
        reportCompleted(data: Windows.Foundation.Collections.ValueSet): void;
    }

    export interface IRemoteLauncherOptions {
        fallbackUri: Windows.Foundation.Uri;
        preferredAppIds: Windows.Foundation.Collections.IVector<string>;
    }

    export interface IUser {
        getPropertyAsync(value: string): Windows.Foundation.IAsyncOperation<any>;
        getPropertiesAsync(values: Windows.Foundation.Collections.IVectorView<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IPropertySet>;
        getPictureAsync(desiredSize: Windows.System.UserPictureSize): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamReference>;
        authenticationStatus: Windows.System.UserAuthenticationStatus;
        nonRoamableId: string;
        type: Windows.System.UserType;
    }

    export interface IUserAuthenticationStatusChangeDeferral {
        complete(): void;
    }

    export interface IUserAuthenticationStatusChangingEventArgs {
        getDeferral(): Windows.System.UserAuthenticationStatusChangeDeferral;
        currentStatus: Windows.System.UserAuthenticationStatus;
        newStatus: Windows.System.UserAuthenticationStatus;
        user: Windows.System.User;
    }

    export interface IUserChangedEventArgs {
        user: Windows.System.User;
    }

    export interface IUserDeviceAssociationChangedEventArgs {
        deviceId: string;
        newUser: Windows.System.User;
        oldUser: Windows.System.User;
    }

    export interface IUserPicker {
        pickSingleUserAsync(): Windows.Foundation.IAsyncOperation<Windows.System.User>;
        allowGuestAccounts: boolean;
        suggestedSelectedUser: Windows.System.User;
    }

    export interface IUserWatcher {
        start(): void;
        stop(): void;
        status: Windows.System.UserWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onauthenticationstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>): void;
        removeEventListener(eventName: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>): void;
        onauthenticationstatuschanging: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;

    }

    export class KnownUserProperties {
        static accountName: string;
        static displayName: string;
        static domainName: string;
        static firstName: string;
        static guestHost: string;
        static lastName: string;
        static principalName: string;
        static providerName: string;
        static sessionInitiationProtocolUri: string;
    }

    export class Launcher {
        static queryAppUriSupportAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static queryAppUriSupportAsync(uri: Windows.Foundation.Uri, packageFamilyName: string): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static findAppUriHandlersAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
        static launchUriForUserAsync(user: Windows.System.User, uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriStatus>;
        static launchUriForUserAsync(user: Windows.System.User, uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriStatus>;
        static launchUriForUserAsync(user: Windows.System.User, uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriStatus>;
        static launchUriForResultsForUserAsync(user: Windows.System.User, uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriResult>;
        static launchUriForResultsForUserAsync(user: Windows.System.User, uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriResult>;
        static launchFolderAsync(folder: Windows.Storage.IStorageFolder): Windows.Foundation.IAsyncOperation<boolean>;
        static launchFolderAsync(folder: Windows.Storage.IStorageFolder, options: Windows.System.FolderLauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriForResultsAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriResult>;
        static launchUriForResultsAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet): Windows.Foundation.IAsyncOperation<Windows.System.LaunchUriResult>;
        static launchUriAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions, inputData: Windows.Foundation.Collections.ValueSet): Windows.Foundation.IAsyncOperation<boolean>;
        static queryUriSupportAsync(uri: Windows.Foundation.Uri, launchQuerySupportType: Windows.System.LaunchQuerySupportType): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static queryUriSupportAsync(uri: Windows.Foundation.Uri, launchQuerySupportType: Windows.System.LaunchQuerySupportType, packageFamilyName: string): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static queryFileSupportAsync(file: Windows.Storage.StorageFile): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static queryFileSupportAsync(file: Windows.Storage.StorageFile, packageFamilyName: string): Windows.Foundation.IAsyncOperation<Windows.System.LaunchQuerySupportStatus>;
        static findUriSchemeHandlersAsync(scheme: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
        static findUriSchemeHandlersAsync(scheme: string, launchQuerySupportType: Windows.System.LaunchQuerySupportType): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
        static findFileHandlersAsync(extension: string): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.ApplicationModel.AppInfo>>;
        static launchFileAsync(file: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        static launchFileAsync(file: Windows.Storage.IStorageFile, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export class LauncherOptions implements Windows.System.ILauncherOptions, Windows.System.ILauncherViewOptions, Windows.System.ILauncherOptions2, Windows.System.ILauncherOptions3 {
        constructor();
        treatAsUntrusted: boolean;
        preferredApplicationPackageFamilyName: string;
        preferredApplicationDisplayName: string;
        fallbackUri: Windows.Foundation.Uri;
        displayApplicationPicker: boolean;
        contentType: string;
        ui: Windows.System.LauncherUIOptions;
        targetApplicationPackageFamilyName: string;
        neighboringFilesQuery: Windows.Storage.Search.StorageFileQueryResult;
        ignoreAppUriHandlers: boolean;
        desiredRemainingView: Windows.UI.ViewManagement.ViewSizePreference;
    }

    export class LauncherUIOptions implements Windows.System.ILauncherUIOptions {
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
        preferredPlacement: Windows.UI.Popups.Placement;
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
    }

    enum LaunchFileStatus {
        success,
        appUnavailable,
        deniedByPolicy,
        fileTypeNotSupported,
        unknown
    }

    enum LaunchQuerySupportStatus {
        available,
        appNotInstalled,
        appUnavailable,
        notSupported,
        unknown
    }

    enum LaunchQuerySupportType {
        uri,
        uriForResults
    }

    export class LaunchUriResult implements Windows.System.ILaunchUriResult {
        result: Windows.Foundation.Collections.ValueSet;
        status: Windows.System.LaunchUriStatus;
    }

    enum LaunchUriStatus {
        success,
        appUnavailable,
        protocolUnavailable,
        unknown
    }

    export class MemoryManager {
        static trySetAppMemoryUsageLimit(value: number): boolean;
        static getAppMemoryReport(): Windows.System.AppMemoryReport;
        static getProcessMemoryReport(): Windows.System.ProcessMemoryReport;
        static appMemoryUsage: number;
        static appMemoryUsageLevel: Windows.System.AppMemoryUsageLevel;
        static appMemoryUsageLimit: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "appmemoryusagedecreased", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "appmemoryusagedecreased", listener: Windows.Foundation.EventHandler<any>): void;
        onappmemoryusagedecreased: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "appmemoryusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "appmemoryusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        onappmemoryusageincreased: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "appmemoryusagelimitchanging", listener: Windows.Foundation.EventHandler<Windows.System.AppMemoryUsageLimitChangingEventArgs>): void;
        removeEventListener(eventName: "appmemoryusagelimitchanging", listener: Windows.Foundation.EventHandler<Windows.System.AppMemoryUsageLimitChangingEventArgs>): void;
        onappmemoryusagelimitchanging: (ev: Windows.Foundation.EventHandler<Windows.System.AppMemoryUsageLimitChangingEventArgs>) => void;

    }

    export class ProcessLauncher {
        static runToCompletionAsync(fileName: string, args: string): Windows.Foundation.IAsyncOperation<Windows.System.ProcessLauncherResult>;
        static runToCompletionAsync(fileName: string, args: string, options: Windows.System.ProcessLauncherOptions): Windows.Foundation.IAsyncOperation<Windows.System.ProcessLauncherResult>;
    }

    export class ProcessLauncherOptions implements Windows.System.IProcessLauncherOptions {
        constructor();
        workingDirectory: string;
        standardOutput: Windows.Storage.Streams.IOutputStream;
        standardInput: Windows.Storage.Streams.IInputStream;
        standardError: Windows.Storage.Streams.IOutputStream;
    }

    export class ProcessLauncherResult implements Windows.System.IProcessLauncherResult {
        exitCode: number;
    }

    export class ProcessMemoryReport implements Windows.System.IProcessMemoryReport {
        privateWorkingSetUsage: number;
        totalWorkingSetUsage: number;
    }

    enum ProcessorArchitecture {
        x86,
        arm,
        x64,
        neutral,
        unknown
    }

    export class ProtocolForResultsOperation implements Windows.System.IProtocolForResultsOperation {
        reportCompleted(data: Windows.Foundation.Collections.ValueSet): void;
    }

    export class RemoteLauncher {
        static launchUriAsync(remoteSystemConnectionRequest: Windows.System.RemoteSystems.RemoteSystemConnectionRequest, uri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.System.RemoteLaunchUriStatus>;
        static launchUriAsync(remoteSystemConnectionRequest: Windows.System.RemoteSystems.RemoteSystemConnectionRequest, uri: Windows.Foundation.Uri, options: Windows.System.RemoteLauncherOptions): Windows.Foundation.IAsyncOperation<Windows.System.RemoteLaunchUriStatus>;
        static launchUriAsync(remoteSystemConnectionRequest: Windows.System.RemoteSystems.RemoteSystemConnectionRequest, uri: Windows.Foundation.Uri, options: Windows.System.RemoteLauncherOptions, inputData: Windows.Foundation.Collections.ValueSet): Windows.Foundation.IAsyncOperation<Windows.System.RemoteLaunchUriStatus>;
    }

    export class RemoteLauncherOptions implements Windows.System.IRemoteLauncherOptions {
        constructor();
        fallbackUri: Windows.Foundation.Uri;
        preferredAppIds: Windows.Foundation.Collections.IVector<string>;
    }

    enum RemoteLaunchUriStatus {
        unknown,
        success,
        appUnavailable,
        protocolUnavailable,
        remoteSystemUnavailable,
        valueSetTooLarge,
        deniedByLocalSystem,
        deniedByRemoteSystem
    }

    enum ShutdownKind {
        shutdown,
        restart
    }

    export class ShutdownManager {
        static beginShutdown(shutdownKind: Windows.System.ShutdownKind, timeout: Windows.Foundation.TimeSpan): void;
        static cancelShutdown(): void;
    }

    export class SystemManagementContract {
    }

    export class TimeZoneSettings {
        static changeTimeZoneByDisplayName(timeZoneDisplayName: string): void;
        static canChangeTimeZone: boolean;
        static currentTimeZoneDisplayName: string;
        static supportedTimeZoneDisplayNames: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class User implements Windows.System.IUser {
        getPropertyAsync(value: string): Windows.Foundation.IAsyncOperation<any>;
        getPropertiesAsync(values: Windows.Foundation.Collections.IVectorView<string>): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IPropertySet>;
        getPictureAsync(desiredSize: Windows.System.UserPictureSize): Windows.Foundation.IAsyncOperation<Windows.Storage.Streams.IRandomAccessStreamReference>;
        static createWatcher(): Windows.System.UserWatcher;
        static findAllAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.System.User>>;
        static findAllAsync(type: Windows.System.UserType): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.System.User>>;
        static findAllAsync(type: Windows.System.UserType, status: Windows.System.UserAuthenticationStatus): Windows.Foundation.IAsyncOperation<Windows.Foundation.Collections.IVectorView<Windows.System.User>>;
        static getFromId(nonRoamableId: string): Windows.System.User;
        authenticationStatus: Windows.System.UserAuthenticationStatus;
        nonRoamableId: string;
        type: Windows.System.UserType;
    }

    enum UserAuthenticationStatus {
        unauthenticated,
        locallyAuthenticated,
        remotelyAuthenticated
    }

    export class UserAuthenticationStatusChangeDeferral implements Windows.System.IUserAuthenticationStatusChangeDeferral {
        complete(): void;
    }

    export class UserAuthenticationStatusChangingEventArgs implements Windows.System.IUserAuthenticationStatusChangingEventArgs {
        getDeferral(): Windows.System.UserAuthenticationStatusChangeDeferral;
        currentStatus: Windows.System.UserAuthenticationStatus;
        newStatus: Windows.System.UserAuthenticationStatus;
        user: Windows.System.User;
    }

    export class UserChangedEventArgs implements Windows.System.IUserChangedEventArgs {
        user: Windows.System.User;
    }

    export class UserDeviceAssociation {
        static findUserFromDeviceId(deviceId: string): Windows.System.User;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "userdeviceassociationchanged", listener: Windows.Foundation.EventHandler<Windows.System.UserDeviceAssociationChangedEventArgs>): void;
        removeEventListener(eventName: "userdeviceassociationchanged", listener: Windows.Foundation.EventHandler<Windows.System.UserDeviceAssociationChangedEventArgs>): void;
        onuserdeviceassociationchanged: (ev: Windows.Foundation.EventHandler<Windows.System.UserDeviceAssociationChangedEventArgs>) => void;

    }

    export class UserDeviceAssociationChangedEventArgs implements Windows.System.IUserDeviceAssociationChangedEventArgs {
        deviceId: string;
        newUser: Windows.System.User;
        oldUser: Windows.System.User;
    }

    export class UserPicker implements Windows.System.IUserPicker {
        constructor();
        pickSingleUserAsync(): Windows.Foundation.IAsyncOperation<Windows.System.User>;
        static isSupported(): boolean;
        suggestedSelectedUser: Windows.System.User;
        allowGuestAccounts: boolean;
    }

    enum UserPictureSize {
        size64x64,
        size208x208,
        size424x424,
        size1080x1080
    }

    enum UserType {
        localUser,
        remoteUser,
        localGuest,
        remoteGuest
    }

    export class UserWatcher implements Windows.System.IUserWatcher {
        start(): void;
        stop(): void;
        status: Windows.System.UserWatcherStatus;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "added", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onadded: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "authenticationstatuschanged", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onauthenticationstatuschanged: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>): void;
        removeEventListener(eventName: "authenticationstatuschanging", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>): void;
        onauthenticationstatuschanging: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserAuthenticationStatusChangingEventArgs>) => void;
        addEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        removeEventListener(eventName: "enumerationcompleted", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        onenumerationcompleted: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>) => void;
        addEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "removed", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;
        addEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        removeEventListener(eventName: "stopped", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>): void;
        onstopped: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,any>) => void;
        addEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        removeEventListener(eventName: "updated", listener: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>): void;
        onupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.System.UserWatcher,Windows.System.UserChangedEventArgs>) => void;

    }

    enum UserWatcherStatus {
        created,
        started,
        enumerationCompleted,
        stopping,
        stopped,
        aborted
    }

    enum VirtualKey {
        none,
        leftButton,
        rightButton,
        cancel,
        middleButton,
        xButton1,
        xButton2,
        back,
        tab,
        clear,
        enter,
        shift,
        control,
        menu,
        pause,
        capitalLock,
        kana,
        hangul,
        junja,
        final,
        hanja,
        kanji,
        escape,
        convert,
        nonConvert,
        accept,
        modeChange,
        space,
        pageUp,
        pageDown,
        end,
        home,
        left,
        up,
        right,
        down,
        select,
        print,
        execute,
        snapshot,
        insert,
        delete,
        help,
        number0,
        number1,
        number2,
        number3,
        number4,
        number5,
        number6,
        number7,
        number8,
        number9,
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z,
        leftWindows,
        rightWindows,
        application,
        sleep,
        numberPad0,
        numberPad1,
        numberPad2,
        numberPad3,
        numberPad4,
        numberPad5,
        numberPad6,
        numberPad7,
        numberPad8,
        numberPad9,
        multiply,
        add,
        separator,
        subtract,
        decimal,
        divide,
        f1,
        f2,
        f3,
        f4,
        f5,
        f6,
        f7,
        f8,
        f9,
        f10,
        f11,
        f12,
        f13,
        f14,
        f15,
        f16,
        f17,
        f18,
        f19,
        f20,
        f21,
        f22,
        f23,
        f24,
        navigationView,
        navigationMenu,
        navigationUp,
        navigationDown,
        navigationLeft,
        navigationRight,
        navigationAccept,
        navigationCancel,
        numberKeyLock,
        scroll,
        leftShift,
        rightShift,
        leftControl,
        rightControl,
        leftMenu,
        rightMenu,
        goBack,
        goForward,
        refresh,
        stop,
        search,
        favorites,
        goHome,
        gamepadA,
        gamepadB,
        gamepadX,
        gamepadY,
        gamepadRightShoulder,
        gamepadLeftShoulder,
        gamepadLeftTrigger,
        gamepadRightTrigger,
        gamepadDPadUp,
        gamepadDPadDown,
        gamepadDPadLeft,
        gamepadDPadRight,
        gamepadMenu,
        gamepadView,
        gamepadLeftThumbstickButton,
        gamepadRightThumbstickButton,
        gamepadLeftThumbstickUp,
        gamepadLeftThumbstickDown,
        gamepadLeftThumbstickRight,
        gamepadLeftThumbstickLeft,
        gamepadRightThumbstickUp,
        gamepadRightThumbstickDown,
        gamepadRightThumbstickRight,
        gamepadRightThumbstickLeft
    }

    enum VirtualKeyModifiers {
        none,
        control,
        menu,
        shift,
        windows
    }

}
declare module Windows.System.Diagnostics {

    export interface IProcessCpuUsage {
        getReport(): Windows.System.Diagnostics.ProcessCpuUsageReport;
    }

    export interface IProcessCpuUsageReport {
        kernelTime: Windows.Foundation.TimeSpan;
        userTime: Windows.Foundation.TimeSpan;
    }

    export interface IProcessDiagnosticInfo {
        cpuUsage: Windows.System.Diagnostics.ProcessCpuUsage;
        diskUsage: Windows.System.Diagnostics.ProcessDiskUsage;
        executableFileName: string;
        memoryUsage: Windows.System.Diagnostics.ProcessMemoryUsage;
        parent: Windows.System.Diagnostics.ProcessDiagnosticInfo;
        processId: number;
        processStartTime: Date;
    }

    export interface IProcessDiskUsage {
        getReport(): Windows.System.Diagnostics.ProcessDiskUsageReport;
    }

    export interface IProcessDiskUsageReport {
        bytesReadCount: number;
        bytesWrittenCount: number;
        otherBytesCount: number;
        otherOperationCount: number;
        readOperationCount: number;
        writeOperationCount: number;
    }

    export interface IProcessMemoryUsage {
        getReport(): Windows.System.Diagnostics.ProcessMemoryUsageReport;
    }

    export interface IProcessMemoryUsageReport {
        nonPagedPoolSizeInBytes: number;
        pageFaultCount: number;
        pageFileSizeInBytes: number;
        pagedPoolSizeInBytes: number;
        peakNonPagedPoolSizeInBytes: number;
        peakPageFileSizeInBytes: number;
        peakPagedPoolSizeInBytes: number;
        peakVirtualMemorySizeInBytes: number;
        peakWorkingSetSizeInBytes: number;
        privatePageCount: number;
        virtualMemorySizeInBytes: number;
        workingSetSizeInBytes: number;
    }

    export class ProcessCpuUsage implements Windows.System.Diagnostics.IProcessCpuUsage {
        getReport(): Windows.System.Diagnostics.ProcessCpuUsageReport;
    }

    export class ProcessCpuUsageReport implements Windows.System.Diagnostics.IProcessCpuUsageReport {
        kernelTime: Windows.Foundation.TimeSpan;
        userTime: Windows.Foundation.TimeSpan;
    }

    export class ProcessDiagnosticInfo implements Windows.System.Diagnostics.IProcessDiagnosticInfo {
        static getForProcesses(): Windows.Foundation.Collections.IVectorView<Windows.System.Diagnostics.ProcessDiagnosticInfo>;
        static getForCurrentProcess(): Windows.System.Diagnostics.ProcessDiagnosticInfo;
        cpuUsage: Windows.System.Diagnostics.ProcessCpuUsage;
        diskUsage: Windows.System.Diagnostics.ProcessDiskUsage;
        executableFileName: string;
        memoryUsage: Windows.System.Diagnostics.ProcessMemoryUsage;
        parent: Windows.System.Diagnostics.ProcessDiagnosticInfo;
        processId: number;
        processStartTime: Date;
    }

    export class ProcessDiskUsage implements Windows.System.Diagnostics.IProcessDiskUsage {
        getReport(): Windows.System.Diagnostics.ProcessDiskUsageReport;
    }

    export class ProcessDiskUsageReport implements Windows.System.Diagnostics.IProcessDiskUsageReport {
        bytesReadCount: number;
        bytesWrittenCount: number;
        otherBytesCount: number;
        otherOperationCount: number;
        readOperationCount: number;
        writeOperationCount: number;
    }

    export class ProcessMemoryUsage implements Windows.System.Diagnostics.IProcessMemoryUsage {
        getReport(): Windows.System.Diagnostics.ProcessMemoryUsageReport;
    }

    export class ProcessMemoryUsageReport implements Windows.System.Diagnostics.IProcessMemoryUsageReport {
        nonPagedPoolSizeInBytes: number;
        pageFaultCount: number;
        pageFileSizeInBytes: number;
        pagedPoolSizeInBytes: number;
        peakNonPagedPoolSizeInBytes: number;
        peakPageFileSizeInBytes: number;
        peakPagedPoolSizeInBytes: number;
        peakVirtualMemorySizeInBytes: number;
        peakWorkingSetSizeInBytes: number;
        privatePageCount: number;
        virtualMemorySizeInBytes: number;
        workingSetSizeInBytes: number;
    }

}
declare module Windows.System.Display {

    export class DisplayRequest implements Windows.System.Display.IDisplayRequest {
        constructor();
        requestActive(): void;
        requestRelease(): void;
    }

    export interface IDisplayRequest {
        requestActive(): void;
        requestRelease(): void;
    }

}
declare module Windows.System.Power {

    export class BackgroundEnergyManager {
        static excessiveUsageLevel: number;
        static lowUsageLevel: number;
        static maxAcceptableUsageLevel: number;
        static nearMaxAcceptableUsageLevel: number;
        static nearTerminationUsageLevel: number;
        static recentEnergyUsage: number;
        static recentEnergyUsageLevel: number;
        static terminationUsageLevel: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        onrecentenergyusageincreased: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>): void;
        onrecentenergyusagereturnedtolow: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    enum BatteryStatus {
        notPresent,
        discharging,
        idle,
        charging
    }

    enum EnergySaverStatus {
        disabled,
        off,
        on
    }

    export class ForegroundEnergyManager {
        static excessiveUsageLevel: number;
        static lowUsageLevel: number;
        static maxAcceptableUsageLevel: number;
        static nearMaxAcceptableUsageLevel: number;
        static recentEnergyUsage: number;
        static recentEnergyUsageLevel: number;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recentenergyusageincreased", listener: Windows.Foundation.EventHandler<any>): void;
        onrecentenergyusageincreased: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "recentenergyusagereturnedtolow", listener: Windows.Foundation.EventHandler<any>): void;
        onrecentenergyusagereturnedtolow: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class PowerManager {
        static batteryStatus: Windows.System.Power.BatteryStatus;
        static energySaverStatus: Windows.System.Power.EnergySaverStatus;
        static powerSupplyStatus: Windows.System.Power.PowerSupplyStatus;
        static remainingChargePercent: number;
        static remainingDischargeTime: Windows.Foundation.TimeSpan;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "batterystatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "batterystatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onbatterystatuschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "energysaverstatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "energysaverstatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onenergysaverstatuschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "powersupplystatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "powersupplystatuschanged", listener: Windows.Foundation.EventHandler<any>): void;
        onpowersupplystatuschanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "remainingchargepercentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "remainingchargepercentchanged", listener: Windows.Foundation.EventHandler<any>): void;
        onremainingchargepercentchanged: (ev: Windows.Foundation.EventHandler<any>) => void;
        addEventListener(eventName: "remainingdischargetimechanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "remainingdischargetimechanged", listener: Windows.Foundation.EventHandler<any>): void;
        onremainingdischargetimechanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    enum PowerSupplyStatus {
        notPresent,
        inadequate,
        adequate
    }

}
declare module Windows.System.Power.Diagnostics {

    export class BackgroundEnergyDiagnostics {
        static computeTotalEnergyUsage(): number;
        static resetTotalEnergyUsage(): void;
        static deviceSpecificConversionFactor: number;
    }

    export class ForegroundEnergyDiagnostics {
        static computeTotalEnergyUsage(): number;
        static resetTotalEnergyUsage(): void;
        static deviceSpecificConversionFactor: number;
    }

}
declare module Windows.System.Profile {

    export class AnalyticsInfo {
        static deviceForm: string;
        static versionInfo: Windows.System.Profile.AnalyticsVersionInfo;
    }

    export class AnalyticsVersionInfo implements Windows.System.Profile.IAnalyticsVersionInfo {
        deviceFamily: string;
        deviceFamilyVersion: string;
    }

    export class HardwareIdentification {
        static getPackageSpecificToken(nonce: Windows.Storage.Streams.IBuffer): Windows.System.Profile.HardwareToken;
    }

    export class HardwareToken implements Windows.System.Profile.IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

    export interface IAnalyticsVersionInfo {
        deviceFamily: string;
        deviceFamilyVersion: string;
    }

    export interface IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

    export interface ISystemIdentificationInfo {
        id: Windows.Storage.Streams.IBuffer;
        source: Windows.System.Profile.SystemIdentificationSource;
    }

    export class KnownRetailInfoProperties {
        static batteryLifeDescription: string;
        static displayDescription: string;
        static displayModelName: string;
        static formFactor: string;
        static frontCameraDescription: string;
        static graphicsDescription: string;
        static hasNfc: string;
        static hasOpticalDrive: string;
        static hasSdSlot: string;
        static isFeatured: string;
        static isOfficeInstalled: string;
        static manufacturerName: string;
        static memory: string;
        static modelName: string;
        static price: string;
        static processorDescription: string;
        static rearCameraDescription: string;
        static retailAccessCode: string;
        static screenSize: string;
        static storageDescription: string;
        static weight: string;
        static windowsEdition: string;
    }

    enum PlatformDataCollectionLevel {
        security,
        basic,
        enhanced,
        full
    }

    export class PlatformDiagnosticsAndUsageDataSettings {
        static canCollectDiagnostics(level: Windows.System.Profile.PlatformDataCollectionLevel): boolean;
        static collectionLevel: Windows.System.Profile.PlatformDataCollectionLevel;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "collectionlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "collectionlevelchanged", listener: Windows.Foundation.EventHandler<any>): void;
        oncollectionlevelchanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class ProfileHardwareTokenContract {
    }

    export class ProfileRetailInfoContract {
    }

    export class ProfileSharedModeContract {
    }

    export class RetailInfo {
        static isDemoModeEnabled: boolean;
        static properties: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class SharedModeSettings {
        static isEnabled: boolean;
    }

    export class SystemIdentification {
        static getSystemIdForPublisher(): Windows.System.Profile.SystemIdentificationInfo;
        static getSystemIdForUser(user: Windows.System.User): Windows.System.Profile.SystemIdentificationInfo;
    }

    export class SystemIdentificationInfo implements Windows.System.Profile.ISystemIdentificationInfo {
        id: Windows.Storage.Streams.IBuffer;
        source: Windows.System.Profile.SystemIdentificationSource;
    }

    enum SystemIdentificationSource {
        none,
        tpm,
        uefi
    }

}
declare module Windows.System.Profile.SystemManufacturers {

    export class SmbiosInformation {
        static serialNumber: string;
    }

    export class SystemManufacturersContract {
    }

}
declare module Windows.System.RemoteDesktop {

    export class InteractiveSession {
        static isRemote: boolean;
    }

}
declare module Windows.System.RemoteSystems {

    export interface IRemoteSystem {
        displayName: string;
        id: string;
        isAvailableByProximity: boolean;
        kind: string;
        status: Windows.System.RemoteSystems.RemoteSystemStatus;
    }

    export interface IRemoteSystemAddedEventArgs {
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    export interface IRemoteSystemConnectionRequest {
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    export interface IRemoteSystemDiscoveryTypeFilter {
        remoteSystemDiscoveryType: Windows.System.RemoteSystems.RemoteSystemDiscoveryType;
    }

    export interface IRemoteSystemFilter {
    }

    export interface IRemoteSystemKindFilter {
        remoteSystemKinds: Windows.Foundation.Collections.IVectorView<string>;
    }

    export interface IRemoteSystemRemovedEventArgs {
        remoteSystemId: string;
    }

    export interface IRemoteSystemStatusTypeFilter {
        remoteSystemStatusType: Windows.System.RemoteSystems.RemoteSystemStatusType;
    }

    export interface IRemoteSystemUpdatedEventArgs {
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    export interface IRemoteSystemWatcher {
        start(): void;
        stop(): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "remotesystemadded", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>): void;
        removeEventListener(eventName: "remotesystemadded", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>): void;
        onremotesystemadded: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>) => void;
        addEventListener(eventName: "remotesystemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>): void;
        removeEventListener(eventName: "remotesystemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>): void;
        onremotesystemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>) => void;
        addEventListener(eventName: "remotesystemupdated", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>): void;
        removeEventListener(eventName: "remotesystemupdated", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>): void;
        onremotesystemupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>) => void;

    }

    export class RemoteSystem implements Windows.System.RemoteSystems.IRemoteSystem {
        static findByHostNameAsync(hostName: Windows.Networking.HostName): Windows.Foundation.IAsyncOperation<Windows.System.RemoteSystems.RemoteSystem>;
        static createWatcher(): Windows.System.RemoteSystems.RemoteSystemWatcher;
        static createWatcher(filters: Windows.Foundation.Collections.IIterable<Windows.System.RemoteSystems.IRemoteSystemFilter>): Windows.System.RemoteSystems.RemoteSystemWatcher;
        static requestAccessAsync(): Windows.Foundation.IAsyncOperation<Windows.System.RemoteSystems.RemoteSystemAccessStatus>;
        displayName: string;
        id: string;
        isAvailableByProximity: boolean;
        kind: string;
        status: Windows.System.RemoteSystems.RemoteSystemStatus;
    }

    enum RemoteSystemAccessStatus {
        unspecified,
        allowed,
        deniedByUser,
        deniedBySystem
    }

    export class RemoteSystemAddedEventArgs implements Windows.System.RemoteSystems.IRemoteSystemAddedEventArgs {
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    export class RemoteSystemConnectionRequest implements Windows.System.RemoteSystems.IRemoteSystemConnectionRequest {
        constructor(remoteSystem: Windows.System.RemoteSystems.RemoteSystem);
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    enum RemoteSystemDiscoveryType {
        any,
        proximal,
        cloud
    }

    export class RemoteSystemDiscoveryTypeFilter implements Windows.System.RemoteSystems.IRemoteSystemDiscoveryTypeFilter, Windows.System.RemoteSystems.IRemoteSystemFilter {
        constructor(discoveryType: Windows.System.RemoteSystems.RemoteSystemDiscoveryType);
        remoteSystemDiscoveryType: Windows.System.RemoteSystems.RemoteSystemDiscoveryType;
    }

    export class RemoteSystemKindFilter implements Windows.System.RemoteSystems.IRemoteSystemKindFilter, Windows.System.RemoteSystems.IRemoteSystemFilter {
        constructor(remoteSystemKinds: Windows.Foundation.Collections.IIterable<string>);
        remoteSystemKinds: Windows.Foundation.Collections.IVectorView<string>;
    }

    export class RemoteSystemKinds {
        static desktop: string;
        static holographic: string;
        static hub: string;
        static phone: string;
        static xbox: string;
    }

    export class RemoteSystemRemovedEventArgs implements Windows.System.RemoteSystems.IRemoteSystemRemovedEventArgs {
        remoteSystemId: string;
    }

    enum RemoteSystemStatus {
        unavailable,
        discoveringAvailability,
        available,
        unknown
    }

    enum RemoteSystemStatusType {
        any,
        available
    }

    export class RemoteSystemStatusTypeFilter implements Windows.System.RemoteSystems.IRemoteSystemStatusTypeFilter, Windows.System.RemoteSystems.IRemoteSystemFilter {
        constructor(remoteSystemStatusType: Windows.System.RemoteSystems.RemoteSystemStatusType);
        remoteSystemStatusType: Windows.System.RemoteSystems.RemoteSystemStatusType;
    }

    export class RemoteSystemUpdatedEventArgs implements Windows.System.RemoteSystems.IRemoteSystemUpdatedEventArgs {
        remoteSystem: Windows.System.RemoteSystems.RemoteSystem;
    }

    export class RemoteSystemWatcher implements Windows.System.RemoteSystems.IRemoteSystemWatcher {
        start(): void;
        stop(): void;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "remotesystemadded", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>): void;
        removeEventListener(eventName: "remotesystemadded", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>): void;
        onremotesystemadded: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemAddedEventArgs>) => void;
        addEventListener(eventName: "remotesystemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>): void;
        removeEventListener(eventName: "remotesystemremoved", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>): void;
        onremotesystemremoved: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemRemovedEventArgs>) => void;
        addEventListener(eventName: "remotesystemupdated", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>): void;
        removeEventListener(eventName: "remotesystemupdated", listener: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>): void;
        onremotesystemupdated: (ev: Windows.Foundation.TypedEventHandler<Windows.System.RemoteSystems.RemoteSystemWatcher,Windows.System.RemoteSystems.RemoteSystemUpdatedEventArgs>) => void;

    }

}
declare module Windows.System.Threading.Core {

    export interface IPreallocatedWorkItem {
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface ISignalNotifier {
        enable(): void;
        terminate(): void;
    }

    export class PreallocatedWorkItem implements Windows.System.Threading.Core.IPreallocatedWorkItem {
        constructor(handler: Windows.System.Threading.WorkItemHandler);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions);
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface SignalHandler {
        target: Windows.System.Threading.Core.SignalNotifier;
        detail: any[];
        type: string;
    }

    export class SignalNotifier implements Windows.System.Threading.Core.ISignalNotifier {
        enable(): void;
        terminate(): void;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
    }

}
declare module Windows.System.Threading {

    export interface IThreadPoolTimer {
        cancel(): void;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export class ThreadPool {
        static runAsync(handler: Windows.System.Threading.WorkItemHandler): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions): Windows.Foundation.IAsyncAction;
    }

    export class ThreadPoolTimer implements Windows.System.Threading.IThreadPoolTimer {
        cancel(): void;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
    }

    export interface TimerDestroyedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface TimerElapsedHandler {
        target: Windows.System.Threading.ThreadPoolTimer;
        detail: any[];
        type: string;
    }

    export interface WorkItemHandler {
        target: Windows.Foundation.IAsyncAction;
        detail: any[];
        type: string;
    }

    enum WorkItemOptions {
        none,
        timeSliced
    }

    enum WorkItemPriority {
        low,
        normal,
        high
    }

}
declare module Windows.System.UserProfile {

    enum AccountPictureKind {
        smallImage,
        largeImage,
        video
    }

    export class AdvertisingManager {
        static getForUser(user: Windows.System.User): Windows.System.UserProfile.AdvertisingManagerForUser;
        static advertisingId: string;
    }

    export class AdvertisingManagerForUser implements Windows.System.UserProfile.IAdvertisingManagerForUser {
        advertisingId: string;
        user: Windows.System.User;
    }

    export class FirstSignInSettings implements Windows.System.UserProfile.IFirstSignInSettings, Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        lookup(key: string): any;
        hasKey(key: string): boolean;
        split(): FirstSignInSettings_split_OUT_28;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
        static getDefault(): Windows.System.UserProfile.FirstSignInSettings;
        size: number;
    }

    interface FirstSignInSettings_split_OUT_28 {
        first: Windows.Foundation.Collections.IMapView<string,any>;
        second: Windows.Foundation.Collections.IMapView<string,any>;
    }

    export class GlobalizationPreferences {
        static calendars: Windows.Foundation.Collections.IVectorView<string>;
        static clocks: Windows.Foundation.Collections.IVectorView<string>;
        static currencies: Windows.Foundation.Collections.IVectorView<string>;
        static homeGeographicRegion: string;
        static languages: Windows.Foundation.Collections.IVectorView<string>;
        static weekStartsOn: Windows.Globalization.DayOfWeek;
    }

    export interface IAdvertisingManagerForUser {
        advertisingId: string;
        user: Windows.System.User;
    }

    export interface IFirstSignInSettings extends Windows.Foundation.Collections.IMapView<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
    }

    export interface IUserProfilePersonalizationSettings {
        trySetLockScreenImageAsync(imageFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        trySetWallpaperImageAsync(imageFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncOperation<boolean>;
    }

    export class LockScreen {
        static requestSetImageFeedAsync(syndicationFeedUri: Windows.Foundation.Uri): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetImageFeedResult>;
        static tryRemoveImageFeed(): boolean;
        static getImageStream(): Windows.Storage.Streams.IRandomAccessStream;
        static setImageFileAsync(value: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static setImageStreamAsync(value: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
        static originalImageFile: Windows.Foundation.Uri;
    }

    enum SetAccountPictureResult {
        success,
        changeDisabled,
        largeOrDynamicError,
        videoFrameSizeError,
        fileSizeError,
        failure
    }

    enum SetImageFeedResult {
        success,
        changeDisabled,
        userCanceled
    }

    export class UserInformation {
        static getAccountPicture(kind: Windows.System.UserProfile.AccountPictureKind): Windows.Storage.IStorageFile;
        static setAccountPictureAsync(image: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesAsync(smallImage: Windows.Storage.IStorageFile, largeImage: Windows.Storage.IStorageFile, video: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPictureFromStreamAsync(image: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesFromStreamsAsync(smallImage: Windows.Storage.Streams.IRandomAccessStream, largeImage: Windows.Storage.Streams.IRandomAccessStream, video: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncOperation<Windows.System.UserProfile.SetAccountPictureResult>;
        static getDisplayNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getFirstNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getLastNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getPrincipalNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static getSessionInitiationProtocolUriAsync(): Windows.Foundation.IAsyncOperation<Windows.Foundation.Uri>;
        static getDomainNameAsync(): Windows.Foundation.IAsyncOperation<string>;
        static accountPictureChangeEnabled: boolean;
        static nameAccessAllowed: boolean;
        // Events
        addEventListener(eventName: string, listener: any): void;
        removeEventListener(eventName: string, listener: any): void;
        addEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        removeEventListener(eventName: "accountpicturechanged", listener: Windows.Foundation.EventHandler<any>): void;
        onaccountpicturechanged: (ev: Windows.Foundation.EventHandler<any>) => void;

    }

    export class UserProfileContract {
    }

    export class UserProfileLockScreenContract {
    }

    export class UserProfilePersonalizationSettings implements Windows.System.UserProfile.IUserProfilePersonalizationSettings {
        trySetLockScreenImageAsync(imageFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        trySetWallpaperImageAsync(imageFile: Windows.Storage.StorageFile): Windows.Foundation.IAsyncOperation<boolean>;
        static isSupported(): boolean;
        static current: Windows.System.UserProfile.UserProfilePersonalizationSettings;
    }

}

