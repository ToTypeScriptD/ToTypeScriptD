declare module Windows.Foundation {

    export class AsyncActionCompletedHandler {
        constructor(object: any, method: number);
        invoke(asyncInfo: Windows.Foundation.IAsyncAction, asyncStatus: Windows.Foundation.AsyncStatus): void;
    }

    export class AsyncActionProgressHandler<TProgress> {
        constructor(object: any, method: number);
        invoke(asyncInfo: Windows.Foundation.IAsyncActionWithProgress<TProgress>, progressInfo: TProgress): void;
    }

    export class AsyncActionWithProgressCompletedHandler<TProgress> {
        constructor(object: any, method: number);
        invoke(asyncInfo: Windows.Foundation.IAsyncActionWithProgress<TProgress>, asyncStatus: Windows.Foundation.AsyncStatus): void;
    }

    export class AsyncOperationCompletedHandler<TResult> {
        constructor(object: any, method: number);
        invoke(asyncInfo: ToTypeScriptD.WinRT.IPromise<TResult>, asyncStatus: Windows.Foundation.AsyncStatus): void;
    }

    export class AsyncOperationProgressHandler<TResult, TProgress> {
        constructor(object: any, method: number);
        invoke(asyncInfo: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>, progressInfo: TProgress): void;
    }

    export class AsyncOperationWithProgressCompletedHandler<TResult, TProgress> {
        constructor(object: any, method: number);
        invoke(asyncInfo: Windows.Foundation.IAsyncOperationWithProgress<TResult,TProgress>, asyncStatus: Windows.Foundation.AsyncStatus): void;
    }

    enum AsyncStatus {
        started,
        completed,
        canceled,
        error
    }

    export class DateTime {
        universalTime: number;
    }

    export class EventHandler<T> {
        constructor(object: any, method: number);
        invoke(sender: any, args: T): void;
    }

    export class EventRegistrationToken {
        value: number;
    }

    export class HResult {
        value: number;
    }

    export interface IAsyncAction extends Windows.Foundation.IAsyncInfo {
        completed: Windows.Foundation.AsyncActionCompletedHandler;
        getResults(): void;
    }

    export interface IAsyncActionWithProgress<TProgress> extends Windows.Foundation.IAsyncInfo {
        progress: Windows.Foundation.AsyncActionProgressHandler<TProgress>;
        completed: Windows.Foundation.AsyncActionWithProgressCompletedHandler<TProgress>;
        getResults(): void;
    }

    export interface IAsyncInfo {
        errorCode: Windows.Foundation.HResult;
        id: number;
        status: Windows.Foundation.AsyncStatus;
        cancel(): void;
        close(): void;
    }

    export interface IAsyncOperation<TResult> extends Windows.Foundation.IAsyncInfo {
        completed: Windows.Foundation.AsyncOperationCompletedHandler<TResult>;
        getResults(): TResult;
    }

    export interface IAsyncOperationWithProgress<TResult, TProgress> extends Windows.Foundation.IAsyncInfo {
        progress: Windows.Foundation.AsyncOperationProgressHandler<TResult,TProgress>;
        completed: Windows.Foundation.AsyncOperationWithProgressCompletedHandler<TResult,TProgress>;
        getResults(): TResult;
    }

    export interface IClosable {
        close(): void;
    }

    export interface IGetActivationFactory {
        getActivationFactory(activatableClassId: string): any;
    }

    export interface IPropertyValue {
        isNumericScalar: boolean;
        type: Windows.Foundation.PropertyType;
        getUInt8(): number;
        getInt16(): number;
        getUInt16(): number;
        getInt32(): number;
        getUInt32(): number;
        getInt64(): number;
        getUInt64(): number;
        getSingle(): number;
        getDouble(): number;
        getChar16(): number;
        getBoolean(): boolean;
        getString(): string;
        getGuid(): string;
        getDateTime(): Date;
        getTimeSpan(): Windows.Foundation.TimeSpan;
        getPoint(): Windows.Foundation.Point;
        getSize(): Windows.Foundation.Size;
        getRect(): Windows.Foundation.Rect;
        getUInt8Array(): IPropertyValue_getUInt8Array_OUT;
        getInt16Array(): IPropertyValue_getInt16Array_OUT;
        getUInt16Array(): IPropertyValue_getUInt16Array_OUT;
        getInt32Array(): IPropertyValue_getInt32Array_OUT;
        getUInt32Array(): IPropertyValue_getUInt32Array_OUT;
        getInt64Array(): IPropertyValue_getInt64Array_OUT;
        getUInt64Array(): IPropertyValue_getUInt64Array_OUT;
        getSingleArray(): IPropertyValue_getSingleArray_OUT;
        getDoubleArray(): IPropertyValue_getDoubleArray_OUT;
        getChar16Array(): IPropertyValue_getChar16Array_OUT;
        getBooleanArray(): IPropertyValue_getBooleanArray_OUT;
        getStringArray(): IPropertyValue_getStringArray_OUT;
        getInspectableArray(): IPropertyValue_getInspectableArray_OUT;
        getGuidArray(): IPropertyValue_getGuidArray_OUT;
        getDateTimeArray(): IPropertyValue_getDateTimeArray_OUT;
        getTimeSpanArray(): IPropertyValue_getTimeSpanArray_OUT;
        getPointArray(): IPropertyValue_getPointArray_OUT;
        getSizeArray(): IPropertyValue_getSizeArray_OUT;
        getRectArray(): IPropertyValue_getRectArray_OUT;
    }

    interface IPropertyValue_getUInt8Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt32Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getUInt64Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getSingleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getDoubleArray_OUT {
        value: number[];
    }

    interface IPropertyValue_getChar16Array_OUT {
        value: number[];
    }

    interface IPropertyValue_getBooleanArray_OUT {
        value: boolean[];
    }

    interface IPropertyValue_getStringArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getInspectableArray_OUT {
        value: any[];
    }

    interface IPropertyValue_getGuidArray_OUT {
        value: string[];
    }

    interface IPropertyValue_getDateTimeArray_OUT {
        value: Date[];
    }

    interface IPropertyValue_getTimeSpanArray_OUT {
        value: Windows.Foundation.TimeSpan[];
    }

    interface IPropertyValue_getPointArray_OUT {
        value: Windows.Foundation.Point[];
    }

    interface IPropertyValue_getSizeArray_OUT {
        value: Windows.Foundation.Size[];
    }

    interface IPropertyValue_getRectArray_OUT {
        value: Windows.Foundation.Rect[];
    }

    export interface IReference<T> extends Windows.Foundation.IPropertyValue {
        value: T;
    }

    export interface IReferenceArray<T> extends Windows.Foundation.IPropertyValue {
        value: T[];
    }

    export interface IUriRuntimeClass {
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
    }

    export interface IUriRuntimeClassWithAbsoluteCanonicalUri {
        absoluteCanonicalUri: string;
        displayIri: string;
    }

    export interface IWwwFormUrlDecoderEntry {
        name: string;
        value: string;
    }

    export interface IWwwFormUrlDecoderRuntimeClass extends Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        getFirstValueByName(name: string): string;
    }

    export class Point {
        x: number;
        y: number;
    }

    enum PropertyType {
        empty,
        uInt8,
        int16,
        uInt16,
        int32,
        uInt32,
        int64,
        uInt64,
        single,
        double,
        char16,
        boolean,
        string,
        inspectable,
        dateTime,
        timeSpan,
        guid,
        point,
        size,
        rect,
        otherType,
        uInt8Array,
        int16Array,
        uInt16Array,
        int32Array,
        uInt32Array,
        int64Array,
        uInt64Array,
        singleArray,
        doubleArray,
        char16Array,
        booleanArray,
        stringArray,
        inspectableArray,
        dateTimeArray,
        timeSpanArray,
        guidArray,
        pointArray,
        sizeArray,
        rectArray,
        otherTypeArray
    }

    export class PropertyValue {
        static createEmpty(): any;
        static createUInt8(value: number): any;
        static createInt16(value: number): any;
        static createUInt16(value: number): any;
        static createInt32(value: number): any;
        static createUInt32(value: number): any;
        static createInt64(value: number): any;
        static createUInt64(value: number): any;
        static createSingle(value: number): any;
        static createDouble(value: number): any;
        static createChar16(value: number): any;
        static createBoolean(value: boolean): any;
        static createString(value: string): any;
        static createInspectable(value: any): any;
        static createGuid(value: string): any;
        static createDateTime(value: Date): any;
        static createTimeSpan(value: Windows.Foundation.TimeSpan): any;
        static createPoint(value: Windows.Foundation.Point): any;
        static createSize(value: Windows.Foundation.Size): any;
        static createRect(value: Windows.Foundation.Rect): any;
        static createUInt8Array(value: any): any;
        static createInt16Array(value: number[]): any;
        static createUInt16Array(value: number[]): any;
        static createInt32Array(value: number[]): any;
        static createUInt32Array(value: number[]): any;
        static createInt64Array(value: number[]): any;
        static createUInt64Array(value: number[]): any;
        static createSingleArray(value: number[]): any;
        static createDoubleArray(value: number[]): any;
        static createChar16Array(value: number[]): any;
        static createBooleanArray(value: boolean[]): any;
        static createStringArray(value: string[]): any;
        static createInspectableArray(value: any[]): any;
        static createGuidArray(value: string[]): any;
        static createDateTimeArray(value: Date[]): any;
        static createTimeSpanArray(value: Windows.Foundation.TimeSpan[]): any;
        static createPointArray(value: Windows.Foundation.Point[]): any;
        static createSizeArray(value: Windows.Foundation.Size[]): any;
        static createRectArray(value: Windows.Foundation.Rect[]): any;
    }

    export class Rect {
        x: number;
        y: number;
        width: number;
        height: number;
    }

    export class Size {
        width: number;
        height: number;
    }

    export class TimeSpan {
        duration: number;
    }

    export class TypedEventHandler<TSender, TResult> {
        constructor(object: any, method: number);
        invoke(sender: TSender, args: TResult): void;
    }

    export class Uri implements Windows.Foundation.IUriRuntimeClass, Windows.Foundation.IUriRuntimeClassWithAbsoluteCanonicalUri {
        absoluteUri: string;
        displayUri: string;
        domain: string;
        extension: string;
        fragment: string;
        host: string;
        password: string;
        path: string;
        port: number;
        query: string;
        queryParsed: Windows.Foundation.WwwFormUrlDecoder;
        rawUri: string;
        schemeName: string;
        suspicious: boolean;
        userName: string;
        absoluteCanonicalUri: string;
        displayIri: string;
        constructor(uri: string);
        constructor(baseUri: string, relativeUri: string);
        equals(pUri: Windows.Foundation.Uri): boolean;
        combineUri(relativeUri: string): Windows.Foundation.Uri;
        static unescapeComponent(toUnescape: string): string;
        static escapeComponent(toEscape: string): string;
    }

    export class WwwFormUrlDecoder implements Windows.Foundation.IWwwFormUrlDecoderRuntimeClass, Windows.Foundation.Collections.IIterable<Windows.Foundation.IWwwFormUrlDecoderEntry>, Windows.Foundation.Collections.IVectorView<Windows.Foundation.IWwwFormUrlDecoderEntry> {
        size: number;
        constructor(query: string);
        getFirstValueByName(name: string): string;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.IWwwFormUrlDecoderEntry>;
        getAt(index: number): Windows.Foundation.IWwwFormUrlDecoderEntry;
        indexOf(value: Windows.Foundation.IWwwFormUrlDecoderEntry): WwwFormUrlDecoder_indexOf_OUT;
        getMany(startIndex: number): WwwFormUrlDecoder_getMany_OUT;
    }

    interface WwwFormUrlDecoder_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface WwwFormUrlDecoder_getMany_OUT {
        __returnValue: number;
        items: Windows.Foundation.IWwwFormUrlDecoderEntry[];
    }

}
declare module Windows.Foundation.Collections {

    enum CollectionChange {
        reset,
        itemInserted,
        itemRemoved,
        itemChanged
    }

    export interface IIterable<T> {
        first(): Windows.Foundation.Collections.IIterator<T>;
    }

    export interface IIterator<T> {
        current: T;
        hasCurrent: boolean;
        moveNext(): boolean;
        getMany(): IIterator_getMany_OUT;
    }

    interface IIterator_getMany_OUT {
        __returnValue: number;
        items: T[];
    }

    export interface IKeyValuePair<K, V> {
        key: K;
        value: V;
    }

    export interface IMap<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        size: number;
        lookup(key: K): V;
        hasKey(key: K): boolean;
        getView(): Windows.Foundation.Collections.IMapView<K,V>;
        insert(key: K, value: V): boolean;
        remove(key: K): void;
        clear(): void;
    }

    export interface IMapChangedEventArgs<K> {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        key: K;
    }

    export interface IMapView<K, V> extends Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<K,V>> {
        size: number;
        lookup(key: K): V;
        hasKey(key: K): boolean;
        split(): IMapView_split_OUT;
    }

    interface IMapView_split_OUT {
        first: Windows.Foundation.Collections.IMapView<K,V>;
        second: Windows.Foundation.Collections.IMapView<K,V>;
    }

    export interface IObservableMap<K, V> extends Windows.Foundation.Collections.IMap<K,V> {
        addEventListener(type: string, listener: EventListener): void;
        removeEventListener(type: string, listener: EventListener): void;
        onmapchanged(ev: any);
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<K,V>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
    }

    export interface IObservableVector<T> extends Windows.Foundation.Collections.IVector<T> {
        addEventListener(type: string, listener: EventListener): void;
        removeEventListener(type: string, listener: EventListener): void;
        onvectorchanged(ev: any);
        add_VectorChanged(vhnd: Windows.Foundation.Collections.VectorChangedEventHandler<T>): Windows.Foundation.EventRegistrationToken;
        remove_VectorChanged(token: Windows.Foundation.EventRegistrationToken): void;
    }

    export interface IPropertySet extends Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
    }

    export interface IVector<T> extends Windows.Foundation.Collections.IIterable<T> {
        size: number;
        getAt(index: number): T;
        getView(): Windows.Foundation.Collections.IVectorView<T>;
        indexOf(value: T): IVector_indexOf_OUT;
        setAt(index: number, value: T): void;
        insertAt(index: number, value: T): void;
        removeAt(index: number): void;
        append(value: T): void;
        removeAtEnd(): void;
        clear(): void;
        getMany(startIndex: number): IVector_getMany_OUT;
        replaceAll(items: T[]): void;
    }

    interface IVector_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface IVector_getMany_OUT {
        __returnValue: number;
        items: T[];
    }

    export interface IVectorChangedEventArgs {
        collectionChange: Windows.Foundation.Collections.CollectionChange;
        index: number;
    }

    export interface IVectorView<T> extends Windows.Foundation.Collections.IIterable<T> {
        size: number;
        getAt(index: number): T;
        indexOf(value: T): IVectorView_indexOf_OUT;
        getMany(startIndex: number): IVectorView_getMany_OUT;
    }

    interface IVectorView_indexOf_OUT {
        __returnValue: boolean;
        index: number;
    }

    interface IVectorView_getMany_OUT {
        __returnValue: number;
        items: T[];
    }

    export class MapChangedEventHandler<K, V> {
        constructor(object: any, method: number);
        invoke(sender: Windows.Foundation.Collections.IObservableMap<K,V>, event: Windows.Foundation.Collections.IMapChangedEventArgs<K>): void;
    }

    export class PropertySet implements Windows.Foundation.Collections.IPropertySet, Windows.Foundation.Collections.IObservableMap<string,any>, Windows.Foundation.Collections.IMap<string,any>, Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IKeyValuePair<string,any>> {
        addEventListener(type: string, listener: EventListener): void;
        removeEventListener(type: string, listener: EventListener): void;
        onmapchanged(ev: any);
        size: number;
        constructor();
        add_MapChanged(vhnd: Windows.Foundation.Collections.MapChangedEventHandler<string,any>): Windows.Foundation.EventRegistrationToken;
        remove_MapChanged(token: Windows.Foundation.EventRegistrationToken): void;
        lookup(key: string): any;
        hasKey(key: string): boolean;
        getView(): Windows.Foundation.Collections.IMapView<string,any>;
        insert(key: string, value: any): boolean;
        remove(key: string): void;
        clear(): void;
        first(): Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IKeyValuePair<string,any>>;
    }

    export class VectorChangedEventHandler<T> {
        constructor(object: any, method: number);
        invoke(sender: Windows.Foundation.Collections.IObservableVector<T>, event: Windows.Foundation.Collections.IVectorChangedEventArgs): void;
    }

}
declare module Windows.Foundation.Diagnostics {

    enum ErrorOptions {
        none,
        suppressExceptions,
        forceExceptions,
        useSetErrorInfo,
        suppressSetErrorInfo
    }

    export interface IErrorReportingSettings {
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

    export class RuntimeBrokerErrorSettings implements Windows.Foundation.Diagnostics.IErrorReportingSettings {
        constructor();
        setErrorOptions(value: Windows.Foundation.Diagnostics.ErrorOptions): void;
        getErrorOptions(): Windows.Foundation.Diagnostics.ErrorOptions;
    }

}
declare module Windows.Foundation.Metadata {

    export class ActivatableAttribute {
        constructor(version: number);
        constructor(type: System.Type, version: number);
    }

    export class AllowMultipleAttribute {
        constructor();
    }

    enum AttributeTargets {
        delegate,
        enum,
        event,
        field,
        interface,
        method,
        parameter,
        property,
        runtimeClass,
        struct,
        interfaceImpl,
        all
    }

    export class AttributeUsageAttribute {
        constructor(targets: Windows.Foundation.Metadata.AttributeTargets);
    }

    export class ComposableAttribute {
        constructor(type: System.Type, compositionType: Windows.Foundation.Metadata.CompositionType, version: number);
    }

    enum CompositionType {
        protected,
        public
    }

    export class DefaultAttribute {
        constructor();
    }

    export class DefaultOverloadAttribute {
        constructor();
    }

    export class DualApiPartitionAttribute {
        version: number;
        constructor();
    }

    export class ExclusiveToAttribute {
        constructor(typeName: System.Type);
    }

    enum GCPressureAmount {
        low,
        medium,
        high
    }

    export class GCPressureAttribute {
        amount: Windows.Foundation.Metadata.GCPressureAmount;
        constructor();
    }

    export class GuidAttribute {
        constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: number, i: number, j: number, k: number);
    }

    export class HasVariantAttribute {
        constructor();
    }

    export class LengthIsAttribute {
        constructor(indexLengthParameter: number);
    }

    export class MarshalingBehaviorAttribute {
        constructor(behavior: Windows.Foundation.Metadata.MarshalingType);
    }

    enum MarshalingType {
        invalidMarshaling,
        none,
        agile,
        standard
    }

    export class MuseAttribute {
        version: number;
        constructor();
    }

    export class OverloadAttribute {
        constructor(method: string);
    }

    export class OverridableAttribute {
        constructor();
    }

    export class ProtectedAttribute {
        constructor();
    }

    export class RangeAttribute {
        constructor(minValue: number, maxValue: number);
    }

    export class StaticAttribute {
        constructor(type: System.Type, version: number);
    }

    export class ThreadingAttribute {
        constructor(model: Windows.Foundation.Metadata.ThreadingModel);
    }

    enum ThreadingModel {
        invalidThreading,
        sta,
        mta,
        both
    }

    export class VariantAttribute {
        constructor();
    }

    export class VersionAttribute {
        constructor(version: number);
    }

    export class WebHostHiddenAttribute {
        constructor();
    }

}
declare module Windows.System.Display {

    export class DisplayRequest implements Windows.System.Display.IDisplayRequest {
        constructor();
        requestActive(): void;
        requestRelease(): void;
    }

    export interface IDisplayRequest {
        requestActive(): void;
        requestRelease(): void;
    }

}
declare module Windows.System {

    export interface ILauncherOptions {
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
    }

    export interface ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    export class Launcher {
        static launchFileAsync(file: Windows.Storage.IStorageFile): ToTypeScriptD.WinRT.IPromise<boolean>;
        static launchFileAsync(file: Windows.Storage.IStorageFile, options: Windows.System.LauncherOptions): ToTypeScriptD.WinRT.IPromise<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri): ToTypeScriptD.WinRT.IPromise<boolean>;
        static launchUriAsync(uri: Windows.Foundation.Uri, options: Windows.System.LauncherOptions): ToTypeScriptD.WinRT.IPromise<boolean>;
    }

    export class LauncherOptions implements Windows.System.ILauncherOptions {
        contentType: string;
        displayApplicationPicker: boolean;
        fallbackUri: Windows.Foundation.Uri;
        preferredApplicationDisplayName: string;
        preferredApplicationPackageFamilyName: string;
        treatAsUntrusted: boolean;
        ui: Windows.System.LauncherUIOptions;
        constructor();
    }

    export class LauncherUIOptions implements Windows.System.ILauncherUIOptions {
        invocationPoint: Windows.Foundation.IReference<Windows.Foundation.Point>;
        preferredPlacement: Windows.UI.Popups.Placement;
        selectionRect: Windows.Foundation.IReference<Windows.Foundation.Rect>;
    }

    enum ProcessorArchitecture {
        x86,
        arm,
        x64,
        neutral,
        unknown
    }

    enum VirtualKey {
        none,
        leftButton,
        rightButton,
        cancel,
        middleButton,
        xButton1,
        xButton2,
        back,
        tab,
        clear,
        enter,
        shift,
        control,
        menu,
        pause,
        capitalLock,
        kana,
        hangul,
        junja,
        final,
        hanja,
        kanji,
        escape,
        convert,
        nonConvert,
        accept,
        modeChange,
        space,
        pageUp,
        pageDown,
        end,
        home,
        left,
        up,
        right,
        down,
        select,
        print,
        execute,
        snapshot,
        insert,
        delete,
        help,
        number0,
        number1,
        number2,
        number3,
        number4,
        number5,
        number6,
        number7,
        number8,
        number9,
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z,
        leftWindows,
        rightWindows,
        application,
        sleep,
        numberPad0,
        numberPad1,
        numberPad2,
        numberPad3,
        numberPad4,
        numberPad5,
        numberPad6,
        numberPad7,
        numberPad8,
        numberPad9,
        multiply,
        add,
        separator,
        subtract,
        decimal,
        divide,
        f1,
        f2,
        f3,
        f4,
        f5,
        f6,
        f7,
        f8,
        f9,
        f10,
        f11,
        f12,
        f13,
        f14,
        f15,
        f16,
        f17,
        f18,
        f19,
        f20,
        f21,
        f22,
        f23,
        f24,
        numberKeyLock,
        scroll,
        leftShift,
        rightShift,
        leftControl,
        rightControl,
        leftMenu,
        rightMenu
    }

    enum VirtualKeyModifiers {
        none,
        control,
        menu,
        shift,
        windows
    }

}
declare module Windows.System.Profile {

    export class HardwareIdentification {
        static getPackageSpecificToken(nonce: Windows.Storage.Streams.IBuffer): Windows.System.Profile.HardwareToken;
    }

    export class HardwareToken implements Windows.System.Profile.IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

    export interface IHardwareToken {
        certificate: Windows.Storage.Streams.IBuffer;
        id: Windows.Storage.Streams.IBuffer;
        signature: Windows.Storage.Streams.IBuffer;
    }

}
declare module Windows.System.RemoteDesktop {

    export class InteractiveSession {
        isRemote: boolean;
    }

}
declare module Windows.System.Threading.Core {

    export interface IPreallocatedWorkItem {
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export interface ISignalNotifier {
        enable(): void;
        terminate(): void;
    }

    export class PreallocatedWorkItem implements Windows.System.Threading.Core.IPreallocatedWorkItem {
        constructor(handler: Windows.System.Threading.WorkItemHandler);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority);
        constructor(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions);
        runAsync(): Windows.Foundation.IAsyncAction;
    }

    export class SignalHandler {
        constructor(object: any, method: number);
        invoke(signalNotifier: Windows.System.Threading.Core.SignalNotifier, timedOut: boolean): void;
    }

    export class SignalNotifier implements Windows.System.Threading.Core.ISignalNotifier {
        enable(): void;
        terminate(): void;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToEvent(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler): Windows.System.Threading.Core.SignalNotifier;
        static attachToSemaphore(name: string, handler: Windows.System.Threading.Core.SignalHandler, timeout: Windows.Foundation.TimeSpan): Windows.System.Threading.Core.SignalNotifier;
    }

}
declare module Windows.System.Threading {

    export interface IThreadPoolTimer {
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
        cancel(): void;
    }

    export class ThreadPool {
        static runAsync(handler: Windows.System.Threading.WorkItemHandler): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority): Windows.Foundation.IAsyncAction;
        static runAsync(handler: Windows.System.Threading.WorkItemHandler, priority: Windows.System.Threading.WorkItemPriority, options: Windows.System.Threading.WorkItemOptions): Windows.Foundation.IAsyncAction;
    }

    export class ThreadPoolTimer implements Windows.System.Threading.IThreadPoolTimer {
        delay: Windows.Foundation.TimeSpan;
        period: Windows.Foundation.TimeSpan;
        cancel(): void;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan): Windows.System.Threading.ThreadPoolTimer;
        static createPeriodicTimer(handler: Windows.System.Threading.TimerElapsedHandler, period: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
        static createTimer(handler: Windows.System.Threading.TimerElapsedHandler, delay: Windows.Foundation.TimeSpan, destroyed: Windows.System.Threading.TimerDestroyedHandler): Windows.System.Threading.ThreadPoolTimer;
    }

    export class TimerDestroyedHandler {
        constructor(object: any, method: number);
        invoke(timer: Windows.System.Threading.ThreadPoolTimer): void;
    }

    export class TimerElapsedHandler {
        constructor(object: any, method: number);
        invoke(timer: Windows.System.Threading.ThreadPoolTimer): void;
    }

    export class WorkItemHandler {
        constructor(object: any, method: number);
        invoke(operation: Windows.Foundation.IAsyncAction): void;
    }

    enum WorkItemOptions {
        none,
        timeSliced
    }

    enum WorkItemPriority {
        low,
        normal,
        high
    }

}
declare module Windows.System.UserProfile {

    enum AccountPictureKind {
        smallImage,
        largeImage,
        video
    }

    export class GlobalizationPreferences {
        calendars: Windows.Foundation.Collections.IVectorView<string>;
        clocks: Windows.Foundation.Collections.IVectorView<string>;
        currencies: Windows.Foundation.Collections.IVectorView<string>;
        homeGeographicRegion: string;
        languages: Windows.Foundation.Collections.IVectorView<string>;
        weekStartsOn: Windows.Globalization.DayOfWeek;
    }

    export class LockScreen {
        originalImageFile: Windows.Foundation.Uri;
        static getImageStream(): Windows.Storage.Streams.IRandomAccessStream;
        static setImageFileAsync(value: Windows.Storage.IStorageFile): Windows.Foundation.IAsyncAction;
        static setImageStreamAsync(value: Windows.Storage.Streams.IRandomAccessStream): Windows.Foundation.IAsyncAction;
    }

    enum SetAccountPictureResult {
        success,
        changeDisabled,
        largeOrDynamicError,
        videoFrameSizeError,
        fileSizeError,
        failure
    }

    export class UserInformation {
        addEventListener(type: string, listener: EventListener): void;
        removeEventListener(type: string, listener: EventListener): void;
        onaccountpicturechanged(ev: any);
        accountPictureChangeEnabled: boolean;
        nameAccessAllowed: boolean;
        static getAccountPicture(kind: Windows.System.UserProfile.AccountPictureKind): Windows.Storage.IStorageFile;
        static setAccountPictureAsync(image: Windows.Storage.IStorageFile): ToTypeScriptD.WinRT.IPromise<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesAsync(smallImage: Windows.Storage.IStorageFile, largeImage: Windows.Storage.IStorageFile, video: Windows.Storage.IStorageFile): ToTypeScriptD.WinRT.IPromise<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPictureFromStreamAsync(image: Windows.Storage.Streams.IRandomAccessStream): ToTypeScriptD.WinRT.IPromise<Windows.System.UserProfile.SetAccountPictureResult>;
        static setAccountPicturesFromStreamsAsync(smallImage: Windows.Storage.Streams.IRandomAccessStream, largeImage: Windows.Storage.Streams.IRandomAccessStream, video: Windows.Storage.Streams.IRandomAccessStream): ToTypeScriptD.WinRT.IPromise<Windows.System.UserProfile.SetAccountPictureResult>;
        static add_AccountPictureChanged(changeHandler: Windows.Foundation.EventHandler<any>): Windows.Foundation.EventRegistrationToken;
        static remove_AccountPictureChanged(token: Windows.Foundation.EventRegistrationToken): void;
        static getDisplayNameAsync(): ToTypeScriptD.WinRT.IPromise<string>;
        static getFirstNameAsync(): ToTypeScriptD.WinRT.IPromise<string>;
        static getLastNameAsync(): ToTypeScriptD.WinRT.IPromise<string>;
        static getPrincipalNameAsync(): ToTypeScriptD.WinRT.IPromise<string>;
        static getSessionInitiationProtocolUriAsync(): ToTypeScriptD.WinRT.IPromise<Windows.Foundation.Uri>;
        static getDomainNameAsync(): ToTypeScriptD.WinRT.IPromise<string>;
    }

}

